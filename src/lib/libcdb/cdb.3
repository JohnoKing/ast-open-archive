.TH CDB 3
.SH NAME
\fBcdb\fR \- cql database format library
.SH SYNOPSIS
.de Tp
.fl
.ne 2
.TP
..
.de Ss
.fl
.ne 2
.SS "\\$1"
..
.de Cs
.nf
.ft 5
..
.de Ce
.ft 1
.fi
..
.ta 1.0i 2.0i 3.0i 4.0i 5.0i
.Cs
#include <cdb.h>
.Ce
.Ss "CDB TYPES"
.Cs
Cdb_t;
Cdbdisc_t;
Cdbdata_t;
Cdbformat_t;
.Ce
.Ss "CDB CONTROL"
.Cs
Cdb_t*    cdbopen(const char* path, unsigned long flags, Cdbdisc_t* disc);
int       cdbclose(Cdb_t* cdb);
.Ce
.Ss "DISCIPLINE"
.Cs
typedef int     (*Cdberror_f)(Cdb_t*, Cdbdisc_t*, int, const char*, ...);
typedef struct
{
  unsigned long version;    /* CDB_VERSION                  */
  const char*   schema;     /* schema descriptor            */
  const char*   comment;    /* data specific comment        */
  Cdberror_f    errorf;     /* error function               */
};
.Ce
.Ss "INPUT/OUTPUT OPERATIONS"
.Cs
int       cdbread(Cdb_t* cdb);
int       cdbwrite(Cdb_t* cdb);

int       cdbflatten(Cdb_t* cdb, Sfio_t* output);
int       cdbsplit(Cdb_t* cdb, Sfio_t* input);
.Ce
.Ss "CDB STATUS"
.Cs
char*     cdbschema(Cdb_t* cdb);
.Ce
.SH DESCRIPTION
.I cdb
provides functions to read and write
.IR cql (1)
database format files.
.Ss "CDB FORMAT"
.I cdb
is a portable binary format for databases of uniform records,
where each record is an array of a fixed number of fields.
It is often an efficient alternative to fixed field, delimited field,
or tagged field flat file databases.
.PP
Three field types are supported:
4-byte
.BR long ,
8-byte
.BR double ,
and 0-terminated
.BR string .
.B long
fields are stored using \f5sfputu()/sfgetu()\fP
(see
.IR sfio (3)),
.B double
fields are stored using \f5sfputd()/sfgetd()\fP,
and
.B string
fields are stored with a \f5sfputd()/sfgetd()\fP count
(including the terminating 0) followed by the 0-terminated data,
with the exception that
.B null
strings are stored with a 0 count and no data.
There is no inter-record compression, so individual records are fully seekable.
.PP
.I cdb
is particularly efficient for storing sparse records and approaches
.IR gzip (1)
levels of compression in some cases.
A sparse record contains runs of fields with
.B null
values; 0 for
.BR long ,
0.0 for
.BR double ,
and 0 length for
.BR string ).
Non-sparse data may not compress as much, but record and field processing
will be faster than ASCII flat file processing.
.PP
A
.I cdb
file consists of a header followed the record data.
The functions below provide an abstract interface to the physical layout.
The header layout is:
.Cs
      \fItype\fP     \fIdescription\fP
      4 byte   magic number
      1 byte   major version
      1 byte   minor version
      32 byte  0-terminated comment string
      integer  number of fields
      integer  number of permanent fields
      integer  flags (currently unused)
      1 byte   flat file field delimiter
      integer* <type,size,delimiter> info for each field
      string   tagged header fields: <tag><data>0
      sfputu   terminating 0
.Ce
The magic number is always CDB_MAGIC="\e003\e004\e002\e000",
the current major version is CDB_MAJOR=1, and the current minor
version is CDB_MINOR=0.
Implementation and database major numbers must match; lower minor
numbers will work properly but may not take advantage of all features.
The remaining fields are described below (see \f5cdbopen()\fP.)
There is currently only one optional header field:
\f5S<schema-descriptor>\fP (see \f5cdbschema()\fP.)
.PP
The record layout is:
.Cs

      \fIf\fP\d1\u .. \fIf\fP\d\fIperm\fP\u ( \fIkeep\fP \fIskip\fP \fIf\fP\di\u .. \fIf\fP\d\fIi+keep-1\fP\u )* 0

.Ce
.PP
.I perm
is the number of fields, starting from the beginning, that are present in
every record.
This number may be 0, but is usually at least 1, since most database schemas
use the first field as a key.
Following the permanent fields are zero or more groups of
.IR keep-skip-data .
.I skip
is the number of
.B null
fields to skip counting from the last
.RB non- null
field.
.I keep
is the number of fields to keep after the skip, and
.I data
is the corresponding field data.
The record ends with a 0
.I keep
count.
.Ss "CDB TYPES"
.Ss "  Cdbdisc_t"
This provides data specific information for the
.I cdb
context and is initialized before the \f5cdbopen()\fP call.
It contains the following fields:
.Cs
      unsigned long      version;
      const char*        schema;
      const char*        comment;
      Cdberror_f         errorf;
.Ce
.Tp
\f5version\fP:
Must be initialized to \f5CDB_VERSION\fP.
The implementation checks this value for interface compatibility.
.Tp
\f5schema\fP:
A 0-terminated string that specifies the record schema (see \f5cdbschema()\fP.)
.Tp
\f5comment\fP:
A 0-terminated string limited to \f5CDB_COMMENT\fP bytes including
the terminating 0.
Comment semantics are controlled by the caller.
.Tp
\f5errorf\fP:
.Ss "  Cdb_t"
This is the
.I cdb
context inialized and returned by \f5cdbopen()\fP.
It contains the following fields:
.Cs
      const char*        id;
      unsigned short     delimiter;
      unsigned short     fields;
      unsigned short     permanent;
      unsigned char      major;
      unsigned char      minor;
      unsigned long      flags;
      char               comment[CDB_COMMENT];
      Sfio_t*            io;
      char*              schema;
      Cdbformat_t*       format;
      Cdbdata_t*         data;
.Ce
.Tp
\f5id\fP:
Used by \f5(*errorf)()\fP to identify the library.
.Tp
\f5delimiter\fP:
The flat file field delimiter character.
Used by \f5cdbflatten()\fP and \f5cdbsplit()\fP for external data
representation.
A 0-terminated string that describes the three components of the record schema:
the field delimiter character,
the number of permanent fields,
and the field types.
The field delimiter character is specified by:
.Cs
      d\fIcharacter\fP
.Ce
.SH AUTHORS
Glenn Fowler, gsf@research.att.com
