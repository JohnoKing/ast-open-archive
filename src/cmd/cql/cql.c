/***************************************************************
*                                                              *
*           This software is part of the ast package           *
*              Copyright (c) 1991-2000 AT&T Corp.              *
*      and it may only be used by you under license from       *
*                     AT&T Corp. ("AT&T")                      *
*       A copy of the Source Code Agreement is available       *
*              at the AT&T Internet web site URL               *
*                                                              *
*     http://www.research.att.com/sw/license/ast-open.html     *
*                                                              *
*     If you received this software without first entering     *
*       into a license with AT&T, you have an infringing       *
*           copy and cannot use it without violating           *
*             AT&T's intellectual property rights.             *
*                                                              *
*               This software was created by the               *
*               Network Services Research Center               *
*                      AT&T Labs Research                      *
*                       Florham Park NJ                        *
*                                                              *
*             Glenn Fowler <gsf@research.att.com>              *
*                                                              *
***************************************************************/
#pragma prototyped
/*
 * Glenn Fowler
 * AT&T Research
 *
 * cql -- C query language
 *
 * state.test registry
 *
 *	000001 *temporary*
 *	000002 *temporary*
 *	000004 *temporary*
 *	000010 HIX_TEST1 -- force 1Mb read (no mmap) if >8Mb input
 *	000020 HIX_TEST2 -- force 1Mb mmap if >8Mb input
 *	000040 don't optimize for referenced fields
 *	000100 CDB_TEST1 -- enable flatpureread
 *	000200 CDB_TEST2
 *	000400 force stdin ASSOCIATIVE hash
 *	001000 dump associative hash table info
 *	002000 dump all buckets for prev
 *	004000 cdb format trace
 *	010000 force index generation for small files
 */

static const char usage[] =
"[-?\n@(#)cql (AT&T Labs Research) 1999-11-19\n]"
USAGE_LICENSE
"[+NAME?cql - C query language]"
"[+DESCRIPTION?\bcql\b applies C style expressions to flat database files."
"	It fills the gap between \bawk\b(1) and full blown relational"
"	database management programs. A flat database is a sequence of"
"	\bnewline\b terminated records of \bdelimiter\b separated fields.]"
"[+?Files are processed as follows. \bcql\b first evaluates the \bbegin\b"
"	expression if defined, then sequentially applies the \bselect\b"
"	expression to all records. The \baction\b expression is evaluated"
"	for each record that \bselect\b evaluates to non-0. After all"
"	records have been checked the \bdone\b expression is evaluated if"
"	defined, and \bcql\b exits. The default \bselect\b expression is"
"	\b1\b (all records are selected) and the default \baction\b"
"	expression prints the record on the standard output.]"
"[+?Depending on the input file declarations, \bcql\b may generate index"
"	files for quick record access. Indexes are used to filter out"
"	records for which \bselect\b would evaluate to \b0\b. Index files"
"	are placed in the current directory and each is named by changing"
"	the suffix to \b.hix\b or by adding a \b.hix\b suffix.]"

"[a:active?Run in active mode by reading declarations and expressions from"
"	the standard input. The special sequence \b%%\b separates the"
"	declarations from the expressions. \b%%\b after an expression"
"	applies that expression to the input files. \bEOF\b terminates the"
"	active session. Active mode error message lines are prefixed with"
"	\b%% cql:\b.]"
"[c:compile?If \afile\a matches \b*.c\b then the \bcql\b expression are"
"	converted to C and placed in \afile\a, and \bcql\b exits. \afile\a"
"	may then be compiled with \bcc\b(1). Otherwise \afile\a is assumed"
"	to be a \adll\a (compiled and linked from a \b.c\b file previously"
"	generated by \bclq\b) and is loaded into the current process.]:[file]"
"[e|d:expression?\aexpression\a defines the database schemas and the labelled"
"	expressions that control database traversal. Multiple \b--expression\b"
"	expressions are parsed in order from left to right.]:[expr]"
"[f:file?Equivalent to \b-e \"#include '\afile\b'\"\b.]:[file]"
"[l:local?By default index files are only generated in the directory"
"	containing the data files; \b--local\b causes index files to be"
"	generated in the current directory.]"
"[n!:index?Enable index file generation. If index files must be (re)generated"
"	and \b--noindex\b is on then \bcql\b exits with a diagnostic.]"
"[r:replace?Replace the top level database view with an updated view if there"
"	were updates.]"
"[u:update?Only output updated records. By default all selected records are"
"	output.]"
"[w!:warn?Disable malformed data warning messages. With \b--nowarn\b malformed"
"	records are silently repaired or discarded.]"
"[I:include?Add \adir\a to the list of directories searched for include"
"	and library files. To this list is added the default"
"	\b../lib/cql\b directories on \b$PATH\b.]:[dir]"
"[D:debug?Set the debug trace level to \alevel\a. Higher levels produce"
"	more output.]#[level]"
"[T:test?Inclusive-or \amask\a into the implementation defined test mask."
"	Occasionally a particular mask may be used as a temporary bug"
"	workaround. Otherwise use at your own risk.]#[mask]"
"[g:g2?(obsolete) Enable \bg2\b output mode.]"

"\n"
"\n[ data ]\n"
"\n"

"[+SCHEMAS?A schema is similar to a C \bstruct\b declaration with the"
"	\bstruct\b keyword omitted. A schema specifies names and types for"
"	the fields in a database record. The types are:]{"
"	[+char*?A null-terminated C string.]"
"	[+date_t?A C \bunsigned long\b variable whose string representation"
"		is a date.]"
"	[+elapsed_t?A C \blong\b variable whose string representation is"
"		elapsed time in 1/100 seconds.]"
"	[+float?A C \bdouble\b variable.]"
"	[+hex?A C \bunsigned long\b variable whose string representation"
"		is hexadecimal.]"
"	[+int?A C \blong\b variable.]"
"	[+string?Equivalent to a null-terminated C \bchar*\b.]"
"	[+unsigned?A C \bunsigned long\b variable.]"
"}"
"[+?Schemas are themselves types. \aschema field;\a declares a subfield"
"	within a record and \aschema* field;\a declares a field that indexes"
"	another schema. In this case the \afield\a value is a string key"
"	that is used to match the first field in the referenced schema."
"	The \bregister\b prefix denotes fields that should be indexed;"
"	references to other schemas are always indexed.]"
"[+?The first declared schema becomes the main schema (the schema of the"
"	data to be scanned.) The main schema may also be set by"
"	\bschema=\aschema\b;\b. \aschema\b.delimiter=\"\adelimiter\b\";\b"
"	sets the delimiter for \aschema\a and \aschema\b.input=\"\afile\b\";\b"
"	sets the input to \afile\a. The default delimiter is \"\b;\b\". The"
"	main schema input is the \adata\a command line argument if specified."
"	Otherwise schema input file names are determined by the schema name"
"	with an optional \b.db\b suffix. Multiple schemas may be placed in"
"	a single file using the \bpax\b(1) \bvdb\b archive format.]"

"[+EXPRESSIONS?A labelled expression is defined by one of:]{"
"	[+\alabel :: statement-list\a?]"
"	[+\atype label() { statement-list }\a?]"
"}"
"[+?Supported expression labels are:]{"
"	[+action?Evaluated for each record in which \bselect\b"
"		returns non-zero. The default \baction\b lists each selected"
"		record as it appears in the databse.]"
"	[+begin?Evaluated once before the traversal begins. The return value"
"		is ignored.]"
"	[+end?Evaluated once after the traversal ends. The return value is"
"		ignored.]"
"	[+select?Evaluated once for each record. If the return value is"
"		non-zero then \baction\b is evaluated. The default \bselect\b"
"		return value is always non-zero.]"
"	[+closure?TBD]"
"	[+loop?TBD]"
"}"
"[+?\bselect\b is assumed when \alabel\a: or"
"	\atype label\a() is omitted. \astatement-list\a is composed of"
"	\bexpr\b(3) C style expressions, including \bint \avariable\a, ..."
"	and \bfloat \avariable\a, ... declarations, \b(int)\b and"
"	\b(float)\b casts, \bif\b - \belse\b conditionals, \bfor\b and"
"	\bwhile\b loops, and { ... } blocks. The trailing \b;\b in any"
"	expression is optional. In the absense of a \breturn\b statement"
"	the expression value is the value of the last evaluated expression in"
"	\astatement-list\a. Numbers and comments follow C syntax. String"
"	operands must be quoted with either \"...\" or '...'. String"
"	comparisons (\b==\b and \b!=\b) treat the right hand operand as a"
"	\bksh\b(1) file match pattern.]"
"[+?The expressions operate on the fields in the current input record. The"
"	\bbegin\b and \bend\b expressions operate on a null valued current"
"	record. If a \bdate_t\b type field is an operand to a binary operator"
"	then the other operand may be a string that is interpreted as a"
"	\bdate\b(1) date expression; there is similar treatment for other"
"	types with alternate string representations.]"
"[+?There is also a predefined readonly schema with the following elements:]{"
"	[+elapsed_t clock?The elapsed time in 1/100 seconds since this \bcql\b"
"		started.]"
"	[+date_t date?The date when this \bcql\b started.]"
"	[+int errors?The current soft error count. \bcql\b continues after a"
"		soft error but exits with a non-zero exit status when"
"		complete.]"
"	[+int line?The current input file line number.]"
"	[+int offset?The current input file byte offset.]"
"	[+int record?The current input file record number.]"
"	[+int select?The current number of selected records.]"
"	[+int size?The size in bytes of the current input record.]"
"	[+date_t time?The current date and time.]"
"}"
"[+?The following \bexpr\b(3) functions are also supported:]{"
"	[+cql.getenv(\aname\a)?Returns the value of the environment variable"
"		\aname\a. The empty string is returned for undefined"
"		environment variables.]"
"	[+cql.path(\aname,len\a)?Truncates the file pathname \aname\a to"
"		\alen\a bytes.]"
"	[+?cql.sub(\astring,old,new,flags\a)?Returns the substituted value of"
"		\astring\a the first match of the \begrep\b(1) style regular"
"		expression \aold\a replaced by \anew\a. \aflags\a may be any"
"		combination of:]{"
"		[+g?Substitute all matches of \aold\a.]"
"		[+l?Convert matches to lower case.]"
"		[+u?Convert matches to upper case.]"
"	}"
"	[+exit(\aexpr\a)?Causes \bcql\b to exit with the exit code \aexpr\a."
"		\aexpr\a defaults to 0 if omitted.]"
"	[+printf(\aformat[,arg...]]\a)?Print the arguments on \bstdout\b"
"		using the \bprintf\b(3) specification \aformat\a.]"
"	[+eprintf(\aformat[,arg...]]\a)?Like \bprintf\b but output goes to"
"		\bstderr\b.]"
"	[+query(\aformat[,arg...]]\b)?Prompt with the \bprintf\b(3) message on"
"		\bstderr\b for an interactive response. A line beginning with"
"		\by\b returns 1, \bq\b or \bEOF\b causes \bcql\b to exit"
"		immediately, and any other input returns 0.]"
"}"

"[+SEE ALSO?\bawk\b(1), \bgrep\b(1), \bksh\b(1), \bpax\b(1), \bperl\b(1),"
"	\btw\b(1), \bexpr\b(3), \bprintf\b(3), \btm\b(3)]"
;

#include "cql.h"

#include <dlldefs.h>
#include <proc.h>
#include <vdb.h>
#include <wait.h>

/*
 * cql and *_t are reserved identifiers
 * the builtins are accessed as cql.*
 */

static Exid_t		symbols[] =
{
EXID("access",	ID,        KEY(K_access),	STRING,			0),
EXID("clock",	ID,	   BUILTIN(B_CLOCK),	T_ELAPSED,		0),
EXID("comment",	ID,        KEY(K_comment)|BUILTIN(B_COMMENT), STRING,	0),
EXID("cql",	ID,	   BUILTIN(B_STATE),	0,			0),
EXID("date",	ID,	   BUILTIN(B_DATE),	T_DATE,			0),
EXID("date_t",	DECLARE,   T_DATE,		T_DATE,			0),
EXID("delimiter",ID,       KEY(K_delimiter)|BUILTIN(B_DELIMITER), INTEGER, 0),
EXID("details",	ID,        KEY(K_details),	0,			0),
EXID("edge",	ID,        KEY(K_edge),		INTEGER,		0),
EXID("elapsed_t",DECLARE,  T_ELAPSED,		T_ELAPSED,		0),
EXID("errors",	ID,	   BUILTIN(B_ERRORS),	INTEGER,		0),
EXID("extern",	ID,        KEY(K_key),		0,			0),
EXID("format",	ID,        KEY(K_format)|BUILTIN(B_FORMAT), STRING,	0),
EXID("getenv",	FUNCTION,  BUILTIN(B_getenv),	S|A(1,S),		0),
EXID("input",	ID,        KEY(K_input)|BUILTIN(B_INPUT),	STRING,	0),
EXID("iteration",ID,	   BUILTIN(B_ITERATION),INTEGER,		0),
EXID("length",	FUNCTION,  BUILTIN(B_length),	I|A(1,S),		0),
EXID("line",	ID,	   BUILTIN(B_LINE),	INTEGER,		0),
EXID("loop",	FUNCTION,  BUILTIN(B_loop),	I|A(1,S)|A(2,S)|A(3,S),	0),
EXID("offset",	ID,	   BUILTIN(B_OFFSET),	INTEGER,		0),
EXID("path",	FUNCTION,  BUILTIN(B_path),	S|A(1,S)|A(2,I),	0),
EXID("permanent",ID,        KEY(K_permanent)|BUILTIN(B_PERMANENT), INTEGER, 0),
EXID("pragma",	PRAGMA,	   P_pragma,		0,			0),
EXID("present",	FUNCTION,  BUILTIN(B_present),	I|A(1,S),		0),
EXID("record",	ID,	   BUILTIN(B_RECORD),	INTEGER,		0),
EXID("register",ID,        KEY(K_index),	0,			0),
EXID("scanlimit",ID,        KEY(K_scanlimit)|BUILTIN(B_SCANLIMIT), INTEGER, 0),
EXID("schema",	ID,        KEY(K_schema)|BUILTIN(B_SCHEMA),	STRING,	0),
EXID("selected",ID,	   BUILTIN(B_SELECTED),	INTEGER,		0),
EXID("size",	ID,	   BUILTIN(B_SIZE),	INTEGER,		0),
EXID("sort",	ID,        KEY(K_sort),		INTEGER,		0),
EXID("static",	PRAGMA,	   P_static,		0,			0),
EXID("struct",	PRAGMA,	   P_struct,		0,			0),
EXID("sub",	FUNCTION,  BUILTIN(B_sub),	S|A(1,S)|A(2,S)|A(3,S)|A(4,S),0),
EXID("terminator",ID,      KEY(K_terminator)|BUILTIN(B_TERMINATOR), INTEGER, 0),
EXID("time",	ID,	   BUILTIN(B_TIME),	T_DATE,			0),
EXID(0,		0,	   0,			0,			0)
};

State_t			state =
{
	{
	{	"closure",	0,	0	},
	{	"begin",	0,	0	},
	{	"select",	0,	0	},
	{	"action",	0,	0	},
	{	"end",		0,	0	},
	},
	1,
	{ HIX_VERSION, 0, VERSION, 0, (Hixerror_f)errorf, hix_event }
};

typedef Sflong_t (*Compiled_f)(char**);

/*
 * excc() code generator
 */

static int
ccf(Excc_t* cc, Exnode_t* node, Exid_t* sym, Exref_t* ref, Exnode_t* elt, Exccdisc_t* ccdisc)
{
	int	i;
	char*	b;
	char*	p;

	if (ISDATA(node))
	{
		switch ((int)GETDATA1(node))
		{
		case 0:
			b = (char*)&state;
			p = (char*)&state.selected;
			break;
		case 1:
			b = (char*)state.empty;
			i = GETDATA2(node);
			switch (sym->type)
			{
			case FLOATING:
				p = (char*)&state.empty[i].f_double;
				break;
			case STRING:
				p = (char*)&state.empty[i].f_string;
				break;
			default:
				p = (char*)&state.empty[i].f_unsigned;
				break;
			}
		}
		sfprintf(ccdisc->text, "(*((%s*)(data[%d]+%d)))", extype(sym->type), GETDATA1(node), p - b);
	}
	else
		sfprintf(ccdisc->text, "%s", sym->name);
	return 0;
}

int
main(int argc, char** argv)
{
	register Field_t*	field;
	register File_t*	f;
	register int*		g;
	int			n;
	char*			s;
	long*			h;
	char**			av;
	List_t*			a;
	List_t*			lastexpr;
	List_t*			p;
	Expr_t*			prog;
	Record_t*		r;
	Sfio_t*			sp;
	Extype_t		val;
	char			buf[PATH_MAX];
	char*			data[2];
	Mark_t*			kp;
	struct
	{
	Exid_t*			entity;
	Exid_t*			relation;
	Dt_t*			member;
	File_t*			f;
	Record_t*		r;
	int			key;
	int			parent;
	int			child;
	int			on;
	int			selected;
	Dtdisc_t		disc;
	}			closure;

	char*			compiled = 0;
	List_t*			expr = 0;
	int			g2 = 0;
	int			pushed = 0;
	Proc_t*			proc = 0;

	NoP(argc);
	error_info.id = state.hix.lib = "cql";
	closure.relation = 0;
	av = argv;
	prog = init(symbols);
	for (;;)
	{
		switch (optget(argv, usage))
		{
		case 'a':
			state.active = 1;
			error_info.id = "%% cql";
			continue;
		case 'c':
			compiled = opt_info.arg;
			continue;
		case 'd':
		case 'e':
			if (!(a = newof(0, List_t, 1, 0)))
				error(3, "out of space [input]");
			a->value.string = opt_info.arg;
			if (expr) lastexpr = lastexpr->next = a;
			else expr = lastexpr = a;
			continue;
		case 'f':
			n = sfsprintf(buf, sizeof(buf), "#include '%s'", opt_info.arg);
			if (!(a = newof(0, List_t, 1, n + 1)))
				error(3, "out of space [input]");
			a->value.string = strcpy((char*)(a + 1), buf);
			if (expr) lastexpr = lastexpr->next = a;
			else expr = lastexpr = a;
			continue;
		case 'g':
			g2 = 1;
			continue;
		case 'l':
			state.hix.flags |= HIX_LOCAL;
			continue;
		case 'n':
			state.hix.flags |= HIX_READONLY;
			continue;
		case 'r':
			state.replace = 1;
			continue;
		case 'u':
			state.update = 1;
			continue;
		case 'w':
			state.verbose = -1;
			continue;
		case 'D':
			error_info.trace = -opt_info.num;
			continue;
		case 'I':
			if (pathinclude(opt_info.arg) < 0)
				error(3, "out of space [include]");
			continue;
		case 'T':
			state.test |= opt_info.num;
			if (state.test & 000010)
				state.hix.flags |= HIX_TEST1;
			if (state.test & 000020)
				state.hix.flags |= HIX_TEST2;
			if (state.test & 000100)
				state.cdb_flags |= CDB_TEST1;
			if (state.test & 000200)
				state.cdb_flags |= CDB_TEST2;
			continue;
		case '?':
			error(ERROR_USAGE|4, "%s", opt_info.arg);
			break;
		case ':':
			error(2, "%s", opt_info.arg);
			break;
		}
		break;
	}
	argv += opt_info.index;
	if (error_info.errors)
		error(ERROR_USAGE|4, "%s", optusage(NiL));

	/*
	 * parse the declarations
	 */

	s = strchr(usage, '\n') + 5;
	message((-1, ":::: %-.*s", strchr(s, '\n') - s, s));
	message((-2, ":::: parse the declarations"));
	for (a = expr; a; a = a->next)
		if (declare(prog, a->value.string, NiL, 1))
			pushed++;
	if (state.active)
		declare(prog, NiL, sfstdin, 0);

	/*
	 * initialize the main schema fields
	 */

	message((-2, ":::: initialize the main schema fields"));
	if (!state.schema || !state.schema->local.pointer || !((Local_t*)state.schema->local.pointer)->record || !((Local_t*)state.schema->local.pointer)->record->fields)
	{
		register char*	s;
		register char*	e;

		if (s = *argv)
		{
			if (e = strchr(s, ':')) *e = 0;
			sp = sfopen(NiL, s, "r");
			if (e) *e = ':';
			if (sp)
			{
				if ((s = sfgetr(sp, '\n', 1)) && *s == VDB_DELIMITER && strneq(s + 1, VDB_MAGIC, sizeof(VDB_MAGIC) - 1) && *(s + sizeof(VDB_MAGIC)) == VDB_DELIMITER && (s = sfgetr(sp, '\n', 1)) && streq(s, ".SCHEMA."))
					declare(prog, NiL, sp, 0);
				sfclose(sp);
			}
		}
		if (!state.schema)
			error(3, "main schema not defined");
	}
	r = ((Local_t*)state.schema->local.pointer)->record;
	attach(state.schema, r, 0);
	f = ((Local_t*)state.schema->local.pointer)->file;
	state.maxfield++;
	if (!(state.empty = newof(0, Field_t, state.maxfield, 0)))
		error(3, "out of space [empty]");
	for (field = state.empty; field < state.empty + state.maxfield; field++)
		field->f_string = "";

	/*
	 * initialize for closure
	 */

	if (p = state.edge)
	{
		Exid_t*		parent;
		Exid_t*		child;
		Exid_t*		cel;
		Record_t*	ent;
		char*		e;

		message((-2, ":::: initialize for closure"));
		if (!p->next || p->next->next)
			error(3, "edge={parent,child} expected");
		parent = p->value.symbol;
		child = p->next->value.symbol;
		state.insert = 1;
		excomp(prog, NiL, 0, parent->name, NiL);
		excomp(prog, NiL, 0, child->name, NiL);
		state.insert = 0;
		if (!parent->local.pointer || !child->local.pointer || !(ent = ((Local_t*)parent->local.pointer)->record) || ent != ((Local_t*)child->local.pointer)->record)
			error(3, "%s: must point to the same schema as %s", child->name, parent->name);
		cel = 0;
		if (e = strchr(parent->name, '.'))
		{
			*e = 0;
			state.closure = closure.relation = (Exid_t*)dtmatch(prog->symbols, parent->name);
			*e = '.';
			if (e = strchr(child->name, '.'))
			{
				*e = 0;
				cel = (Exid_t*)dtmatch(prog->symbols, child->name);
				*e = '.';
			}
		}
		if (!e || !closure.relation || !cel || closure.relation != cel)
			error(3, "%s: must name the same schema as %s", child->name, parent->name);
		memset(&closure.disc, 0, sizeof(closure.disc));
		closure.disc.key = offsetof(Mark_t, name);
		if (!(closure.member = dtopen(&closure.disc, Dtset)))
			error(3, "out of space [closure hash]");
		closure.entity = ent->symbol;
		closure.key = ent->key;
		closure.parent = GETFIELD(parent);
		closure.child = GETFIELD(child);
		closure.selected = 0;
		message((-3, "clo: entity=%s relation=%s key=%d parent=%d child=%d", closure.entity->name, closure.relation->name, closure.key, closure.parent, closure.child));
		closure.r = ((Local_t*)closure.relation->local.pointer)->record;
		attach(closure.relation, closure.r, 0);
		propagate(closure.r);
		closure.f = ((Local_t*)closure.relation->local.pointer)->file;
		load(prog, closure.f, NiL);
		state.iteration = 1;
	}
	else
		propagate(r);
	s = f->name;
	f->name = 0;
	load(prog, f, NiL);
	f->name = s;
	if (*argv)
	{
		if (!*(argv + 1))
			f->name = *argv;
		else
		{
			if (!(sp = sfstropen()))
				error(3, "out of space [file]");
			for (; *argv; argv++)
				sfputr(sp, *argv, *(argv + 1) && !streq(*argv, ":") ? ':' : -1);
			if (!(f->name = sfstruse(sp)) || !(f->name = strdup(f->name)))
				error(3, "out of space [file]");
			sfstrclose(sp);
		}
	}
	else if (!f->name)
	{
		if (!(sp = sfstropen()))
			error(3, "out of space [file]");
		sfprintf(sp, "%s.db", state.schema->name);
		if (!(f->name = sfstruse(sp)) || !(f->name = strdup(f->name)))
			error(3, "out of space [file]");
		sfstrclose(sp);
	}
	if (closure.relation && !closure.f->name)
		closure.f->name = f->name;

	/*
	 * parse the expressions
	 */

	if (!state.active)
		message((-2, ":::: parse the expressions"));
	state.expr.flags &= ~EX_STRICT;
	while (pushed-- > 0)
		excomp(prog, NiL, 0, NiL, NiL);
	state.expr.flags |= EX_STRICT;
	while (a = expr)
	{
		expr = expr->next;
		free(a);
	}

	/*
	 * initialize the sort fields
	 *
	 * NOTE: defer to /bin/sort until a good library surfaces
	 *	 this implementation is self-contained except
	 *	 for the procclose() at the end
	 * AHEM: -lrecsort is that interface, but now where's the
	 *	 time to convert
	 */

	if (state.sort)
	{
		char**	ap;
		Sfio_t*	xp;
		int	child;
		int	i;
		int	io;

		if (state.active)
			error(3, "cannot sort in active mode");
		if (!(child = av[0][0] == '-'))
		{
			if (!(proc = procopen(NiL, NiL, NiL, NiL, PROC_READ)))
			{
				char*	cmd = av[0];

				av[0] = "-";
				if (!(proc = procopen(cmd, av, NiL, NiL, PROC_READ)))
					error(ERROR_SYSTEM|3, "sort: cannot run");
				av[0] = cmd;
			}
			child = !proc->pid;
		}
		if (child)
		{
			if (error_info.trace)
				error_info.id = "cql-child";
			message((-2, ":::: initialize child sort"));
			n = f->record->fields;
			if (!(sp = sfstropen()) || !(xp = sfstropen()) || !(av = newof(0, char*, 2 * n + 3, 0)))
				error(3, "out of space [sort]");
			for (io = 0; io < elementsof(prog->file) && prog->file[io]; io++);
			state.insert = 1;
			sfprintf(xp, "\\n', cql.input");
			ap = av;
			*ap++ = "sort";
			sfprintf(sp, "-t%c", f->delimiter);
			if (!(*ap++ = strdup(sfstruse(sp))))
				error(3, "out of space [sort]");
			for (p = state.sort; p; p = p->next)
			{
				excomp(prog, NiL, 0, p->value.symbol->name, NiL);
				if (p->value.symbol->local.pointer && ((Local_t*)p->value.symbol->local.pointer)->reference)
				{
					i = n++;
					sfprintf(xp, ", %s", p->value.symbol->name);
				}
				else i = GETFIELD(p->value.symbol);
				sfprintf(sp, "+%d", i);
				if (!(*ap++ = strdup(sfstruse(sp))))
					error(3, "out of space [sort]");
				sfprintf(sp, "-%d%s", i + 1, p->value.symbol->type == STRING ? "" : "n");
				if (!(*ap++ = strdup(sfstruse(sp))))
					error(3, "out of space [sort]");
			}
			*ap = 0;
			state.insert = 0;
			if (!(proc = procopen(*av, av, NiL, NiL, PROC_WRITE)))
				error(ERROR_SYSTEM|3, "sort: cannot run #2");
			if (!sfopen(sfstdout, "/dev/null", "w") || !(prog->file[io] = sfnew(NiL, NiL, SF_UNBOUND, proc->wfd, SF_WRITE)))
				error(ERROR_SYSTEM|3, "sort: cannot redirect output #2");
			sfprintf(sp, "%s: printf(%d, '%%s", state.loop[ACTION].name, io);
			while (n-- > f->record->fields)
				sfprintf(sp, "%c%%s", f->delimiter);
			sfprintf(sp, "%s);", sfstruse(xp));
			exexpr(prog, state.loop[END].name, NiL, DELETE);
			exexpr(prog, state.loop[ACTION].name, NiL, DELETE);
			excomp(prog, NiL, 0, sfstruse(sp), NiL);
			sfstrclose(xp);
			sfstrclose(sp);
			g2 = 0;
		}
		else
		{
			if (error_info.trace)
				error_info.id = "cql-parent";
			message((-2, ":::: initialize parent sort"));
			sfclose(sfstdin);
			if (dup(proc->rfd) || close(proc->rfd) || !sfnew(sfstdin, NiL, SF_UNBOUND, 0, SF_READ))
				error(ERROR_SYSTEM|3, "sort: cannot redirect input");
			if (f->index)
				*f->index = hixend;
			f->hixdisc = state.hix;
			if (f->hix && hixclose(f->hix) || !(f->hix = hixopen("-", NiL, NiL, f->index, &f->hixdisc)))
				error(3, "sort: cannot open input");
			if (f->overlay)
			{
				dtclose(f->overlay);
				f->overlay = 0;
			}
			exexpr(prog, state.loop[SELECT].name, NiL, DELETE);
			sfsprintf(buf, sizeof(buf), "%s: 1;", state.loop[SELECT].name);
			excomp(prog, NiL, 0, buf, NiL);
		}
	}

	/*
	 * expression loop
	 */

	state.expr.flags &= ~EX_STRICT;
	for (;;)
	{
		if (state.active)
		{
			/*
			 * parse the expressions
			 */

			while (isspace(n = sfgetc(sfstdin)));
			if (n == EOF) break;
			sfungetc(sfstdin, n);
			message((-2, ":::: parse the expressions"));
			exexpr(prog, NiL, NiL, DELETE);
			excomp(prog, NiL, 0, NiL, sfstdin);
		}

		/*
		 * initialize the expressions
		 */

		message((-2, ":::: initialize the expressions"));
		if (compiled)
		{
			if (strmatch(compiled, "*.c"))
			{
				Excc_t*		cc;
				Exccdisc_t	ccdisc;

				message((-2, ":::: generate expression C code in %s", compiled));
				memset(&ccdisc, 0, sizeof(ccdisc));
				if (!(ccdisc.text = sfopen(NiL, compiled, "w")))
					error(ERROR_SYSTEM|3, "%s: cannot write", compiled);
				ccdisc.id = error_info.id;
				ccdisc.ccf = ccf;
				if (!(cc = exccopen(prog, &ccdisc)))
					error(3, "%s: cannot generate expression C code", compiled);
				for (n = 0; n < elementsof(state.loop); n++)
					excc(cc, state.loop[n].name, 0, INTEGER);
				exccclose(cc);
				exit(0);
			}
			else if (strmatch(compiled, "*.cdb"))
			{
				error(3, "%s: use the cdb command to convert db files", compiled);
			}
			else
			{
				char*		name;
				void*		dll;
				Exnode_t*	x;

				message((-2, ":::: load expression C code from %s", compiled));
				if (!(sp = sfstropen()))
					error(ERROR_SYSTEM|3, "out of space [load]");
				if (!(dll = dllfind(compiled, NiL, RTLD_LAZY)))
					error(ERROR_SYSTEM|3, "%s: cannot load", compiled);
				for (n = 0; n < elementsof(state.loop); n++)
				{
					sfprintf(sp, "%s_%s", error_info.id, state.loop[n].name);
					name = sfstruse(sp);
					if ((x = exexpr(prog, state.loop[n].name, NiL, 0)) && !(x->compiled.integer = (Compiled_f)dlsym(dll, name)))
						error(3, "%s: %s function not found", compiled, name);
				}
				sfstrclose(sp);
				state.expr.data = data;
			}
		}
		closure.on = closure.relation && (state.loop[CLOSURE].body = exexpr(prog, state.loop[CLOSURE].name, NiL, 0));
		if (state.loop[BEGIN].body = exexpr(prog, state.loop[BEGIN].name, NiL, 0))
			exeval(prog, state.loop[BEGIN].body, state.empty);

		/*
		 * the main loop
		 */

		for (;;)
		{
			if (!state.loop[ACTION].body && (!g2 || !(state.loop[ACTION].body = g2print(prog, r))))
				state.loop[ACTION].body = exexpr(prog, state.loop[ACTION].name, NiL, 0);
			if (!state.loop[SELECT].body && !(state.loop[SELECT].body = exexpr(prog, state.loop[SELECT].name, NiL, INTEGER)))
				state.loop[SELECT].body = exexpr(prog, state.loop[SELECT].name = NiL, NiL, INTEGER);

			/*
			 * blast the input file
			 */

			generate(prog, f, f->name, state.schema);
			if (!state.loop[SELECT].body || !optimize(prog, state.loop[SELECT].body))
			{
				if (g = f->index)
				{
					if (*g == hixend)
						g = 0;
					else
					{
						while ((n = *g++) != hixend)
							reference(prog, NiL, r->member[n].symbol, NiL, NiL, -1, &state.expr);
						g = f->index;
					}
				}
				if (state.loop[SELECT].body)
					pivot(f->hix, state.loop[SELECT].body);
				while (field = record(f, NiL, 0, 0, 0, 0))
				{
					data[1] = (char*)field;
					state.record++;
					if (g)
					{
						h = f->hash;
						while ((n = *g++) != hixend)
						{
							if (r->member[n].record)
								val.integer = strsum(field[n].f_string, 0L);
							else if (r->member[n].index > 1 || r->member[n].format.type == STRING)
								val.integer = (field[n].flags & CDB_STRING) ? strsum(field[n].f_string, 0L) : field[n].f_unsigned;
							else
								val = value(prog, NiL, r->member[n].symbol, NiL, field, -1, &state.expr);
							message((-8, "put: #1 offset=%05lld field=%d hash=0x%08llx value=%s index=%d type=%d", (Sflong_t)f->hix->offset, n, val.integer, (field + n)->f_string, r->member[n].index, r->member[n].format.type));
							*h++ = val.integer;
						}
						g = f->index;
						if (hixput(f->hix, f->hash))
							break;
					}
					if (state.loop[SELECT].body)
					{
						val = exeval(prog, state.loop[SELECT].body, field);
						if (!val.integer)
							continue;
					}
					state.selected++;
					if (state.loop[ACTION].body)
						exeval(prog, state.loop[ACTION].body, field);
					else
						image(f, sfstdout, f->terminator);
					if (closure.on)
					{
						s = (field + closure.key)->f_string;
						if (!(kp = (Mark_t*)dtmatch(closure.member, s)))
						{
							n = strlen(s);
							if (!(kp = newof(0, Mark_t, 1, n)))
								error(3, "out of space [closure mark]");
							memcpy(kp->name, s, n);
							dtinsert(closure.member, kp);
						}
						kp->value = state.iteration;
					}
				}
				commit(f);
				if (closure.on && closure.selected != state.selected)
				{
					Exid_t*			main_schema = state.schema;
					Field_t*		main_field;
					File_t*			main_f = f;
					Record_t*		main_r = r;

					message((-2, ":::: closure"));
					generate(prog, f, f->name, state.schema);
					state.schema = closure.relation;
					f = closure.f;
					r = closure.r;
					generate(prog, f, f->name, state.schema);
					if (!state.loop[CLOSURE].body || !optimize(prog, state.loop[CLOSURE].body))
					{
						if (g = f->index)
						{
							if (*g == hixend)
								g = 0;
							else
							{
								while ((n = *g++) != hixend)
									reference(prog, NiL, r->member[n].symbol, NiL, NiL, -1, &state.expr);
								g = f->index;
							}
						}
						if (state.loop[CLOSURE].body) pivot(f->hix, state.loop[CLOSURE].body);
						/*UNDENT...*/

	do
	{
		n = 0;
		hixset(f->hix, 0);
		for (kp = (Mark_t*)dtfirst(closure.member); kp; kp = (Mark_t*)dtnext(closure.member, kp))
			if (kp->value == state.iteration)
			{
				hixeq(f->hix, closure.parent, strsum(kp->name, 0L));
				if (n++)
					hixor(f->hix);
			}
		state.iteration++;
		message((-3, "clo: iteration=%d selected=%d total=%d", state.iteration, state.selected - closure.selected, state.selected));
		closure.selected = state.selected;
		while (field = record(f, NiL, 0, 0, 0, 0))
		{
			if (g)
			{
				h = f->hash;
				while ((n = *g++) != hixend)
				{
					if (r->member[n].index > 1 || r->member[n].format.type == STRING) val.integer = strsum((field + n)->f_string, 0L);
					else val = value(prog, NiL, r->member[n].symbol, NiL, field, -1, &state.expr);
					message((-8, "put: #2 offset=%05lld field=%d hash=0x%08llx value=%s index=%d type=%d", (Sflong_t)f->hix->offset, n, val.integer, (field + n)->f_string, r->member[n].index, r->member[n].format.type));
					*h++ = val.integer;
				}
				g = f->index;
				if (hixput(f->hix, f->hash)) break;
			}
			if (((kp = (Mark_t*)dtmatch(closure.member, (field + closure.parent)->f_string)) ? kp->value : 0) != (state.iteration - 1))
				continue;
			val = exeval(prog, state.loop[CLOSURE].body, field);
			if (!val.integer)
				continue;
			s = (field + closure.child)->f_string;
			if (!(kp = (Mark_t*)dtmatch(closure.member, s)))
			{
				n = strlen(s);
				if (!(kp = newof(0, Mark_t, 1, n)))
					error(3, "out of space [closure mark]");
				memcpy(kp->name, s, n);
				kp->value = state.iteration;
				dtinsert(closure.member, kp);
			}
			state.selected++;
			if (main_field = record(main_f, s, strsum((field + closure.child)->f_string, 0L), closure.key, 1, 1))
			{
				state.schema = main_schema;
				if (state.loop[ACTION].body)
					exeval(prog, state.loop[ACTION].body, main_field);
				else
					image(main_f, sfstdout, main_f->terminator);
				state.schema = closure.relation;
			}
		}
		if (g)
		{
			g = 0;
			commit(f);
			generate(prog, f, f->name, state.schema);
		}
		else hixseek(f->hix, 0L);
	} while (closure.selected != state.selected);

						/*...INDENT*/
					}
					else message((-1, ":::: %s expression optimizes to constant 0", state.loop[CLOSURE].name));
					state.schema = main_schema;
					f = main_f;
					r = main_r;
				}
			}
			else message((-1, ":::: %s expression optimizes to constant 0", state.loop[SELECT].name));
			if (!state.loop[END].body && (state.loop[END].body = exexpr(prog, state.loop[END].name, NiL, 0)))
			{
				state.end++;
				exeval(prog, state.loop[END].body, state.empty);
				state.end--;
			}
			if (!state.again) break;
			state.again = 0;
			message((-2, ":::: restart the main loop"));
			for (n = BEGIN + 1; n <= END; n++)
			{
				if (state.loop[n].body && *state.loop[n].next)
				{
					if (!(a = newof(0, List_t, 1, 0)))
						error(3, "out of space [list]");
					a->value.node = state.loop[n].body;
					a->next = expr;
					expr = a;
					state.loop[n].body = 0;
				}
				state.loop[n].name = state.loop[n].next;
			}
		}

		/*
		 * clean up
		 */

		message((-2, ":::: clean up"));
		while (expr)
		{
			a = expr;
			expr = expr->next;
			exfreenode(prog, a->value.node);
		}
		if (!state.active) break;
		for (n = 0; n < elementsof(state.loop); n++)
			if (state.loop[n].body)
			{
				exexpr(prog, state.loop[n].name, NiL, DELETE);
				state.loop[n].body = 0;
			}
	}
	for (n = 0; n < elementsof(prog->file); n++)
		if (sp = prog->file[n])
			sfclose(sp);
	if (proc && procclose(proc))
		error_info.errors++;
	exit(error_info.errors != 0);
}
