.de L		\" literal font
.ft 5
.it 1 }N
.if !\\$1 \&\\$1 \\$2 \\$3 \\$4 \\$5 \\$6
..
.de LR
.}S 5 1 \& "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6"
..
.de RL
.}S 1 5 \& "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6"
..
.de EX		\" start example
.ta 1i 2i 3i 4i 5i 6i
.PP
.RS 
.PD 0
.ft 5
.nf
..
.de EE		\" end example
.fi
.ft
.PD
.RE
.PP
..
.TH PROTO 1
.SH NAME \" @(#)proto.1 (gsf@research.att.com) 10/11/95
proto \- make prototyped C source compatible with K&R, ANSI and C++
.SH SYNOPSIS
.B proto
[
\-c \fIname\fP=\fIvalue\fP
] [
\-l \fIfile\fP
] [
\-dfhinprstxz+
]
.I "file ..."
.SH DESCRIPTION
.I proto
converts ANSI C prototype constructs in
.I file
to constructs compatible with K&R C, ANSI C, and C++.
Only files with the line
.L "#pragma prototyped"
in the first 64 lines are processed; other files are silently ignored.
If 
.B \-f
is specified then all files are processed.
If
.B \-h
is specified then the
.I proto
inline header definitions are omitted.
If
.B \-n
is specified then
the output will contain
.L "#line"
.IR cpp (1)
directives to maintain line number compatibility with
the original source file.
If 
.B \-p
is specified then ignored file contents are passed untouched to the output.
If
.B \-s
is specified then
.L "#include <prototyped.h>"
is output instead of the inline header definitions.
If
.B \-r
is specified then the files are modified in place; otherwise the output
is placed on the standard output.
.PP
.B \-i
specifies inverse proto: classic function definitions are converted
to ANSI prototype form and non-ANSI directives are commented out.
In this case files with the line
.L "#pragma noprototyped"
in the first 64 lines are silently ignored.
If
.B \-h
is specified with
.B \-i
then only
.L extern
prototypes are emitted for each non-static function.
This option requires that all classic function formal arguments be declared,
i.e., omitted declarations for
.B int
formals will not generate the correct prototype.
Typical usage would be to first run
.B "proto \-ih *.c"
to generate the external prototypes that should be placed in a
.B .h
file shared by
.B *.c
and then
.B "proto \-ir *.c"
to convert the function prototypes in place.
Note that prototype code conditioned on
.B __STDC__
will most likely confuse
.BR \-i .
.PP
\fB\-c\fP \fIname\fP=\fIvalue\fP
generates a copyright notice comment at the top of the output controlled
by one or more \fIname\fP=\fIvalue\fP pairs.
If
.I value
contains space characters then it must be enclosed in either \f5"..."\fP
or \f5'...'\fP quotes.
\fIname\fP may be:
.TP
.B type
The copyright type.
.B proprietary
(default) and
.B nonexclusive
are supported.
.TP
.B corporation
They own it all, e.g.,
.IR "AT&T" .
.TP
.B company
Within the corporation, e.g.,
.IR "Bell Laboratories" .
.TP
.B organization
Within the company, e.g.,
.IR "Software Engineering Research Department" .
.TP
.B license
External reference to the detailed license text, e.g.,
.IR "http://www.research.att.com/orgs/ssr/book/reuse" .
.TP
.B contact
External reference for more information, e.g.,
.IR "bozo@bigtop.research.att.com" .
.PP
The copyright notice text can be generated by:
.EX
proto -hfc "..." /dev/null | egrep -v '^$| : : .* : :'
.EE
.PP
All conversion is done before macro expansion, so programs that
disguise C syntax in macros lose.
A single prototype must not span more than 1024 bytes.
.PP
ANSI
.L <stdarg.h>
variable argument constructs are recognized.
.L "va_start("
must appear within 1024 bytes of the enclosing function prototype.
.PP
The ANSI macro operators
.B #
(stringize) and
.B ##
(concatenate) are recognized, but note that old K&R preprocessors cannot
be coaxed to expand arguments to
.B #
or
.BR ## .
.PP
For C++,
.L extern
declarations and references are placed in the "C" linkage class.
Although C allows
.L extern
in function bodies, C++ restricts linkage class specifications to file scope.
.PP
The macros
.LR __PROTO__ ,
.LR __OTORP__ ,
.LR __PARAM__ ,
.LR __MANGLE__ ,
.LR __STDARG__ ,
.L __V_
and
.L __VARARG__
must not be used in the input source files.
.PP
The
.IR pp (3)
based
.IR cpp (1)
uses the same transformations to pre-pre-process
.L "#pragma prototyped"
files.
The transformations are disabled when
.IR pp (3)
is preprocessing for ANSI.
If the
.IR pp (3)
.IR cpp (1)
is used for all C compiles then
.I proto
need only be used when transporting files to places lacking
.IR pp (3).
.SH CAVEATS
.I proto
is not an ANSI C compiler.
.SH BUGS
Function-returning-function prototypes and casts are not handled --
nested typedefs get around the problem.
.SH SEE ALSO
cpp(1), pp(3)
.SH AUTHOR
Glenn Fowler
.br
gsf@research.att.com
