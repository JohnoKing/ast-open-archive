#pragma prototyped
/*
 * Editor (snarfed from v10, now posix compliant, no hard limits)
 */

static const char id[] = "\n@(#)ed (AT&T Research) 01/01/96\0\n";

#include <ast.h>
#include <error.h>
#include <ls.h>
#include <sfstr.h>
#include <sig.h>

#include <ctype.h>
#include <regex.h>
#include <setjmp.h>

#define BLOCK_LINE	1024
#define BLOCK_TMP	(8*SF_BUFSIZE)

#define BREAK_PAGE	23
#define BREAK_LINE	72

#define LINE_GLOBAL	((off_t)0x80000000)
#define LINE_MARKED	((off_t)0x40000000)
#define LINE_NONE	((off_t)-1)

#define MARK_MIN	'a'
#define MARK_MAX	'z'

#define MATCH_MIN	'0'
#define MATCH_MAX	'9'

#define PRINT		01
#define PRINT_LIST	02
#define PRINT_NUMBER	04

#define REC_IGNORE	001
#define REC_LINE	002
#define REC_SPLICE	004
#define REC_TERMINATE	010
#define REC_TEXT	020

#define BEG(n)		(ed.line+ed.match[n].rm_so)
#define CUR()		(ed.line)
#define END(n)		(ed.line+ed.match[n].rm_eo)
#define HIT(n)		(ed.match[n].rm_eo!=-1)
#define NXT()		(ed.line++)
#define SET(p)		(ed.line=(p))

#define error		fatal
#define trap()		do{if(ed.caught)handle();}while(0);

#define swap(t,a,b)	(ed.swp=(void*)(a),(a)=(b),(b)=(t)ed.swp)

typedef struct
{
	off_t		offset;
	off_t		undo;
	unsigned long	event;
} Line_t;

static int		signals[] = { SIGQUIT, SIGHUP, SIGINT, SIGTERM };

static struct		/* program state -- no other dynamic globals */
{
	struct
	{
	Sfio_t*		file;
	Sfio_t*		global;
	Sfio_t*		help;
	Sfio_t*		line;
	Sfio_t*		prompt;
	Sfio_t*		query;
	Sfio_t*		shell;
	Sfio_t*		substitute;
	Sfio_t*		work;
	}		buffer;
	struct
	{
	int		print;
	int		size;
	}		page;
	struct
	{
	off_t		marks[MARK_MAX - MARK_MIN + 1];
	unsigned long	dol;
	unsigned long	dot;
	}		undo;
	Line_t*		addr1;
	Line_t*		addr2;
	Line_t*		dol;
	Line_t*		dot;
	Line_t*		zero;
	Sfio_t*		iop;
	Sfio_t*		msg;
	Sfio_t*		tmp;
	char*		global;
	char*		line;
	char*		linebreak;
	char*		tmpfile;
	int		caught;
	int		compiled;
	int		evented;
	int		given;
	int		help;
	int		initialized;
	int		interactive;
	int		lastc;
	int		marked;
	int		modified;
	int		peekc;
	int		pending;
	int		print;
	int		prompt;
	int		verbose;
	int		warn_newline;
	int		warn_null;
	jmp_buf		again;
	off_t		marks[MARK_MAX - MARK_MIN + 1];
	off_t		tmpoff;
	regex_t		re;
	regmatch_t	match[MATCH_MAX - MATCH_MIN + 1];
	unsigned long	all;
	unsigned long	bytes;
	unsigned long	event;
	unsigned long	lines;
	void*		swp;
}			ed;

static void		commands(void);
static void		handle(void);
static void		quit(int);

static void
interrupt(int sig)
{
	signal(sig, interrupt);
	if (ed.initialized) {
		if (!ed.caught)
			ed.caught = sig;
	}
	else if (!ed.pending)
		ed.pending = sig;
}

static int
getchr(void)
{
	if (ed.lastc = ed.peekc) {
		ed.peekc = 0;
		return(ed.lastc);
	}
	if (ed.global) {
		if (ed.lastc = *ed.global++)
			return(ed.lastc);
		ed.global = 0;
		return(EOF);
	}
	if ((ed.lastc = sfgetc(sfstdin)) == EOF)
		trap();
	return(ed.lastc);
}

static ssize_t
helpwrite(int fd, const void* buf, size_t len)
{
	ssize_t	n;

	NoP(fd);
	n = ed.help ? sfwrite(ed.msg, buf, len) : ed.verbose ? sfputr(ed.msg, "?", '\n') : 0;
	sfstrset(ed.buffer.help, 0);
	sfwrite(ed.buffer.help, buf, len - 1);
	sfputc(ed.buffer.help, 0);
	return(n);
}

static void
error(int level, ...)
{
	va_list		ap;
	register int	c;

	trap();
	va_start(ap, level);
	errorv(NiL, level, ap);
	va_end(ap);
	if (level >= 2) {
		if (ed.iop) {
			sfclose(ed.iop);
			ed.iop = 0;
			error_info.file = 0;
		}
		if (ed.interactive <= 0 && (ed.interactive = isatty(0)) <= 0)
			quit(1);
		ed.print = 0;
		ed.bytes = 0;
		ed.lines = 0;
		if (ed.global)
			ed.lastc = '\n';
		ed.global = 0;
		ed.peekc = ed.lastc;
		if (ed.lastc)
			while ((c = getchr()) != '\n' && c != EOF)
				;
		longjmp(ed.again, 1);
	}
}

static void
init(void)
{
	register Sfio_t**	ss;
	register int		c;

	ed.interactive = -1;
	ed.msg = sfstdout;
	ed.all = BLOCK_LINE;
	ed.page.size = BREAK_PAGE;
	ed.verbose = 1;
	for (c = 0; c < elementsof(signals); c++)
		if (signal(signals[c], interrupt) == SIG_IGN)
			signal(signals[c], SIG_IGN);
	for (ss = (Sfio_t**)&ed.buffer; ss < (Sfio_t**)(((char*)&ed.buffer) + sizeof(ed.buffer)); ss++) {
		if (!(*ss = sfstropen()))
			error(ERROR_SYSTEM|3, "cannot initialize internal buffer");
		sfputc(*ss, 0);
		sfstrset(*ss, 0);
	}
	sfputr(ed.buffer.help, "?", 0);
	if (!(ed.zero = newof(NiL, Line_t, ed.all, 0)))
		error(ERROR_SYSTEM|3, "out of space [zero]");
}

static char*
getrec(register Sfio_t* sp, register int delimiter, register int flags)
{
	register int	c;
	register char*	glob;

	sfstrset(sp, 0);
	glob = ed.global;
	while ((c = getchr()) != delimiter) {
		if (c == '\n') {
			ed.peekc = c;
			break;
		}
		if (c == EOF) {
			if (glob)
				ed.peekc = (flags & REC_LINE) ? 0 : c;
			else if (delimiter != '\n' || (flags & (REC_LINE|REC_SPLICE)))
				error(2, "unexpected EOF");
			else if (flags & REC_TEXT)
				return(0);
			break;
		}
		if (c == '\\' && ((c = getchr()) != delimiter || (flags & REC_SPLICE) && c != '\n') && c && !(flags & REC_IGNORE))
			sfputc(sp, '\\');
		if (!c)
			error(1, "null character ignored");
		else if (!(flags & REC_IGNORE))
			sfputc(sp, c);
	}
	if (flags & REC_TERMINATE)
		sfputc(sp, c);
	return(sfstruse(sp));
}

static void
putrec(register char* s)
{
	register int	n;
	register char*	t;

	if ((ed.print & PRINT_LIST) && (t = fmtesc(s))) {
		s = t;
		n = strlen(s);
		while (n > BREAK_LINE) {
			n -= BREAK_LINE;
			sfprintf(ed.msg, "%-*.*s\\\n", BREAK_LINE, BREAK_LINE, s);
			s += BREAK_LINE;
		}
		sfprintf(ed.msg, "%s$\n", s);
	}
	else
		sfputr(ed.msg, s, '\n');
}

static void
modify(void)
{
	if (!ed.evented) {
		ed.evented = ed.modified = 1;
		ed.event++;
		ed.undo.dot = ed.dot - ed.zero;
		ed.undo.dol = ed.dol - ed.zero;
		if (ed.marked) {
			register int	c;

			for (c = 0; c < elementsof(ed.marks); c++)
				ed.undo.marks[c] = ed.marks[c];
		}
	}
}

static void
undo(void)
{
	register Line_t*	a1;
	register Line_t*	a3;
	register unsigned long	event;
	int			c;
	off_t			t;
	unsigned long		n;

	c = 0;
	event = ed.event;
	a1 = ed.zero;
	a3 = ed.zero + ed.all;
	while (++a1 < a3)
		if (a1->event == event) {
			c = 1;
			t = a1->offset;
			a1->offset = a1->undo;
			a1->undo = t;
		}
	if (!c)
		error(2, "nothing to undo");
	if (ed.marked)
		for (c = 0; c < elementsof(ed.marks); c++) {
			t = ed.marks[c];
			ed.marks[c] = ed.undo.marks[c];
			ed.undo.marks[c] = t;
		}
	n = ed.dot - ed.zero;
	ed.dot = ed.zero + ed.undo.dot;
	ed.undo.dot = n;
	n = ed.dol - ed.zero;
	ed.dol = ed.zero + ed.undo.dol;
	ed.undo.dol = n;
}

static char*
lineget(off_t off)
{
	char*	s;

	off &= ~(LINE_GLOBAL|LINE_MARKED);
	if (sfseek(ed.tmp, off, SEEK_SET) != off)
		error(ERROR_SYSTEM|2, "temp file read seek error");
	if (!(s = sfgetr(ed.tmp, 0, 0)))
		error(ERROR_SYSTEM|2, "temp file read error");
	return(s);
}

static off_t
lineput(char* s)
{
	off_t	off;

	modify();
	off = ed.tmpoff;
	if (sfseek(ed.tmp, off, SEEK_SET) != off)
		error(ERROR_SYSTEM|2, "temp file write seek error");
	if (sfputr(ed.tmp, s, 0) < 0)
		error(ERROR_SYSTEM|2, "temp file write error");
	if ((ed.tmpoff = sfseek(ed.tmp, 0L, SEEK_CUR)) == (off_t)-1)
		error(ERROR_SYSTEM|2, "temp file tell error");
	return(off);
}

static void
replace(register Line_t* a1, char* s)
{
	register off_t	off;

	off = lineput(s);
	if (a1->offset & LINE_MARKED) {
		register off_t*	mp;

		a1->offset &= ~LINE_GLOBAL;
		off |= LINE_MARKED;
		for (mp = ed.marks; mp < &ed.marks[elementsof(ed.marks)]; mp++)
			if (*mp == a1->offset)
				*mp = off;
	}
	a1->event = ed.event;
	a1->undo = a1->offset;
	a1->offset = off;
}

static void
squeeze(int i)
{
	if (ed.addr1 < ed.zero + i)
		error(2, "at top of file");
	if (ed.addr2 > ed.dol)
		error(2, "at end of file");
	if (ed.addr1 > ed.addr2)
		error(2, "first address exceeds second");
}

static void
nonzero(void)
{
	squeeze(1);
}

static char*
getfile(void)
{
	register char*	s;
	register int	n;
	register int	m;

	if (!(s = sfgetr(ed.iop, '\n', 1))) {
		if (!(s = sfgetr(ed.iop, '\n', -1)))
			return(0);
		ed.warn_newline = 1;
	}
	n = sfslen();
	if ((m = strlen(s)) < n) {
		register char*	t;
		register char*	u;
		register char*	x;

		t = u = s + m;
		x = s + n;
		while (u < x)
			if (!(*t++ = *u++))
				t--;
		*t++ = 0;
		n = t - s;
		ed.warn_null += x - t;
	}
	ed.bytes += n;
	ed.lines++;
	return(s);
}

static char*
getline(void)
{
	register char*	s;

	if ((s = getrec(ed.buffer.line, '\n', REC_TEXT)) && s[0] == '.' && !s[1])
		s = 0;
	return(s);
}

static char*
getbreak(void)
{
	char*	s;

	if ((s = ed.linebreak) && (ed.linebreak = strchr(s, '\n')))
		*ed.linebreak++ = 0;
	return(s);
}

static char*
getcopy(void)
{
	if (ed.addr1 > ed.addr2)
		return(0);
	return(lineget((ed.addr1++)->offset));
}

static void
print(void)
{
	register Line_t* a1;

	nonzero();
	a1 = ed.addr1;
	do {
		if (ed.print & PRINT_NUMBER)
			sfprintf(ed.msg, "%d\t", a1 - ed.zero);
		putrec(lineget((a1++)->offset));
	} while (a1 <= ed.addr2);
	ed.dot = ed.addr2;
	ed.print = 0;
}

static int
getnum(void)
{
	register int c;
	register int r;

	r = 0;
	while ((c = getchr()) >= '0' && c <= '9')
		r = r * 10 + c - '0';
	ed.peekc = c;
	return(r);
}

static void
regfatal(int code)
{
	char	buf[128];

	if (code) {
		regerror(code, 0, buf, sizeof(buf));
		error(2, "%s", buf);
	}
}

static void
compile(int delimiter)
{
	register char*	s;
	int		c;

	s = getrec(ed.buffer.line, delimiter, 0);
	if (*s) {
		if (ed.compiled) {
			ed.compiled = 0;
			regfree(&ed.re);
		}
		if (c = regcomp(&ed.re, s, 0))
			regfatal(c);
		ed.compiled = 1;
	}
	else if (!ed.compiled)
		error(2, "no previous regular expression");
}

static int
execute(Line_t* addr)
{
	register char*	s;
	register int	c;

	trap();
	if (!addr)
		s = CUR();
	else if (addr == ed.zero)
		return(0);
	else
		s = lineget(addr->offset);
	if (c = regexec(&ed.re, s, elementsof(ed.match), ed.match, 0)) {
		if (c != REG_NOMATCH)
			regfatal(c);
		return(0);
	}
	SET(s);
	return(1);
}

static Line_t*
address(void)
{
	register int		c;
	register int		sign;
	register Line_t*	a;
	register Line_t*	b;
	int			opcnt;
	int			nextopand;

	nextopand = -1;
	sign = 1;
	opcnt = 0;
	a = ed.dot;
	do {
		do c = getchr(); while (isspace(c) && c != '\n');
		if (c >= '0' && c <= '9') {
			ed.peekc = c;
			if (!opcnt)
				a = ed.zero;
			a += sign * getnum();
		}
		else switch (c) {

		case '$':
			a = ed.dol;
			/*FALLTHROUGH*/
		case '.':
			if (opcnt)
				error(2, "invalid address");
			break;

		case '\'':
			if ((c = getchr()) == EOF || (c -= MARK_MIN) < 0 || c >= elementsof(ed.marks) || opcnt)
				error(2, "invalid mark");
			a = ed.marked && ed.marks[c] != LINE_NONE ? ed.zero : ed.dol;
			do {
				if (++a > ed.dol)
					error(2, "undefined mark referenced");
			} while (ed.marks[c] != (a->offset & ~LINE_GLOBAL));
			break;

		case '?':
			sign = -sign;
			/*FALLTHROUGH*/
		case '/':
			compile(c);
			b = a;
			for (;;) {
				a += sign;
				if (a <= ed.zero)
					a = ed.dol;
				if (a > ed.dol)
					a = ed.zero;
				if (execute(a))
					break;
				if (a == b)
					error(2, "pattern not found");
			}
			break;

		default:
			if (nextopand == opcnt) {
				a += sign;
				if (a < ed.zero || ed.dol < a)
					continue;       /* error? */
			}
			if (c != '+' && c != '-' && c != '^') {
				ed.peekc = c;
				if (!opcnt)
					a = 0;
				return(a);
			}
			sign = 1;
			if (c != '+')
				sign = -sign;
			nextopand = ++opcnt;
			continue;

		}
		sign = 1;
		opcnt++;
	} while (a >= ed.zero && a <= ed.dol);
	error(2, "address out of range");
	return(0);
}

static void
setwide(void)
{
	if (!ed.given) {
		ed.addr1 = ed.zero + (ed.dol > ed.zero);
		ed.addr2 = ed.dol;
	}
}

static void
setnoaddr(void)
{
	if (ed.given)
		error(2, "invalid address count");
}

static void
newline(void)
{
	register int	warned = 0;

	for (;;)
		switch (getchr()) {

		case EOF:
		case '\n':
			return;

		case 'l':
			ed.print = PRINT_LIST;
			continue;

		case 'n':
			ed.print = PRINT_NUMBER;
			continue;

		case 'p':
			ed.print = PRINT;
			continue;

		default:
			if (!warned) {
				warned = 1;
				error(2, "extra characters at end of command");
			}
			continue;
		}
}

static char*
plural(unsigned long count)
{
	return(count == 1 ? "" : "s");
}

static void
exfile(void)
{
	if (sfclose(ed.iop))
		error(ERROR_SYSTEM|1, "io error");
	ed.iop = 0;
	if (ed.verbose) {
		if (ed.help) {
			sfprintf(ed.msg, "\"%s\" %lu line%s, %lu character%s", error_info.file, ed.lines, plural(ed.lines), ed.bytes, plural(ed.bytes));
			if (ed.warn_null) {
				sfprintf(ed.msg, ", %lu null%s", ed.warn_null, plural(ed.warn_null));
				ed.warn_null = 0;
			}
			if (ed.warn_newline) {
				sfprintf(ed.msg, ", newline appended");
				ed.warn_newline = 0;
			}
			sfputc(ed.msg, '\n');
		}
		else
			sfprintf(ed.msg, "%d\n", ed.bytes);
	}
	if (ed.warn_null || ed.warn_newline) {
		char*	sep = "";

		sfstrset(ed.buffer.line, 0);
		if (ed.warn_null) {
			sfprintf(ed.buffer.line, "%d null character%s ignored", ed.warn_null, plural(ed.warn_null));
			ed.warn_null = 0;
			sep = ", ";
		}
		if (ed.warn_newline) {
			sfprintf(ed.buffer.line, "%snewline appended to last line", sep);
			ed.warn_newline = 0;
		}
		error(1, "%s", sfstruse(ed.buffer.line));
	}
	error_info.file = 0;
}

static void
putfile(void)
{
	register Line_t*	a1;
	register int		n;

	ed.bytes = 0;
	ed.lines = 0;
	a1 = ed.addr1;
	do {
		if ((n = sfputr(ed.iop, lineget((a1++)->offset), '\n')) < 0)
			error(ERROR_SYSTEM|2, "write error");
		ed.bytes += n;
		ed.lines++;
	} while (a1 <= ed.addr2);
	if (sfsync(ed.iop))
		error(ERROR_SYSTEM|2, "write error");
}

static void
quit(int code)
{
	if (ed.tmpfile) {
		remove(ed.tmpfile);
		ed.tmpfile = 0;
	}
	if (ed.verbose && ed.modified && ed.dol != ed.zero) {
		ed.modified = 0;
		error(2, "file changed but not written");
	}
	if (ed.caught == SIGQUIT) {
		signal(ed.caught, SIG_DFL);
		kill(0, ed.caught);
	}
	exit(code);
}

static void
handle(void)
{
	register int	c;
	char*		s;
	char*		b;
	mode_t		mask;

	if (ed.caught == SIGINT) {
		ed.caught = 0;
		ed.lastc = '\n';
		sfputc(ed.msg, '\n');
		error(2, "interrupt");
	}
	for (c = 0; c < elementsof(signals); c++)
		signal(signals[c], SIG_IGN);
	if (ed.dol > ed.zero) {
		ed.addr1 = ed.zero + 1;
		ed.addr2 = ed.dol;
		mask = umask(S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
		b = "ed.hup";
		if (!(ed.iop = sfopen(NiL, b, "w")) && (s = getenv("HOME"))) {
			sfstrset(ed.buffer.line, 0);
			sfprintf(ed.buffer.line, "%s/%s", s, b);
			b = sfstruse(ed.buffer.line);;
			ed.iop = sfopen(NiL, b, "w");
		}
		umask(mask);
		if (!ed.iop)
			error(ERROR_SYSTEM|1, "%s: cannot save changes", b);
		else {
			error_info.file = b;
			putfile();
		}
	}
	ed.modified = 0;
	quit(0);
}

static int
append(char* (*f)(void), Line_t* a)
{
	register char*		s;
	register Line_t*	a1;
	register Line_t*	a2;
	register Line_t*	a3;
	off_t			t;
	long			m;
	long			slide;

	slide = 0;
	ed.dot = a;
	while (s = (*f)()) {
		if ((ed.dol - ed.zero) + 1 >= ed.all) {
#if __sgi__ && !__GNUC__ /* sgi pointer arithmetic bug -- it's fun */
			long	dot = ed.dot - ed.zero;
			long	dol = ed.dol - ed.zero;
#endif
			a3 = ed.zero;
			ed.all += BLOCK_LINE;
			if (!(ed.zero = newof(ed.zero, Line_t, ed.all, 0))) {
				error(ERROR_SYSTEM|1, "no space [zero]");
				ed.caught = SIGHUP;
				trap();
			}
			m = ed.zero - a3;
			slide += m;
#if __sgi__ && !__GNUC__ /* sgi pointer arithmetic bug -- it's fun */
			ed.dot = ed.zero + dot;
			ed.dol = ed.zero + dol;
#else
			ed.dot += m;
			ed.dol += m;
#endif
		}
		t = lineput(s);
		slide++;
		a1 = ++ed.dol;
		a2 = a1 + 1;
		a3 = ++ed.dot;
		while (a1 > a3) {
			(--a2)->event = ed.event;
			a2->undo = a2->offset;
			a2->offset = (--a1)->offset;
		}
		a3->event = ed.event;
		a3->undo = a3->offset;
		a3->offset = t;
	}
	return(slide);
}

static void
add(int i)
{
	if (i && (ed.given || ed.dol > ed.zero)) {
		ed.addr1--;
		ed.addr2--;
	}
	squeeze(0);
	newline();
	append(getline, ed.addr2);
}

static void
page(void)
{
	register int	direction;
	register int	n;

	switch (direction = getchr()) {

	case '-':
	case '.':
	case '+':
		break;

	default:
		ed.peekc = direction;
		direction = '+';
		break;

	}
	if ((n = getnum()) > 0)
		ed.page.size = n;
	newline();
	if (ed.print)
		ed.page.print = ed.print;
	else
		ed.print = ed.page.print;
	switch (direction) {

	case '-':
		ed.addr1 = ed.addr2 - ed.page.size + 1;
		break;

	case '.':
		ed.addr2 += ed.page.size / 2;
		ed.addr1 = ed.addr2 - ed.page.size + 1;
		break;

	case '+':
		ed.addr1 = ed.addr2;
		ed.addr2 += ed.page.size - 1;
		break;

	}
	if (ed.addr1 <= ed.zero)
		ed.addr1 = ed.zero + 1;
	if (ed.addr2 > ed.dol)
		ed.addr2 = ed.dol;
	print();
}

static void
rdelete(register Line_t* a1, register Line_t* a2)
{
	register Line_t*	a3;

	modify();
	a3 = ed.dol;
	ed.dol -= ++a2 - a1;
	ed.dot = a1 > ed.dol ? ed.dol : a1;
	do {
		a1->undo = a1->offset;
		a1->event = ed.event;
		(a1++)->offset = (a2++)->offset;
	} while (a2 <= a3);
	while (a1 <= a3) {
		a1->undo = a1->offset;
		(a1++)->event = ed.event;
	}
}

static void
gdelete(void)
{
	register Line_t*	a1;
	register Line_t*	a2;
	register Line_t*	a3;

	a3 = ed.dol;
	for (a1 = ed.zero; !(a1->offset & LINE_GLOBAL); a1++)
		if (a1 >= a3)
			return;
	modify();
	for (a2 = a1 + 1; a2 <= a3;) {
		a1->event = ed.event;
		a1->undo = a1->offset;
		if (a2->offset & LINE_GLOBAL) {
			a2++;
			ed.dot = a1;
		}
		else
			(a1++)->offset = (a2++)->offset;
	}
	ed.dol = a1 - 1;
	if (ed.dot > ed.dol)
		ed.dot = ed.dol;
	while (a1 <= a3) {
		a1->undo = a1->offset;
		(a1++)->event = ed.event;
	}
}

static void
shell(void)
{
	register char*	s;
	register char*	f = 0;
	register int	c;

	if (ed.given)
		squeeze(ed.dol > ed.zero);
	s = getrec(ed.buffer.line, '\n', 0);
	if (s[0] == '!' && !s[1]) {
		if (!*sfstrbase(ed.buffer.shell))
			error(2, "no saved shell command");
		f = sfstrbase(ed.buffer.file);
	}
	else if (!s[0])
		error(2, "empty shell command");
	else
		swap(Sfio_t*, ed.buffer.shell, ed.buffer.line);
	s = sfstrbase(ed.buffer.shell);
	sfstrset(ed.buffer.line, 0);
	sfputc(ed.buffer.line, '!');
	while (c = *s++) {
		if (c == '\\') {
			if (*s != '%')
				sfputc(ed.buffer.line, c);
			sfputc(ed.buffer.line, *s++);
		}
		else if (c == '%')
			sfputr(ed.buffer.line, f = sfstrbase(ed.buffer.file), -1);
		else
			sfputc(ed.buffer.line, c);
	}
	if (ed.given) {
		if (!ed.tmpfile && !(ed.tmpfile = pathtemp(NiL, NiL, error_info.id)))
			error(ERROR_SYSTEM|2, "cannot generate temp file name");
		if (!(ed.iop = sfopen(NiL, ed.tmpfile, "w")))
			error(ERROR_SYSTEM|2, "%s: cannot create temp file", ed.tmpfile);
		error_info.file = ed.tmpfile;
		if (ed.dol > ed.zero)
			putfile();
		exfile();
		ed.bytes = 0;
		ed.lines = 0;
		sfprintf(ed.buffer.line, " < %s", ed.tmpfile);
		s = sfstruse(ed.buffer.line);
		if (!(ed.iop = sfpopen(NiL, s + 1, "r")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", s);
		error_info.file = s;
		rdelete(ed.addr1, ed.addr2);
		append(getfile, ed.dot);
		exfile();
		remove(ed.tmpfile);
	}
	else {
		s = sfstruse(ed.buffer.line) + 1;
		if (f)
			putrec(s);
		if (!(ed.iop = sfpopen(NiL, s, "")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", s);
		if (sfclose(ed.iop)) {
			ed.iop = 0;
			error(ERROR_SYSTEM|2, "%s: shell command exit error", s);
		}
		if (ed.verbose)
			putrec("!");
	}
}

static void
edit(void)
{
	register off_t*	mp;

	if (ed.tmp) {
		sfclose(ed.tmp);
		ed.tmp = 0;
	}
	ed.tmpoff = 0;
	if (!(ed.tmp = sftmp(BLOCK_TMP)))
		error(ERROR_SYSTEM|3, "cannot create temp file");
	for (mp = ed.marks; mp < &ed.marks[elementsof(ed.marks)]; )
		*mp++ = LINE_NONE;
	ed.marked = 0;
	ed.event++;
	ed.dot = ed.dol = ed.zero;
	if (!ed.initialized) {
		ed.initialized = 1;
		if (ed.pending)
			ed.caught = ed.pending;
	}
}

static void
filename(int c)
{
	register char*	p;
	register int	sh = 0;

	ed.bytes = 0;
	ed.lines = 0;
	p = getrec(ed.buffer.line, '\n', REC_LINE);
	if (*p) {
		if (!isspace(*p))
			error(2, "no space after command");
		for (p++; isspace(*p); p++)
			;
		if (!*p)
			error(2, "file name expected");
		if (c != 'f') {
			if (*p == '!') {
				p++;
				sh = 1;
			}
			else if (*p == '\\' && *(p + 1) == '!')
				p++;
		}
		if (!sh && (!*sfstrbase(ed.buffer.file) || c == 'e' || c == 'f')) {
			sfstrset(ed.buffer.file, 0);
			sfputr(ed.buffer.file, p, 0);
		}
		if (c == 'f')
			return;
	}
	else if (c == 'f')
		return;
	else if (!*(p = sfstrbase(ed.buffer.file)))
		error(2, "file name expected");
	if (c == 'e') {
		edit();
		ed.addr2 = ed.zero;
	}
	if (sh) {
		if (!(ed.iop = sfpopen(NiL, p, (c == 'e' || c == 'r') ? "r" : "w")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", p);
		p--;
	}
	else if (c == 'e' || c == 'r') {
		if (!(ed.iop = sfopen(NiL, p, "r")))
			error(ERROR_SYSTEM|2, "%s: cannot read", p);
	}
	else if ((c != 'W' || !(ed.iop = sfopen(NiL, p, "a"))) && !(ed.iop = sfopen(NiL, p, "w")))
		error(ERROR_SYSTEM|2, "%s: cannot write", p);
	error_info.file = p;
}

static void
global(int sense, int query)
{
	register char*		s;
	register int		c;
	register Line_t*	a1;

	if (ed.global)
		error(2, "recursive global not allowed");
	setwide();
	squeeze(ed.dol > ed.zero);
	if ((c = getchr()) == '\n')
		error(2, "incomplete global expression");
	compile(c);
	if (query)
		newline();
	else {
		s = getrec(ed.buffer.global, '\n', REC_SPLICE|REC_TERMINATE);
		if (s[0] == '\n' && !s[1])
			sfputr(ed.buffer.global, "p\n", 0);
	}
	for (a1 = ed.zero; a1 <= ed.dol; a1++) {
		a1->offset &= ~LINE_GLOBAL;
		if (a1 >= ed.addr1 && a1 <= ed.addr2 && execute(a1) == sense)
			a1->offset |= LINE_GLOBAL;
	}

	/* special case: g/.../d (avoid n^2 algorithm) */

	if (!query && s[0] == 'd' && s[1] == '\n' && !s[2])
		gdelete();
	else {
		for (a1 = ed.zero; a1 <= ed.dol; a1++) {
			if (a1->offset & LINE_GLOBAL) {
				a1->offset &= ~LINE_GLOBAL;
				ed.dot = a1;
				if (query) {
					putrec(lineget(a1->offset));
					if ((c = getchr()) == EOF)
						break;
					else if (c == '\n')
						continue;
					else if (c == '&') {
						newline();
						if (!*(ed.global = sfstrbase(ed.buffer.query)))
							error(2, "no saved command");
					}
					else {
						ed.peekc = c;
						ed.global = getrec(ed.buffer.query, '\n', REC_TERMINATE);
					}
				}
				else
					ed.global = s;
				commands();
				a1 = ed.zero;
			}
		}
	}
}

static void
join(void)
{
	register Line_t*	a1;

	nonzero();
	sfstrset(ed.buffer.work, 0);
	for (a1 = ed.addr1; a1 <= ed.addr2;)
		sfputr(ed.buffer.work, lineget((a1++)->offset), -1);
	a1 = ed.dot = ed.addr1;
	replace(a1, sfstruse(ed.buffer.work));
	if (a1 < ed.addr2)
		rdelete(a1 + 1, ed.addr2);
}

static int
compsub(void)
{
	register int	seof;
	register int	c;

	seof = getchr();
	if (isspace(seof))
		error(2, "invalid or missing delimiter");
	compile(seof);
	sfstruse(ed.buffer.substitute);
	for (;;) {
		c = getchr();
		if (c == '\\') {
			sfputc(ed.buffer.substitute, c);
			c = getchr();
		}
		else if (c == '\n' || c == EOF) {
			if (!ed.global || !ed.global[0]) {
				ed.peekc = c;
				ed.print |= PRINT;
				break;
			}
		}
		else if (c == seof)
			break;
		else if (c == '%' && !sfstrtell(ed.buffer.substitute) && ((ed.peekc = getchr()) == '\n' || ed.peekc == EOF || ed.peekc == seof)) {
			if (!*sfstrbase(ed.buffer.substitute))
				error(2, "no saved replacement string");
			sfstrset(ed.buffer.substitute, sfstrsize(ed.buffer.substitute) - 1);
			continue;
		}
		sfputc(ed.buffer.substitute, c);
	}
	sfputc(ed.buffer.substitute, 0);
	if ((ed.peekc = getchr()) == 'g') {
		ed.peekc = 0;
		newline();
		return(-1);
	}
	c = getnum();
	newline();
	return(c);
}

static void
dosub(void)
{
	register char*	s;
	register int	c;
	register int	n;

	sfstrset(ed.buffer.work, 0);
	if (n = BEG(0) - CUR())
		sfwrite(ed.buffer.work, CUR(), n);
	s = sfstrbase(ed.buffer.substitute);
	while (c = *s++) {
		if (c == '&') {
			if (n = END(0) - BEG(0))
				sfwrite(ed.buffer.work, BEG(0), n);
			continue;
		}
		if (c == '\\') {
			c = *s++;
			if (c >= MATCH_MIN && c <= MATCH_MAX) {
				c -= MATCH_MIN;
				if (HIT(c) && (n = END(c) - BEG(c)))
					sfwrite(ed.buffer.work, BEG(c), n);
				continue;
			}
		}
		sfputc(ed.buffer.work, c);
	}
	n = sfstrtell(ed.buffer.work);
	sfputr(ed.buffer.work, END(0), 0);
	swap(Sfio_t*, ed.buffer.work, ed.buffer.line);
	SET(sfstrbase(ed.buffer.line) + n);
}

static void
substitute(int inglob)
{
	register Line_t*	a1;
	register int		m;
	int			g;
	int			n;

	n = getnum();
	g = compsub();
	if (g > 0) {
		if (n)
			error(2, "only one substitute count expected");
		n = g;
		g = 0;
	}
	for (a1 = ed.addr1; a1 <= ed.addr2; a1++) {
		if (execute(a1)){
			m = n;
			do {
				int	span = END(0) - BEG(0);

				if (--m <= 0) {
					dosub();
					if (!g)
						break;
					if (!span) {
						if (!*END(0))
							break;
						NXT();
					}
				}
			} while (execute(NiL));
			if (m <= 0) {
				char*	s;
				char*	e;

				inglob = 1;
				s = sfstrbase(ed.buffer.line);
				if (e = strchr(s, '\n'))
					*e++ = 0;
				replace(a1, s);
				if (e) {
					ed.linebreak = e;
					m = append(getbreak, a1);
					a1 += m;
					ed.addr2 += m;
				}
			}
		}
	}
	if (!inglob)
		error(2, "global pattern not found");
}

static void
reverse(register Line_t* a1, register Line_t* a2)
{
	modify();
	while (--a2 > a1) {
		a1->event = a2->event = ed.event;
		a2->undo = a2->offset;
		a2->offset = a1->undo = a1->offset;
		(a1++)->offset = a2->undo;
	}
}

static void
move(int cflag)
{
	register Line_t*	adt;
	register Line_t*	ad1;
	register Line_t*	ad2;

	nonzero();
	if (!(adt = address()))
		error(2, "invalid move destination");
	newline();
	if (cflag) {
		unsigned long	m;

		ad1 = ed.dol;
		m = append(getcopy, ad1++);
		ad2 = ed.dol;
		ad1 += m;
		adt += m;
	}
	else {
		ad2 = ed.addr2;
		for (ad1 = ed.addr1; ad1 <= ad2; ad1++)
			ad1->offset &= ~LINE_GLOBAL;
		ad1 = ed.addr1;
	}
	ad2++;
	if (adt < ad1) {
		ed.dot = adt + (ad2 - ad1);
		if (++adt == ad1)
			return;
		reverse(adt, ad1);
		reverse(ad1, ad2);
		reverse(adt, ad2);
	}
	else if (adt >= ad2) {
		ed.dot = adt++;
		reverse(ad1, ad2);
		reverse(ad2, adt);
		reverse(ad1, adt);
	}
	else
		error(2, "move would do nothing");
}

static void
commands(void)
{
	register Line_t*	a1;
	register int		c;
	register int		n;
	char*			s;
	int			lastsep;

	for (;;) {
		trap();
		if (ed.print) {
			ed.addr1 = ed.addr2 = ed.dot;
			print();
		}
		if (!ed.global) {
			ed.evented = 0;
			if (ed.prompt > 0)
				sfputr(ed.msg, sfstrbase(ed.buffer.prompt), -1);
		}
		if ((c = getchr()) == ',' || c == ';') {
			ed.given = 1;
			ed.addr1 = (lastsep = c) == ',' ? ed.zero + 1 : ed.dot;
			a1 = ed.dol;
			c = getchr();
		}
		else {
			ed.addr1 = 0;
			ed.peekc = c;
			c = '\n';
			for (;;) {
				lastsep = c;
				a1 = address();
				c = getchr();
				if (c != ',' && c != ';')
					break;
				if (lastsep == ',')
					error(2, "invalid address");
				if (!a1) {
					a1 = ed.zero + 1;
					if (a1 > ed.dol)
						a1--;
				}
				ed.addr1 = a1;
				if (c == ';')
					ed.dot = a1;
			}
			if (lastsep != '\n' && !a1)
				a1 = ed.dol;
		}
		if (!(ed.addr2 = a1)) {
			ed.given = 0;
			ed.addr2 = ed.dot;	
		}
		else
			ed.given = 1;
		if (!ed.addr1)
			ed.addr1 = ed.addr2;
		switch (c) {

		case 'a':
			add(0);
			continue;

		case 'c':
			nonzero();
			newline();
			rdelete(ed.addr1, ed.addr2);
			append(getline, ed.addr1 - 1);
			continue;

		case 'd':
			nonzero();
			newline();
			rdelete(ed.addr1, ed.addr2);
			continue;

		case 'E':
			ed.modified = 0;
			c = 'e';
			/*FALLTHROUGH*/
		case 'e':
			setnoaddr();
			if (ed.verbose && ed.modified) {
				ed.modified = 0;
				error(2, "modified data not written");
			}
			/*FALLTHROUGH*/
		case 'r':
			filename(c);
			setwide();
			squeeze(0);
			c = ed.zero != ed.dol;
			append(getfile, ed.addr2);
			ed.modified = c;
			exfile();
			continue;

		case 'f':
			setnoaddr();
			filename(c);
			putrec(sfstrbase(ed.buffer.file));
			continue;

		case 'G':
			global(1, 1);
			continue;

		case 'g':
			global(1, 0);
			continue;

		case 'H':
			ed.help = !ed.help;
			/*FALLTHROUGH*/
		case 'h':
			setnoaddr();
			newline();
			if (ed.help || c == 'h')
				sfputr(ed.msg, sfstrbase(ed.buffer.help), '\n');
			continue;

		case 'i':
			add(-1);
			continue;

		case 'j':
			if (!ed.given)
				ed.addr2++;
			newline();
			join();
			continue;

		case 'k':
			nonzero();
			if ((c = getchr()) == EOF || (c -= MARK_MIN) < 0 || c >= elementsof(ed.marks))
				error(2, "invalid mark");
			newline();
			ed.addr2->offset |= LINE_MARKED;
			ed.marks[c] = ed.addr2->offset & ~LINE_GLOBAL;
			ed.marked = 1;
			continue;

		case 'm':
			move(0);
			continue;

		case 'n':
			ed.print |= PRINT_NUMBER;
			newline();
			print();
			continue;

		case '\n':
			if (!a1) {
				a1 = ed.dot + 1;
				ed.addr2 = a1;
				ed.addr1 = a1;
			}
			if (lastsep == ';')
				ed.addr1 = a1;
			print();
			continue;

		case 'l':
			ed.print |= PRINT_LIST;
			/*FALLTHROUGH*/
		case 'p':
			newline();
			print();
			continue;

		case 'P':
			setnoaddr();
			s = getrec(ed.buffer.line, '\n', 0);
			if (*s || !(ed.prompt = -ed.prompt) && (s = "*")) {
				sfstrset(ed.buffer.prompt, 0);
				sfputr(ed.buffer.prompt, s, 0);
				ed.prompt = 1;
			}
			continue;

		case 'Q':
			ed.modified = 0;
			/*FALLTHROUGH*/
		case 'q':
			setnoaddr();
			newline();
			quit(0);
			continue;

		case 'S':
			setnoaddr();
			newline();
			sfprintf(ed.msg, "file=\"%s\"%s%s%s prompt=\"%s\" tmp=%lu%s event=%lu version=%s\n", sfstrbase(ed.buffer.file), ed.modified ? " modified" : "", ed.help ? " help" : "", ed.verbose ? " verbose" : "", sfstrbase(ed.buffer.prompt), ed.tmpoff, ed.tmpoff > BLOCK_TMP ? "[file]" : "", ed.event, strrchr(id, ' ') + 1);
			continue;

		case 's':
			nonzero();
			substitute(ed.global != 0);
			continue;

		case 't':
			move(1);
			continue;

		case 'u':
			setnoaddr();
			newline();
			undo();
			continue;

		case 'V':
			global(0, 1);
			continue;

		case 'v':
			global(0, 0);
			continue;

		case 'W':
		case 'w':
			setwide();
			squeeze(ed.dol > ed.zero);
			if ((n = getchr()) != 'q' && n != 'Q') {
				ed.peekc = n;
				n = 0;
			}
			filename(c);
			if (ed.dol > ed.zero)
				putfile();
			exfile();
			if (n == 'Q' || ed.addr1 <= ed.zero + 1 && ed.addr2 == ed.dol)
				ed.modified = 0;
			if (n)
				quit(0);
			continue;

		case 'z':
			nonzero();
			page();
			continue;

		case '=':
			setwide();
			squeeze(0);
			newline();
			sfprintf(ed.msg, "%d\n", ed.addr2 - ed.zero);
			continue;

		case '!':
			shell();
			continue;

		case '#':
			setnoaddr();
			getrec(ed.buffer.line, '\n', REC_IGNORE);
			continue;

		case EOF:
			return;

		}
		error(2, "unknown command");
	}
}

int
main(int argc, char** argv)
{
	NoP(argc);
	error_info.id = "ed";
	error_info.write = helpwrite;
	init();
	for (;;)
	{
		for (;;) {
			switch (optget(argv, "hop:[prompt]qs [file]")) {

			case 'h':
				ed.help = 1;
				continue;

			case 'o':
				ed.msg = sfstderr;
				sfstrset(ed.buffer.file, 0);
				sfputr(ed.buffer.file, "/dev/stdout", 0);
				continue;

			case 'p':
				sfstrset(ed.buffer.prompt, 0);
				sfputr(ed.buffer.prompt, opt_info.arg, 0);
				ed.prompt = 1;
				continue;

			case 'q':
				signal(SIGQUIT, SIG_DFL);
				ed.verbose = 1;
				continue;

			case 's':
				ed.verbose = 0;
				continue;

			case 0:
				break;

			case '?':
				error(ERROR_USAGE|4, opt_info.arg);
				break;

			case ':':
				error(2, opt_info.arg);
				break;

			}
			break;
		}
		if (!*(argv += opt_info.index) || **argv != '-' || *(*argv + 1))
			break;
		ed.verbose = 0;
	}
	if (*argv) {
		if (*(argv + 1))
			error(ERROR_USAGE|4, opt_info.arg);
		sfprintf(ed.buffer.global, "e %s", *argv);
		ed.global = sfstruse(ed.buffer.global);
	}
	edit();
	sfslowio(sfstdin);
	setjmp(ed.again);
	commands();
	quit(0);
	exit(0);
}
#pragma prototyped

#include <ast.h>
#include <ctype.h>
#include <error.h>
#include <regex.h>

static const char id[] = "\n@(#)grep (AT&T Research) 01/01/96\0\n";

/*
 * snarfed from Doug McElroy's C++ version
 *
 * this grep is based on the Posix re package.
 * unfortunately it has to have a nonstandard interface.
 * 1. fgrep does not have usual operators. REG_LITERAL
 * caters for this.
 * 2. grep allows null expressions, hence REG_NULL.
 * 3. it may be possible to combine the multiple 
 * patterns of grep into single patterns.  important
 * special cases are handled by regcomb().
 * 4. anchoring by -x has to be done separately from
 * compilation (remember that fgrep has no ^ or $ operator),
 * hence REG_LEFT|REG_RIGHT.  (An honest, but slow alternative:
 * run regexec with REG_NOSUB off and nmatch=1 and check
 * whether the match is full length)
 */

typedef struct Item			/* list item			*/
{
	struct Item*	next;		/* next in list			*/
	union
	{
	regex_t		re;		/* re value - sue me for waste	*/
	char*		string;		/* string value			*/
	}		value;
} Item_t;

typedef struct				/* generic list			*/
{
	Item_t*		head;		/* list head			*/
	Item_t*		tail;		/* list tail			*/
} List_t;

static struct				/* program state		*/
{
	List_t		files;		/* pattern file list		*/
	List_t		patterns;	/* pattern list			*/
	List_t		res;		/* re list			*/

	int		code;		/* no hits exit code		*/
	int		hits;		/* if any patterns hit		*/
	int		options;	/* regex options		*/

	unsigned char	count;		/* count number of hits		*/
	unsigned char	list;		/* list files with hits		*/
	unsigned char	match;		/* match sense			*/
	unsigned char	query;		/* return status but no output	*/
	unsigned char	number;		/* line numbers			*/
	unsigned char	prefix;		/* print file prefix		*/
	unsigned char	suppress;	/* no unopenable file messages	*/
} state;

static void
fatal(int result)
{
	char	buf[128];

	if (result && result != REG_NOMATCH)
	{
		regerror(result, 0, buf, sizeof(buf));
		error(3, "%s", buf);
	}
}

static void
addre(List_t* p, char* s)
{
	int	result;
	Item_t*	x;

	if (!(x = newof(0, Item_t, 1, 0)))
		error(ERROR_SYSTEM|3, "out of space (pattern `%s')", s);
	if (result = regcomp(&x->value.re, s, state.options))
		fatal(result);
	if (!p->head)
		p->head = p->tail = x;
	else if (regcomb(&p->tail->value.re, &x->value.re))
		p->tail = p->tail->next = x;
	else free(x);
}

static void
addstring(List_t* p, char* s)
{
	Item_t*	x;

	if (!(x = newof(0, Item_t, 1, 0)))
		error(ERROR_SYSTEM|3, "out of space (string `%s')", s);
	x->value.string = s;
	if (p->head) p->tail->next = x;
	else p->head = x;
	p->tail = x;
}

/*
 * the update s = t+1 flagged below is formally illegal when
 * t==0, but what run-time system will catch it?
 */

static void
compile(void)
{
	int	i;
	int	line;
	char*	s;
	char*	t;
	char*	file;
	Item_t*	x;
	Sfio_t*	f;

	for (x = state.patterns.head; x; x = x->next)
		for (t = s = x->value.string; t; s = t + 1) /* see above */
		{
			if (t = strchr(s, '\n'))
				*t = 0;
			addre(&state.res, s);
		}	
	for (x = state.files.head; x; x = x->next)
	{
		s = x->value.string;
		if (f = sfopen(NiL, s, "r"))
		{
			file = error_info.file;
			error_info.file = s;
			line = error_info.line;
			error_info.line = 0;
			while (s = sfgetr(f, '\n', 1))
			{
				error_info.line++;
				addre(&state.res, s);
			}
			error_info.file = file;
			error_info.line = line;
			sfclose(f);
		}
		else if (!state.suppress)
			error(ERROR_SYSTEM|4, "%s: cannot open", s);
		else state.code = 2;
	}
	if (!(x = state.res.head))
		error(3, "no pattern#1");
}

static void
execute(Sfio_t* input, char* name)
{
	char*		s;
	char*		file;
	Item_t*		x;
	int		result;
	int		line;
	unsigned long	hits = 0;
	
	file = error_info.file;
	if (!(error_info.file = name))
		name = "(standard input)";
	line = error_info.line;
	error_info.line = 0;
	while (s = sfgetr(input, '\n', 1))
	{
		error_info.line++;
		for (x = state.res.head; x; x = x->next)
		{
			if (!(result = regexec(&x->value.re, s, 0, 0, 0)))
				break;
			if (result != REG_NOMATCH)
				fatal(result);
		}
		if ((x != 0) == state.match)
		{
			hits++;
			if (state.query || state.list)
				break;
			if (state.count)
				continue;
			if (state.prefix)
				sfprintf(sfstdout, "%s:", name);
			if (state.number)
				sfprintf(sfstdout, "%d:", error_info.line);
			sfprintf(sfstdout, "%s\n", s);
		}
	}
	error_info.file = file;
	error_info.line = line;
	if (hits)
	{
		state.hits = 1;
		if (state.query)
			return;
		if (state.list)
			sfprintf(sfstdout, "%s\n", name);
	}
	if (!state.list && state.count)
	{
		if (state.prefix)
			sfprintf(sfstdout, "%s:", name);
		sfprintf(sfstdout, "%d\n", hits);
	}
}

main(int argc, char** argv)
{
	int	c;
	char*	s;
	Sfio_t*	f;

	state.match = 1;
	state.options = REG_NOSUB|REG_NULL;
	state.code = 1;
	if (s = strrchr(argv[0], '/')) s++;
	else s = argv[0];
	switch (*s)
	{
	case 'a':
	case 'A':
		s = "agrep";
		state.options |= REG_AUGMENTED;
		break;
	case 'e':
	case 'E':
		s = "egrep";
		state.options |= REG_EXTENDED;
		break;
	case 'f':
	case 'F':
		s = "fgrep";
		state.options |= REG_LITERAL;
		break;
	default:
		s = "grep";
		break;
	}
	error_info.id = s;
	while (c = optget(argv, "AEFchilqnsvxe:[pattern]f:[file] [file ...]"))
		switch (c)
		{
		case 'A':
			state.options |= REG_AUGMENTED;
			break;
		case 'E':
			state.options |= REG_EXTENDED;
			break;
		case 'F':
			state.options |= REG_LITERAL;
			break;
		case 'c':
			state.count = 1;
			break;
		case 'e':
			addstring(&state.patterns, opt_info.arg);
			break;
		case 'f':
			addstring(&state.files, opt_info.arg);
			break;
		case 'h':
			state.prefix = 0;
			break;
		case 'i':
			state.options |= REG_ICASE;
			break;
		case 'l':
			state.list = 1;
			break;
		case 'n':
			state.number = 1;
			break;
		case 'q':
			state.query = 1;
			break;
		case 's':
			state.suppress = 1;
			break;
		case 'v':
			state.match = 0;
			break;
		case 'x':
			state.options |= REG_LEFT|REG_RIGHT;
			break;
		case '?':
			error(ERROR_USAGE|4, opt_info.arg);
			break;
		case ':':
			error(2, opt_info.arg);
			break;
		}
	argv += opt_info.index;
	if ((state.options & (REG_AUGMENTED|REG_LITERAL)) == (REG_AUGMENTED|REG_LITERAL))
		error(3, "-A and -F are incompatible");
	if ((state.options & (REG_EXTENDED|REG_LITERAL)) == (REG_EXTENDED|REG_LITERAL))
		error(3, "-E and -F are incompatible");
	if (!state.files.head && !state.patterns.head)
	{
		if (!argv[0])
			error(3, "no pattern");
		addstring(&state.patterns, *argv++);
	}
	compile();
	if (!argv[0])
		execute(sfstdin, NiL);
	else
	{
		if (!state.prefix && argv[1])
			state.prefix = 1;
		while (s = *argv++)
		{
			if (f = sfopen(NiL, s, "r"))
			{
				execute(f, s);
				sfclose(f);
			}
			else if (!state.suppress)
				error(ERROR_SYSTEM|4, "%s: cannot open", s);
			else state.code = 2;
			if (state.query && state.hits)
				break;
		}
	}
	exit(state.hits ? 0 : state.code);
}
#pragma prototyped

#include <ast.h>
#include <error.h>

#include "regex.h"

typedef unsigned char uchar;

typedef struct {
	uchar *w;		/* write pointer */
	uchar *e;		/* end */
	uchar *s;		/* start */
} Text;

extern void compile(Text *script, Text *raw);
extern void execute(Text *script, Text *input);
extern int recomp(Text *script, Text *t, int seof);
extern int match(uchar *re, Text *data, int gflag);
extern int substitute(regex_t*, Text* data, uchar *rhs, int gf);
extern regex_t *readdr(int addr);
extern void tcopy(Text *from, Text *to);
void printscript(Text *script);
extern void vacate(Text*);
extern void synwarn(char*);
extern void syntax(char*);
extern int readline(Text*);
extern int ateof(void);
extern void coda(void);

#define exch(a, b, t) ((t)=(a), (a)=(b), (b)=(t))
	
	/* space management; assure room for n more chars in Text */
#define assure(/*Text*/t, /*int*/ n) 		\
	do if((t)->s==0 || (t)->w>=(t)->e-n-1) grow(t, n);while(0)
extern void grow(Text*, int);

	/* round character pointer up to integer pointer.
	   portable to the cray; simpler tricks are not */

#define intp(/*uchar**/p) (int*)(p + sizeof(int) - 1 \
			- (p+sizeof(int)-1 - (uchar*)0)%sizeof(int))

extern int reflags;
extern int recno;
extern int nflag;
extern int qflag;
extern int sflag;
extern int bflag;
extern char *stdouterr;

extern Text files;

/* SCRIPT LAYOUT

   script commands are packed thus:
   0,1,or2 address words signed + for numbers - for regexp
   if 2 addresses, then another word indicates activity
	positive: active, the record number where activated
	negative: inactive, sign or-ed with number where deactivated
   instruction word
	high byte IMASK+flags; flags are NEG and SEL
	next byte command code (a letter)
	next two bytes, length of this command, including addrs
        (length is a multiple of 4; capacity could be expanded
	by counting the length in words instead of bytes)
   after instruction word
	on s command
		offset of regexp in rebuf
		word containing flags p,w plus n (g = >n=0)
		replacement text
		word containing file designator, if flag w
	on y command
		256-byte transliteration table
	on b and t command
		offset of label in script
*/

#define BYTE		CHAR_BIT
#define IMASK		0xC0000000	/* instruction flag */
#define NEG  		0x01000000	/* instruction written with ! */
#define LMASK		0xffff		/* low half word */
#define AMASK		0x7fffffff	/* address mask, clear sign bit */
#define INACT		(~AMASK)	/* inactive bit, the sign bit */
#define DOLLAR		AMASK		/* huge address */
#define REGADR		(~AMASK)	/* context address */
#define PFLAG		0x80000000	/* s/../../p */
#define WFLAG		0x40000000	/* s/../../g */

extern int pack(int neg, int cmd, int length);
extern int *instr(uchar*);
#define code(/*int*/ inst) ((inst)>>2*BYTE & 0xff)
#define nexti(/*uchar**/ p) ((p) + (*instr(p)&LMASK))
#pragma prototyped

#include "sed.h"

static const char id[] = "\n@(#)sed (AT&T Research) 01/01/96\0\n";

void	readscript(Text*, char*);
void	copyscript(Text*, uchar*);
void	initinput(int, char **);
Sfio_t*	aopen(char*);

#define ustrncmp(a,b,c) (uchar*)strncmp((char*)(a), (char*)(b), c)

int reflags;		/* regcomp() flags */
int recno;		/* current record number */
int nflag;		/* nonprint option */
int qflag;		/* command q executed */
int sflag;		/* substitution has occurred */
int bflag;		/* strip leading blanks from c,a,i <text> */

main(int argc, char **argv)
{
	int c;
	static Text script;
	static Text data;
	error_info.id = "sed";
	while (c = optget(argv, "bdne:[expression]f:[script]AE [file ...]"))
		switch (c)
		{
		case 'A':
			reflags |= REG_AUGMENTED;
			break;
		case 'E':
			reflags |= REG_EXTENDED;
			break;
		case 'b':
			bflag++;
			break;
		case 'e':
			copyscript(&data, (uchar*)opt_info.arg);
			break;
		case 'f':
			readscript(&data, opt_info.arg);
			break;
		case 'n':
			nflag++;
			break;
		case '?':
			error(ERROR_USAGE|4, opt_info.arg);
			break;
		case ':':
			error(2, opt_info.arg);
			break;
		}
	if (error_info.errors)
		error(ERROR_USAGE|4, optusage(NiL));
	argv += opt_info.index;
	argc -= opt_info.index;
	if(data.s == 0) {
		if(!*argv)
			error(3, "no script");
		copyscript(&data, (uchar*)*argv++);
		argc--;
	}
	if(ustrncmp(data.s, "#n", 2) == 0)
		nflag = 1;
	copyscript(&data, (uchar*)"\n\n");  /* e.g. s/a/\ */
	compile(&script, &data);
#if DEBUG
	printscript(&script);
#endif

	initinput(argc, argv);
	for(;;) {
		data.w = data.s;
		if(!readline(&data))
			break;
		execute(&script, &data);
	}
	if(sfclose(sfstdout) == EOF)
		error(3, stdouterr);
	return 0;
}

void
grow(Text *t, int n)
{
	int w = t->w - t->s;
	int e = t->e - t->s + (n/SF_BUFSIZE+1)*SF_BUFSIZE;
	t->s = (uchar*)realloc(t->s, e);
	if(t->s == 0)
		error(3, "out of space");
	t->w = t->s + w;
	t->e = t->s + e;
}

/* BUG: a segment that ends with a comment whose
   last character is \ causes a diagnostic */

void
safescript(Text *t)
{
	if(t->w > t->s+1 && t->w[-2] == '\\')
		error(1, "script segment ends with \\");
}

void
readscript(Text *t, char *s)
{
	int n;
	Sfio_t *f = aopen(s);
	for(;;) {
		assure(t, 4);
		n = sfread(f, t->w, t->e - t->w - 3);
		if(n <= 0)
			break;
		t->w += n;
	}
	sfclose(f);
	if(t->w > t->s && t->w[-1] != '\n') {
		*t->w++ = '\n';
		error(1, "newline appended to script segment");
	}
	*t->w = 0;
	safescript(t);
}

void
copyscript(Text *t, uchar *s)
{
	do {
		assure(t, 2);
	} while(*t->w++ = *s++);
	if(--t->w > t->s && t->w[-1] != '\n') {
		*t->w++ = '\n';
		*t->w = 0;
	}
	safescript(t);
}

/* DATA INPUT */

struct {
	int iargc;		/* # of files not fully read */
	char **iargv;		/* current file */
	Sfio_t *ifile;		/* current input file */
} input;

int
readline(Text *t)
{
	char*	s;
	int	c;

	coda();
	if (qflag || ateof())
		return 0;
	while (!(s = sfgetr(input.ifile, '\n', 1)))
	{
		if (s = sfgetr(input.ifile, '\n', -1))
		{
			error(1, "newline appended");
			break;
		}
		error_info.file = 0;
		error_info.line = 0;
		if (--input.iargc <= 0)
			return 0;
		sfclose(input.ifile);
		input.ifile = aopen(*++input.iargv);
		error_info.file = *input.iargv;
	}
	c = sfslen();
	assure(t, c);
	memcpy(t->w, s, c);
	t->w += c - 1;

	/*
	 * peek ahead to identify line $
	 */

	if ((c = sfgetc(input.ifile)) != EOF)
		sfungetc(input.ifile, c);
	else if (input.iargc == 1)
		input.iargc = 0;
	error_info.line++;
	recno++;
	sflag = 0;
	return 1;
}	

int 
ateof(void)
{
	return input.iargc <= 0;
}	

void
initinput(int argc, char **argv)
{
	input.iargc = argc;
	input.iargv = argv;
	if(input.iargc == 0) {
		input.iargc = 1;	/* for ateof() */
		input.ifile = sfstdin;
	} else {
		input.ifile = aopen(*input.iargv);
		error_info.file = *input.iargv;
	}
}

Sfio_t *
aopen(char *s)
{
	Sfio_t *f = sfopen(NiL, s, "r");
	if(f == 0)
		error(ERROR_SYSTEM|3, "%s: cannot open", s);
	return f;
}

#if DEBUG & 1

/* debugging code 1; compile and execute stubs.
   simply prints the already collected script and
   prints numbered input lines */

void
compile(Text *script, Text *t)
{
	uchar *s = t->s;
	assure(script, 1);
	*script->w++ = 0;
	while(*s) sfputc(sfstdout, *s++);
}

void
execute(Text *x, Text *y)
{
	x = x;		
	sfprintf(sfstdout, "%d: %s", recno, y->s);
}

#endif
#pragma prototyped

#include "sed.h"

#include <ctype.h>

#define ustrlen(p) strlen((char*)(p))
#define ustrcmp(p, q) strcmp((char*)(p), (char*)(q))
#define ustrcpy(p, q) (uchar*)strcpy((char*)(p), (char*)(q))
#define ustrchr(p, c) (uchar*)strchr((char*)(p), c)

int blank(Text*);
void fixlabels(Text*);
void fixbrack(Text*);
void ckludge(Text*, int, int, int, Text*);
int addr(Text*, Text*);
int pack(int, int, int);
int* instr(uchar*);
uchar *succi(uchar*);

#if DEBUG
extern void regdump(regex_t*);	/* secret entry into regex pkg */
#endif

int semicolon;
Text rebuf;

uchar adrs[256] = {	/* max no. of addrs, 3 is illegal */
	0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, /* <nl> */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 2, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* !# */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 1, 3, 3, /* := */
	3, 3, 3, 3, 2, 3, 3, 2, 2, 3, 3, 3, 3, 3, 2, 3, /* DGHN */
	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* P */
	3, 1, 2, 2, 2, 3, 3, 2, 2, 1, 3, 3, 2, 3, 2, 3, /* a-n */
	2, 1, 2, 2, 2, 3, 3, 2, 2, 2, 3, 2, 3, 0, 3, 3, /* p-y{} */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
};

#define Ec Tc	/* commands that have same compilation method */
#define Dc Tc
#define Gc Tc
#define Hc Tc
#define Nc Tc
#define Pc Tc
#define dc Tc
#define gc Tc
#define hc Tc
#define lc Tc
#define nc Tc
#define pc Tc
#define qc Tc
#define xc Tc
#define tc bc
#define ic ac
#define cc ac

uchar *synl;	/* current line pointer for syntax errors */

/* COMMAND LAYOUT */

int
blank(Text *t)
{
	if(*t->w==' ' || *t->w=='\t') {
		t->w++;
		return 1;
	} else
		return 0;
}

int *
instr(uchar *p)		/* get address of command word */
{
	int *q = (int*)p;
	while((*q & IMASK) != IMASK)
		q++;
	return q;
}

uchar *
succi(uchar *p)
{
	int *q = instr(p);
	if(code(*q) == '{')
		return (uchar*)(q+1);
	else
		return p + (*q & LMASK);
}

int
pack(int neg, int cmd, int length)
{
	int l = length & LMASK;
	if(length != l)
		syntax("<command-list> or <text> too long");
	return IMASK | neg | cmd << 2*BYTE | l;
}

void
putint(Text *s, int n)
{
	assure(s, sizeof(int));
	*(int*)s->w = n;
	s->w += sizeof(int);
}

int
number(Text *t)
{
	unsigned n = 0;
	while(isdigit(*t->w)) {
		if(n > (INT_MAX-9)/10)
			syntax("number too big");
		n = n*10 + *t->w++ - '0';
	}
	return n;
}	

int
addr(Text *script, Text *t)
{
	int n;
	switch(*t->w) {
	default:
		return 0;
	case '$':
		t->w++;
		n = DOLLAR;
		break;
	case '\\':
		t->w++;
		if(*t->w=='\n' ||*t->w=='\\')
			syntax("bad regexp delimiter");
	case '/':
		n = recomp(&rebuf, t, *t->w++) | REGADR;
		break;
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		n = number(t);
		if(n == 0)
			syntax("address is zero");
	}
	putint(script, n);
	return 1;
}

regex_t *
readdr(int x)
{
	return (regex_t*)(rebuf.s + (x&AMASK));
}

/* LABEL HANDLING */

/* the labels array consists of int values followed by strings.
   value -1 means unassigned; other values are relative to the
   beginning of the script 

   on the first pass, every script ref to a label becomes the
   integer offset of that label in the labels array, or -1 if
   it is a branch to the end of script

   on the second pass (fixlabels), the script ref is replaced
   by the value from the labels array. */

Text labels;

int *
lablook(uchar *l, Text *labels)
{
	uchar *p, *q;
	int n;
	assure(labels, 1);
	for(p = labels->s; p < labels->w; ) {
		q = p + sizeof(int);
		if(ustrcmp(q, l) == 0)
			return (int*)p;
		q += ustrlen(q) + 1;
		p = (uchar*)intp(q);
	}
	n = ustrlen(l);
	assure(labels, sizeof(int)+n+1+sizeof(int));
	*(int*)p = -1;
	q = p + sizeof(int);
	ustrcpy(q, l);
	q += ustrlen(q) + 1;
	labels->w = (uchar*)intp(q);
	return (int*)p;
}

/* find pos in label list; assign value i to label if i>=0 */

int
getlab(Text *t, int i)
{
	int *p;
	uchar *u;
	while(blank(t));	/* not exactly posix */
	for(u=t->w; *t->w!='\n'; t->w++)
		if(!isprint(*t->w) || *t->w==' ')
			synwarn("invisible character in name");
	if(u == t->w)
		return -1;
	*t->w = 0;
	p = lablook(u, &labels);
	if(*p == -1)
		*p = i;
	else if(i != -1)
		syntax("duplicate label");
	*t->w = '\n';
	return (uchar*)p - labels.s;
}

void
Cc(Text *script, Text *t)	/* colon */
{
	if(getlab(t, script->w - sizeof(int) - script->s) == -1)
		syntax("missing label");
}

void
bc(Text *script, Text *t)
{
	int g;
	g = getlab(t, -1);	/* relative pointer to label list */
	putint(script, g);
}
			
void
fixlabels(Text *script)
{
	uchar *p;
	int *q;
	for(p=script->s; p<script->w; p=succi(p)) {
		q = instr(p);
		switch(code(*q)) {
		case 't':
		case 'b':
			if(q[1] == -1)
				q[1] = script->w - script->s;
			else if(*(int*)(labels.s+q[1]) != -1)
				q[1] = *(int*)(labels.s+q[1]);
			else
				error(3, "undefined label: %s",
					labels.s+q[1]+sizeof(int));
		}
	}
	free(labels.s);
}

/* FILES */

Text files;

void
rc(Text *script, Text *t)
{
	uchar *u;
	if(!blank(t))
		synwarn("no space before file name");
	while(blank(t)) ;
	for(u=t->w; *t->w!='\n'; t->w++) ;
	if(u == t->w)
		syntax("missing file name");
	*t->w = 0;
	putint(script, (uchar*)lablook(u, &files) - files.s);
	*t->w = '\n';
}

void
wc(Text *script, Text *t)
{
	int *p;
	rc(script, t);
	p = (int*)(files.s + ((int*)script->w)[-1]);
	if(*p != -1)
		return;
	*(Sfio_t**)p = sfopen(NiL, (char*)(p+1), "w");
	if(*p == 0)
		syntax("can't open file for writing");
}

/* BRACKETS */

Text brack;

/* Lc() stacks (in brack) the location of the { command word.
   Rc() stuffs into that word the offset of the } sequel
   relative to the command word.
   fixbrack() modifies the offset to be relative to the
   beginning of the instruction, including addresses. */

void				/* { */
Lc(Text *script, Text *t)
{
	while(blank(t));
	putint(&brack, script->w - sizeof(int) - script->s);
}

void				/* } */
Rc(Text *script, Text *t)
{
	int l;
	int *p;
	t = t;
	if(brack.w == 0 || (brack.w-=sizeof(int)) < brack.s)
		syntax("unmatched }");
	l = *(int*)brack.w;
	p = (int*)(script->s + l);
	l = script->w - script->s - l;
	if(l >= LMASK - 3*sizeof(int))	/* fixbrack could add 3 */
		syntax("{command-list} too long)");
	*p = (*p&~LMASK) | l;
}

void
fixbrack(Text *script)
{
	uchar *p;
	int *q;
	if(brack.w == 0)
		return;
	if(brack.w > brack.s)
		syntax("unmatched {");
	for(p=script->s; p<script->w; p=succi(p)) {
		q = instr(p);
		if(code(*q) == '{')
			*q += (uchar*)q - p;
	}
	free(brack.s);
}

/* EASY COMMANDS */

void
Xc(Text *script, Text *t)	/* # */
{
	script = script;	/* avoid use/set diagnostics */
	if(t->s[1]=='n')
		nflag = 1;
	while(*t->w != '\n')
		t->w++;
}

void
Ic(Text *script, Text *t)	/* ignore */
{
	script = script;
	t->w--;
}

void
Tc(Text *script, Text *t)	/* trivial to compile */
{
	script = script;
	t = t;
}

void
xx(Text *script, Text *t)
{
	script = script;
	t = t;
	syntax("unknown command");
}

/* MISCELLANY */

void
ac(Text *script, Text *t)
{
	if(*t->w++ != '\\' || *t->w++ != '\n')
		syntax("\\<newline> missing after command");
	for(;;) {
		while(bflag && blank(t)) ;
		assure(script, 2 + sizeof(int));
		switch(*t->w) {
		case 0:
			error(ERROR_PANIC|4, "bug: missed end of <text>");
		case '\n':
			*script->w++ = *t->w;
			*script->w++ = 0;
			script->w = (uchar*)intp(script->w);
			return;
		case '\\':
			t->w++;
		default:
			*script->w++ = *t->w++;
		}
	}
}
void
yc(Text *script, Text *t)
{
	int i;
	int delim = *t->w++;
	uchar *s = script->w;
	uchar *p, *q;
	if(delim == '\n' || delim=='\\')
		syntax("missing delimiter");
	assure(script, 256);
	for(i=0; i<256; i++) 
		s[i] = 0;
	for(q=t->w; *q!=delim; q++)
		if(*q == '\n')
			syntax("missing delimiter");
		else if(*q=='\\' && q[1]==delim)
			q++;
	for(p=t->w, q++; *p != delim; p++, q++) {
		if(*p=='\\' && p[1]==delim)
			p++;
		if(*q == '\n')
			syntax("missing delimiter");
		if(*q == delim)
			syntax("string lengths differ");
		if(*q=='\\' && q[1]==delim)
			q++;
		if(s[*p] && s[*p]!=*q)
			syntax("ambiguous map");
		if(s[*p])
			synwarn("redundant map");
		s[*p] = *q;
	}
	if(*q++ != delim)
		syntax("string lengths differ");
	for(i=0; i<256; i++)
		if(s[i] == 0)
			s[i] = i;
	t->w = q;
	script->w += 256;
}

void
sc(Text *script, Text *t)
{
	int c, flags, re, nsub;
	int *q;
	int n = -1;
	int delim = *t->w++;
	switch(delim) {
	case '\n':
	case '\\':
		syntax("improper delimiter");
	}
	re = recomp(&rebuf, t, delim);
	putint(script, re);
	nsub = readdr(re)->re_nsub;
	flags = script->w - script->s;
	putint(script, 0);		/* space for flags */
	while((c=*t->w++) != delim) {
		assure(script, 3+sizeof(int*));
		if(c == '\n')
			syntax("unterminated command");
		else if(c == '\\') {
			int d = *t->w++;
			if(d==delim)
				;
			else if(d=='&' || d=='\\')
				*script->w++ = c;
			else if(d>='0' && d<='9') {
				if(d > '0'+nsub)
					syntax("improper backreference");
				*script->w++ = c;
			}
			c = d;
		}
		*script->w++ = c;
	}
	*script->w++ = 0;
	script->w = (uchar*)intp(script->w);
	q = (int*)(script->s + flags);
	*q = 0;
	for(;;) {
		switch(*t->w) {
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			if(n != -1)
				syntax("extra flags");
			n = number(t);
			if(n == 0 || (n&(PFLAG|WFLAG)) != 0)
				syntax("count out of range");
			continue;
		case 'p':
			if(*q & PFLAG)
				syntax("extra flags");
			t->w++;
			*q |= PFLAG;
			continue;
		case 'g':
			t->w++;
			if(n != -1)
				syntax("extra flags");
			n = 0;
			continue;
		case 'w':
			t->w++;
			*q |= WFLAG;	 
			wc(script, t);
		}
		break;
	}
	*q |= n==-1? 1: n;
}		

void
synwarn(char *s)
{
	uchar *t = ustrchr(synl, '\n');
	error(1, "%s: %.*s", s, t-synl, synl);
}

void
syntax(char *s)
{
	uchar *t = ustrchr(synl, '\n');
	error(3, "%s: %.*s", s, t-synl, synl);
}

#if DEBUG

void
printscript(Text *script)
{
	uchar *s;
	int *q;
	for(s=script->s; s<script->w; s = succi(s)) {
		q = (int*)s;
		if((*q&IMASK) != IMASK) {
			if((*q&REGADR) == 0)
				printf("%d", *q);
			else
				regdump((regex_t*)(*q & AMASK));
			q++;
		}
		if((*q&IMASK) != IMASK) {
			if((*q&REGADR) == 0)
				printf(",%d", *q);
			else
				regdump((regex_t*)(*q & AMASK));
			q += 2;
		}
		if(code(*q) == '\n')
			continue;
		printf("%s%c\n", *q&NEG?"!":"", code(*q));
	}	
}

#endif

#if DEBUG & 2

/* debugging code 2; execute stub.
   prints the compiled script (without arguments)
   then each input line with line numbers */

void
execute(Text *script, Text *y)
{
	if(recno == 1)
		printscript(script);
	printf("%d:%s",recno,y->s);
}

#endif

typedef void (*cmdf)(Text*, Text*);

static cmdf docom[128] = {
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,Ic,xx,xx,xx,xx,xx, /* <nl> */
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,
	xx,Ic,xx,Xc,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx, /* !# */
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,Cc,Ic,xx,Ec,xx,xx, /* :;= */
	xx,xx,xx,xx,Dc,xx,xx,Gc,Hc,xx,xx,xx,xx,xx,Nc,xx, /* DGHN */
	Pc,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx, /* P */
	xx,ac,bc,cc,dc,xx,xx,gc,hc,ic,xx,xx,lc,xx,nc,xx, /* a-n */
	pc,qc,rc,sc,tc,xx,xx,wc,xc,yc,xx,Lc,xx,Rc,xx,xx  /* p-y{} */
};


void
compile(Text *script, Text *t)
{
	int loc;	/* progam counter */
	int neg;	/* ! in effect */
	int cmd;
	int naddr;
	int *q;		/* address of instruction word */
	t->w = t->s;	/* here w is a read pointer */
	while(*t->w) {
		assure(script, 4*sizeof(int));
		loc = script->w - script->s;
		synl = t->w;
		naddr = 0;
		while(blank(t)) ;
		naddr += addr(script, t);
		if(naddr && *t->w ==',') {
			t->w++;
			naddr += addr(script, t);
			if(naddr < 2)
				syntax("missing address");
		}
		q = (int*)script->w;
		if(naddr == 2)
			*q++ = INACT;
		script->w = (uchar*)(q+1);
		neg = 0;
		for(;;) {
			while(blank(t));
			cmd = *t->w++;
			if(neg && docom[cmd&0xff]==Ic)
				syntax("improper !");
			if(cmd != '!')
				break;
			neg = NEG;
		}
		if(!neg) {
			switch(adrs[cmd]) {
			case 1:
				if(naddr <= 1)
					break;
			case 0:
				if(naddr == 0)
					break;
				syntax("too many addresses");
			}
		}
		(*docom[cmd&0xff])(script, t);
		switch(*t->w) {
		case 0:
			script->w = script->s + loc;
			break;
		default:
			if(cmd == '{')
				break;
			syntax("junk after command");
		case ';':
			if(!semicolon++)
				synwarn("semicolon separators");
		case '\n':
				t->w++;
		}
		*q = pack(neg,cmd,script->w-script->s-loc);
	}
	fixbrack(script);
	fixlabels(script);
}
#pragma prototyped

#include "sed.h"

#include <ctype.h>

#define ustrchr(p, c) (uchar*)strchr((char*)(p), c)

int selected(uchar*, Text*);

#define Re Ie
#define Ce Ie
#define Se Ie
#define re ae

#define IBUG "interpreter bug %d"
char *stdouterr = "writing standard output";

Text hold;

void
cputchar(int c)
{
	if(sfputc(sfstdout, c) == EOF)
		error(3, stdouterr);
}

void
writeline(Text *data)
{
	int n = data->w - data->s;
	if(sfwrite(sfstdout, data->s, n) != n)
		error(ERROR_SYSTEM|3, stdouterr);
	cputchar('\n');
}

/* return 1 if action is to be taken on current line,
         -1 if (numeric) address has been passed,
	  0 otherwise*/
int
sel1(int addr, Text *data)
{
	if(addr & REGADR)
		return regexec(readdr(addr),(char*)data->s,0,0,0) == 0;
	if(addr == recno)
		return 1;
	if(addr == DOLLAR)
		return ateof();
	if(addr < recno)
		return -1;
	return 0;
}

/* return 2 on non-final line of a selected range,
          1 on any other selected line,
	  0 on non-selected lines 
   (the 1-2 distinction matters only for 'c' commands) */

int
selected(uchar *pc, Text *data)
{
	int active;
	int *ipc = (int*)pc;	/* points to address words */
	int *q = instr(pc);	/* points to instruction word */
	int neg = !!(*q & NEG);
	switch(q - ipc)	{
	case 0:			/* 0 address */
		return !neg;
	case 1:			/* 1 address */
		return neg ^ sel1(ipc[0], data)==1;
	case 2:
		error(ERROR_PANIC|4, IBUG,1);
	case 3:			/* 2 address */
		q--;		/* points to activity indicator */
		active = !(*q & INACT);
		if((*q&AMASK) < recno) {
			switch(sel1(ipc[active], data)) {
			case 0:
				if((active&ateof()) == 0)
					break;
			case 1:
				*q = recno;
				if(active)
					*q |= INACT;
				return (neg^1) << (!active&!ateof());
			case -1:
				if(active) {
					*q = recno | INACT;
					return neg;
				}
			}
		}
		return (neg^active) << 1;
	default:
		error(ERROR_PANIC|4, IBUG,2);
		return 0;	/* dummy */
	}
}

void
vacate(Text *t)
{
	assure(t, 1);
	t->w = t->s;
	*t->w = 0;
}

void
tcopy(Text *from, Text *to)
{
	int n = from->w - from->s;
	assure(to, n+1);
	memmove(to->w, from->s, n);
	to->w += n;
	*to->w = 0;
}
	

/* EASY COMMANDS */

uchar *
vv(Text *script, uchar *pc, Text *data)
{
	script = script;
	pc = pc;
	data = data;
	error(ERROR_PANIC|4, IBUG,3);
	return 0;	/* dummy */
}

uchar *
be(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return script->s + instr(pc)[1];
}

uchar *
de(Text *script, uchar *pc, Text *data)
{
	pc = pc;
	vacate(data);
	return 0;
}

uchar *
De(Text *script, uchar *pc, Text *data)
{
	int n;
	uchar *end = (uchar*)ustrchr(data->s, '\n');
	if(end == 0)
		return de(script, pc, data);
	end++;
	n = data->w - end;
	memmove(data->s, end, n+1);
	data->w = data->s + n;
	return script->s;
}

uchar *
Ee(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	if(sfprintf(sfstdout, "%d\n", recno) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return nexti(pc);
}

uchar *
Ge(Text *script, uchar *pc, Text *data)
{
	script = script;
	if(hold.s == 0) 
		vacate(&hold);
	if(data->w > data->s)
		*data->w++ = '\n';
	tcopy(&hold, data);
	return nexti(pc);
}

uchar *
ge(Text *script, uchar *pc, Text *data)
{
	vacate(data);
	return Ge(script, pc, data);
}

uchar *
He(Text *script, uchar *pc, Text *data)
{
	script = script;
	assure(&hold, 1);
	*hold.w++ = '\n';
	tcopy(data, &hold);
	return nexti(pc);
}

uchar *
he(Text *script, uchar *pc, Text *data)
{
	script = script;
	vacate(&hold);
	tcopy(data, &hold);
	return nexti(pc);
}

uchar *
Ie(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return nexti(pc);
}

uchar *
ie(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	if(sfprintf(sfstdout, "%s", (char*)(instr(pc)+1)) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return nexti(pc);
}

uchar *
Le(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return (uchar*)(instr(pc)+1);
}

uchar *
Ne(Text *script, uchar *pc, Text *data)
{
	assure(data, 1);
	*data->w++ = '\n';
	if(readline(data))
		return nexti(pc);
	*--data->w = 0;
	return de(script, pc, data);
}

uchar *
ne(Text *script, uchar *pc, Text *data)
{
	if(!nflag)
		writeline(data);
	vacate(data);
	if(readline(data))
		return nexti(pc);
	return 0;
}

uchar *
Pe(Text *script, uchar *pc, Text *data)
{
	int n;
	uchar *end = ustrchr(data->s, '\n');
	if(end == 0)
		n = data->w - data->s;
	else
		n = end - data->s;
	if(sfwrite(sfstdout, data->s, n) != n)
		error(ERROR_SYSTEM|3, stdouterr);
	cputchar('\n');
	script = script;
	return nexti(pc);
}

uchar *
pe(Text *script, uchar *pc, Text *data)
{
	writeline(data);
	script = script;
	return nexti(pc);
}

uchar *
qe(Text *script, uchar *pc, Text *data)
{
	pc = pc;
	data = data;
	qflag++;
	return script->w;
}

uchar *
te(Text *script, uchar *pc, Text *data)
{
	int tflag = sflag;
	sflag = 0;
	if(tflag)
		return be(script, pc, data);
	else
		return nexti(pc);
}

uchar *
ww(Text *script, uchar *pc, Text *data, int offset)
{
	int *q = (int*)(files.s + offset);
	Sfio_t *f = *(Sfio_t**)q;
	int n = data->w - data->s;
	assure(data, 1);
	*data->w = '\n';
	if(sfwrite(f, data->s, n+1) != n+1 ||
	   sfsync(f) == EOF)	/* in case of subsequent r */
		error(ERROR_SYSTEM|3, "%s: cannot write", (char*)(q+1));
	*data->w = 0;
	script = script;
	return nexti(pc);
}

uchar *
we(Text *script, uchar *pc, Text *data)
{
	return ww(script, pc, data, instr(pc)[1]);
}

uchar *
xe(Text *script, uchar *pc, Text *data)
{
	uchar *t;
	script = script;
	if(hold.s == 0)
		vacate(&hold);
	exch(data->s, hold.s, t);
	exch(data->e, hold.e, t);
	exch(data->w, hold.w, t);
	return nexti(pc);
}

uchar *
ye(Text *script, uchar *pc, Text *data)
{
	uchar *s = (uchar*)data->s;
	uchar *w = (uchar*)data->w;
	uchar *tbl = (uchar*)(instr(pc)+1);
	for( ; s<w; s++)
		*s = tbl[*s];
	script = script;
	return nexti(pc);
}

/* MISCELLANY */

uchar *
se(Text *script, uchar *pc, Text *data)
{
	int *q = instr(pc);
	int flags = q[2];
	uchar *p = (uchar*)(flags&WFLAG? q+4: q+3);
	int n = flags & ~(PFLAG|WFLAG);

	sflag = substitute(readdr(q[1]), data, p, n);
	if(!sflag)
		return nexti(pc);
	if(flags & PFLAG)
		pe(script, pc, data);
	if(flags & WFLAG)
		return ww(script, pc, data, ((int*)nexti(pc))[-1]);
	return nexti(pc);
}

struct { char p, q; } digram[] = {
	'\\',	'\\',
	'\a',	'a',
	'\b',	'b',
	'\f',	'f',
	'\n',	'n',
	'\r',	'r',
	'\t',	't',
	'\v',	'v',
};

uchar *
le(Text *script, uchar *pc, Text *data)
{
	int i = 0;
	int j;
	uchar *s;
	script = script;
	for(s=data->s; s<data->w; s++, i++) {
		if(i >= 60) {
			cputchar('\\');
			cputchar('\n');
			i = 0;
		}
		for(j=0; j<sizeof(digram)/sizeof(*digram); j++)
			if(*s == digram[j].p) {
				cputchar('\\');
				cputchar(digram[j].q);
				goto cont;
			}
		if(!isprint(*s)) {
			if(sfprintf(sfstdout, "\\%3.3o", *s) <= 0)
				error(ERROR_SYSTEM|3, stdouterr);
		} else
			cputchar(*s);
	cont:	;
	}
	cputchar('$');
	cputchar('\n');
	return nexti(pc);
}	

/* END-OF-CYCLE STUFF */

Text todo;

uchar *
ae(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	assure(&todo, sizeof(uchar*));
	*(uchar**)todo.w = pc;
	todo.w += sizeof(uchar*);
	return nexti(pc);
}

uchar *
ce(Text *script, uchar *pc, Text *data)
{	
	if(sfprintf(sfstdout, "%s", (char*)(instr(pc)+1)) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return de(script, pc, data);
}

void
coda(void)
{
	int *q;
	uchar *p;
	Sfio_t *f;
	if(todo.s == 0)
		return;
	for(p=todo.s; p<todo.w; p+=sizeof(int)) {
		q = instr(*(uchar**)p);
		switch(code(*q)) {
		case 'a':
			if(sfprintf(sfstdout, "%s", (char*)(q+1)) <= 0)
				error(ERROR_SYSTEM|3, stdouterr);
			continue;
		case 'r':
			f = sfopen(NiL, (char*)(files.s+q[1]+sizeof(int)), "r");
			if(f == 0)
				continue;
			if (sfmove(f, sfstdout, SF_UNBOUND, -1) < 0 || !sfeof(f) || sferror(sfstdout))
				error(ERROR_SYSTEM|3, stdouterr);
			sfclose(f);
			continue;
		default:
			error(ERROR_PANIC|4, IBUG,5);
		}
	}
	vacate(&todo);
}

/* execution functions return pointer to next instruction */

typedef uchar* (*exef)(Text*, uchar *, Text*);

static exef excom[128] = {
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,Ie,vv,vv,vv,vv,vv,
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,
	vv,vv,vv,Ie,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv, /* # */
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,Ce,Se,vv,Ee,vv,vv, /* :;= */
	vv,vv,vv,vv,De,vv,vv,Ge,He,vv,vv,vv,vv,vv,Ne,vv, /* DGHN */
	Pe,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv, /* P */
	vv,ae,be,ce,de,vv,vv,ge,he,ie,vv,vv,le,vv,ne,vv, /* a-n */
	pe,qe,re,se,te,vv,vv,we,xe,ye,vv,Le,vv,Re,vv,vv  /* p-y{} */
};

void
execute(Text *script, Text *data)
{
	uchar *pc;
	int sel;
	for(pc = script->s; pc < script->w; ) {
		sel = selected(pc, data);
		if(sel) {
			int cmd = code(*instr(pc));
			if(sel==2 && cmd=='c')
				cmd = 'd';
			pc = (*excom[cmd])(script, pc, data);
			if(pc == 0)
				return;
		} else
			pc = nexti(pc);
	}
	if(!nflag)
		writeline(data);
}
#pragma prototyped

#include "sed.h"

void docopy(uchar *where, int n);
int dosub(uchar *where, uchar *rp);

Text retemp;	/* holds a rewritten regex, without delimiter */

int
recomp(Text *rebuf, Text *t, int delim)
{
	static int lastre;
	uchar *w;
	vacate(&retemp);
	for(w=t->w; ; retemp.w++,w++) {
		assure(&retemp, 2);
		*retemp.w = *w;
		if(*w == delim)
			break;
		else if(*w==0 || *w=='\n')
			syntax("unterminated address");
		else if(*w != '\\')
			continue;
		else if(*++w==delim)
			*retemp.w = delim;
		else if(*w == 'n')
			*retemp.w = '\n';
		else if(*w==0 || *w=='\n')
			syntax("unterminated regular expression");
		else {
			assure(&retemp, 2);
			*++retemp.w = *w;
		}
	}
	*retemp.w = 0;

	assure(rebuf, sizeof(regex_t));
	if(*retemp.s) {
		if(regcomp((regex_t*)rebuf->w,(char*)retemp.s,reflags))
			syntax("bad regular expression");
		lastre = rebuf->w - rebuf->s;
		rebuf->w += sizeof(regex_t);
	} else if(rebuf->w == rebuf->s)
		syntax("no previous regular expression");
	t->w = w + 1;
	return lastre;
}

Text gendata;

#define NMATCH 10
regmatch_t matches[NMATCH];
#define so matches[0].rm_so
#define eo matches[0].rm_eo

int
substitute(regex_t *re, Text* data, uchar *rhs, int n)
{
	Text t;
	uchar *where = data->s;
	if(regexec(re, (char*)data->s, NMATCH, matches, 0))
		return 0;
	vacate(&gendata);
	if(n == 0)
		do {
			docopy(where, so);
			if(!dosub(where, rhs))
				return 0;
			where += eo;
			if(eo == so)
				if(where < data->w)
					docopy(where++, 1);
				else
					goto done;
		} while(regexec(re, (char*)where, NMATCH, matches, REG_NOTBOL) == 0);
	else {
		while(--n > 0) {
			where += eo;
			if(eo == so)
				if(where < data->w)
					where++;
				else
					return 0;
			if(regexec(re, (char*)where, NMATCH, matches, REG_NOTBOL))
				return 0;
		}
		docopy(data->s, where-data->s+so);
		if(!dosub(where, rhs))
			return 0;
		where += eo;
	}			
	eo = so = data->w - where;
	docopy(where, so);
done:
	exch(gendata, *data, t);
	return 1;
}

void
docopy(uchar *where, int n)
{
	assure(&gendata, n+1);
	memmove(gendata.w, where, n);
	gendata.w += n;
	*gendata.w = 0;
}

	/* interpretation problem: if there is no match for \1, say,
           does the substitition occur?  dosub uses a null string.
	   a change where indicated will abort the substitution */
	
int
dosub(uchar *where, uchar *rp)
{
	int c, n;
	regmatch_t *m;

	while(c = *rp++) {
		if(c == '\\') {
			c = *rp++;
			if (c >= '1' && c <= '9') {
				m = matches + c - '0';
				if(m->rm_eo == -1)
					continue;   /* or return 0 */
				n = m->rm_eo - m->rm_so;
				assure(&gendata, n);
				memmove(gendata.w,where+m->rm_so,n);
				gendata.w += n;
				continue;
			}
		} else if(c == '&') {
				assure(&gendata, eo-so);
				memmove(gendata.w,where+so,eo-so);
				gendata.w += eo-so;
				continue;
		}
		assure(&gendata, 1);
		*gendata.w++ = c;
	}
	return 1;
}
#pragma prototyped

/*
 * regular-expression tester
 *
 * usage: testre <testre.dat
 * see comments in testre.dat for description of format
 */

static const char id[] = "\n@(#)testre (AT&T Research) 01/01/96\0\n";

#include <ast.h>
#include <ctype.h>
#include <regex.h>
#include <setjmp.h>
#include <sig.h>
#include <stk.h>

#define LOOPED		2

#define NOTEST		(~0)
#ifndef REG_LEFT
#define REG_LEFT	NOTEST
#endif
#ifndef REG_MINIMAL
#define REG_MINIMAL	NOTEST
#endif
#ifndef REG_NULL
#define REG_NULL	NOTEST
#endif
#ifndef REG_RIGHT
#define REG_RIGHT	NOTEST
#endif

#define REG_UNKNOWN	(-1)

#ifndef REG_ENEWLINE
#define REG_ENEWLINE	(REG_UNKNOWN-1)
#endif
#ifndef REG_ENULL
#define REG_ENULL	(REG_UNKNOWN-2)
#endif
#ifndef REG_ECOUNT
#define REG_ECOUNT	(REG_UNKNOWN-3)
#endif
#ifndef REG_BADESC
#define REG_BADESC	(REG_UNKNOWN-4)
#endif
#ifndef REG_EMEM
#define REG_EMEM	(REG_UNKNOWN-5)
#endif
#ifndef REG_ELOOP
#define REG_ELOOP	(REG_UNKNOWN-6)
#endif
#ifndef REG_EBUS
#define REG_EBUS	(REG_UNKNOWN-7)
#endif
#ifndef REG_EFAULT
#define REG_EFAULT	(REG_UNKNOWN-8)
#endif

static const struct { int code; char* name; } codes[] = {
	REG_UNKNOWN,	"UNKNOWN",
	REG_NOMATCH,	"NOMATCH",
	REG_BADPAT,	"BADPAT",
	REG_ECOLLATE,	"ECOLLATE",
	REG_ECTYPE,	"ECTYPE",
	REG_EESCAPE,	"EESCAPE",
	REG_ESUBREG,	"ESUBREG",
	REG_EBRACK,	"EBRACK",
	REG_EPAREN,	"EPAREN",
	REG_EBRACE,	"EBRACE",
	REG_BADBR,	"BADBR",
	REG_ERANGE,	"ERANGE",
	REG_ESPACE,	"ESPACE",
	REG_BADRPT,	"BADRPT",
	REG_ENEWLINE,	"ENEWLINE",
	REG_ENULL,	"ENULL",
	REG_ECOUNT,	"ECOUNT",
	REG_BADESC,	"BADESC",
	REG_EMEM,	"EMEM",
	REG_ELOOP,	"ELOOP",
	REG_EBUS,	"EBUS",
	REG_EFAULT,	"EFAULT",
};

static struct
{
	int	failures;
	int	goofs;
	int	lineno;
	int	ret;
	int	signals;
	char*	which;
	jmp_buf	gotcha;
} state;

static void
report(char* comment, char* re, char* s, int flags)
{
	state.failures++;
	sfprintf(sfstdout, "%d:", state.lineno);
	if(re) {
		sfprintf(sfstdout, "%s", re);
		if(s)
			sfprintf(sfstdout, " versus %s", s);
	}
	sfprintf(sfstdout, " %s%s %s", state.which, (flags & REG_NOSUB) ? " NOSUB" : "", comment);
}

static void
bad(char* comment, char* re, char* s)
{
	sfprintf(sfstdout,  "bad test case ");
	report(comment, re, s, 0);
	exit(1);
}

static void
doregerror(regex_t* preg, int code, int lineno)
{
	char*	msg;
	char	buf[200];

	switch (code)
	{
	case REG_EBUS:
		msg = "bus error";
		break;
	case REG_EFAULT:
		msg = "memory fault";
		break;
	case REG_ELOOP:
		msg = "did not terminate";
		break;
	default:
		regerror(code, preg, msg = buf, sizeof buf);
		break;
	}
	sfprintf(sfstdout, "%s\n", msg);
}

static int
readfield(char* f, char end)
{
	int	c;

	for(;;) {
		*f = 0;
		c = sfgetc(sfstdin);
		if(c == EOF)
			return 1;
		if(c == end)
			break;
		if(c == '\n')
			return 1;
		*f++ = c;
	} 
	if(c == '\t') {
		while(c == end)
			c = sfgetc(sfstdin);
		sfungetc(sfstdin, c);
	}
	return 0;
}

static int
hex(int c)
{
	return	isdigit(c) ? c-'0' :
		isupper(c) ? c-'A' :
		c-'a'+10;
}

static void
escape(char* s)
{
	char*	t;

	for(t=s; *t=*s; s++, t++) {
		if(*s != '\\')
			continue;
		switch(*++s) {
		case 0:
			*++t = 0;
			break;
		case 'n':
			*t = '\n';
			break;
		case 'x':
			if(!isxdigit(s[1]) || !isxdigit(s[2]))
				bad("bad \\x\n", NiL, NiL);
			*t = hex(*++s) << 4;
			*t |= hex(*++s);
			break;
		default:
			s--;
		}
	}
}

static int
readline(char* spec, char* re, char* s, char* ans)
{
	int	c;

	switch(c = sfgetc(sfstdin)) {
	case EOF:
		return 0;
	case '#':
		while(c != '\n')
			c = sfgetc(sfstdin);
	case '\n':
		*spec = 0;
		return 1;
	}
	sfungetc(sfstdin, c);
	if(readfield(spec, '\t')) return 0;
	if(readfield(re, '\t')) return 0;
	if(readfield(s, '\t')) return 0;
	if(readfield(ans, '\n')) return 0;
	escape(re);
	escape(s);
	return 1;
}

static void
matchprint(regmatch_t* match, int nmatch)
{
	int	i;

	for( ; nmatch>0; nmatch --)
		if(match[nmatch-1].rm_so != -1)
			break;
	for(i=0; i<nmatch; i++) {
		sfprintf(sfstdout, "(");
		if(match[i].rm_so == -1)
			sfprintf(sfstdout, "?");
		else
			sfprintf(sfstdout, "%d", match[i].rm_so);
		sfprintf(sfstdout, ",");
		if(match[i].rm_eo == -1)
			sfprintf(sfstdout, "?");
		else
			sfprintf(sfstdout, "%d", match[i].rm_eo);
		sfprintf(sfstdout, ")");
	}
	sfprintf(sfstdout, "\n");
}

static int
matchcheck(int nmatch, regmatch_t* match, char* ans, char* re, char* s, int flags)
{
	char*	p;
	int	i;
	int	m;
	int	n;

	for(i = 0, p = ans; i<nmatch && *p; i++) {
		if(*p++ != '(')
			bad("improper answer\n", re, s);
		if(*p == '?') {
			m = -1;
			p++;
		} else
			m = strtol(p, &p, 10);
		if(*p++ != ',')
			bad("improper answer\n", re, s);
		if(*p == '?') {
			n = -1;
			p++;
		} else
			n = strtol(p, &p, 10);
		if(*p++ != ')')
			bad("improper answer\n", re, s);
		if(m!=match[i].rm_so || n!=match[i].rm_eo) {
			report("match was: ", re, s, flags);
			matchprint(match, nmatch);
			return 0;
		}
	}
	for( ; i<nmatch; i++) {
		if(match[i].rm_so!=-1 || match[i].rm_eo!=-1) {
			report("match was: ", re, s, flags);
			matchprint(match, nmatch);
			return 0;
		}
	}
	return 1;
}

static void
gotcha(int sig)
{
	signal(sig, gotcha);
	alarm(0);
	state.signals++;
	switch (sig)
	{
	case SIGALRM:
		state.ret = REG_ELOOP;
		break;
	case SIGBUS:
		state.ret = REG_EBUS;
		break;
	case SIGSEGV:
		state.ret = REG_EFAULT;
		break;
	}
	sigunblock(sig);
	longjmp(state.gotcha, 1);
}

static void*
stkresize(void* handle, void* p, size_t n)
{
	void*	x;

	if (!n || !(x = stkalloc((Stk_t*)handle, n)))
		return 0;
	if (p)
		memcpy(x, p, n / 2);
	return x;
}

main(int argc, char** argv)
{
	regmatch_t	NOMATCH;
	int		flags;
	int		cflags;
	int		eflags;
	int		are;
	int		bre;
	int		ere;
	int		kre;
	int		lre;
	int		sre;
	char		spec[10];
	char		re[1000];
	char		s[100000];
	char		ans[500];
	char		msg[500];
	regmatch_t	match[100];
	regex_t		preg;
	char*		p;
	int		nmatch;
	int		cret;
	int		eret;
	int		i;
	int		expected;
	int		got;
	int		len;

	int		catch = 0;
	int		testno = 0;
	int		verbose = 0;
	off_t		stk = -1;

	sfprintf(sfstdout, "TEST	<regex>");
	while((p = *++argv) && *p == '-')
		for(;;)
		{
			switch(*++p)
			{
			case 0:
				break;
			case 'c':
				catch = 1;
				sfprintf(sfstdout, ", catch");
				continue;
			case 's':
#ifdef REG_AUGMENTED
				stk = stktell(stkstd);
				regalloc((void*)stkstd, stkresize, REG_NOFREE);
				sfprintf(sfstdout, ", stkstd");
#endif
				continue;
			case 'v':
				verbose = 1;
				sfprintf(sfstdout, ", verbose");
				continue;
			default:
				sfprintf(sfstdout, ", invalid option %c", *p);
				continue;
			}
			break;
		}
	if(p)
		sfprintf(sfstdout, ", argument(s) ignored");
	sfprintf(sfstdout, "\n");
	if(catch) {
		signal(SIGALRM, gotcha);
		signal(SIGBUS, gotcha);
		signal(SIGSEGV, gotcha);
	}
	NOMATCH.rm_so = -2;
	NOMATCH.rm_eo = -2;
	while(readline(spec, re, s, ans)) {
		state.lineno++;
		if(*spec == 0)
			continue;
		sfsync(sfstdout);

	/* interpret: */

		cflags = eflags = are = bre = ere = kre = lre = sre = 0;
		nmatch = 20;
		for(p=spec; *p; p++) {
			if(isdigit(*p)) {
				nmatch = strtol(p, &p, 10);
				p--;
				continue;
			}
			switch(*p) {

			case 'A':
				are = 1;
				continue;
			case 'B':
				bre = 1;
				continue;
			case 'E':
				ere = 1;
				continue;
			case 'K':
				kre = 1;
				continue;
			case 'L':
				lre = 1;
				continue;
			case 'S':
				sre = 1;
				continue;

			case 'I':
				cflags |= REG_ICASE;
				continue;
			case 'M':
				cflags |= REG_MINIMAL;
				continue;
			case 'U':
				cflags |= REG_NULL;
				continue;
			case 'W':
				cflags |= REG_NEWLINE;
				continue;

			case 'a':
				cflags |= REG_LEFT|REG_RIGHT;
				continue;
			case 'b':
				eflags |= REG_NOTBOL;
				continue;
			case 'e':
				eflags |= REG_NOTEOL;
				continue;
			case 'l':
				cflags |= REG_LEFT;
				continue;
			case 'r':
				cflags |= REG_RIGHT;
				continue;

			case '?':
				continue;

			default:
				bad("bad spec\n", re, s);

			}
		}
		if(streq(re, "NULL"))
			re[0] = 0;
		if(streq(s, "NULL"))
			s[0] = 0;
		if((cflags|eflags) == NOTEST)
			continue;

	compile:

		if(bre) {
			state.which = "BRE";
			bre = 0;
			flags = cflags;
		}
		else if(ere) {
			state.which = "ERE";
			ere = 0;
			flags = cflags | REG_EXTENDED;
		}
#ifdef REG_AUGMENTED
		else if(are) {
			state.which = "ARE";
			are = 0;
			flags = cflags | REG_AUGMENTED;
		}
#endif
#ifdef REG_LITERAL
		else if(lre) {
			state.which = "LRE";
			lre = 0;
			flags = cflags | REG_LITERAL;
		}
#endif
#ifdef REG_SHELL
		else if(sre) {
			state.which = "SRE";
			sre = 0;
			flags = cflags | REG_SHELL;
		}
#ifdef REG_AUGMENTED
		else if(kre) {
			state.which = "KRE";
			kre = 0;
			flags = cflags | REG_SHELL | REG_AUGMENTED;
		}
#endif
#endif
		else
			continue;
		if(verbose)
			sfprintf(sfstdout, "test %-3d %s \"%s\" \"%s\"\n", state.lineno, state.which, re, s);

	nosub:

		testno++;
		if(catch) {
			if(setjmp(state.gotcha))
				cret = state.ret;
			else {
				alarm(LOOPED);
				cret = regcomp(&preg, re, flags);
				alarm(0);
			}
		} else
			cret = regcomp(&preg, re, flags);
		if(cret == 0) {
			if(!streq(ans, "NULL") &&
			   !streq(ans, "NOMATCH") &&
			   ans[0]!='(') {
				report("regcomp should fail and didn't\n", re, NiL, flags);
				continue;
			}
		} else {
			if(streq(ans, "NULL") ||
			   ans[0]=='(' ||
			   cret==REG_BADPAT && streq(ans, "NOMATCH")) {
				report("regcomp failed: ", re, NiL, flags);
				doregerror(&preg, cret, state.lineno);
			} else {
				expected = got = 0;
				for(i=1; i<elementsof(codes); i++) {
					if(streq(ans, codes[i].name))
						expected = i;
					if(cret==codes[i].code)
						got = i;
				}
				if(!expected)
				{
					report("invalid error code: ", re, NiL, flags);
					sfprintf(sfstdout, "%s expected, %s returned\n", ans, codes[got].name);
				}
				else if(cret!=codes[expected].code && cret!=REG_BADPAT) {
					report("regcomp should fail and did: ", re, NiL, flags);
					sfprintf(sfstdout, "%s expected, %s returned: ", ans, codes[got].name);
					state.failures--;
					state.goofs++;
					doregerror(&preg, cret, state.lineno);
				}
			}
			goto compile;
		}

	/* execute: */
		
		for(i=0; i<elementsof(match); i++)
			match[i] = NOMATCH;

		if(catch) {
			if(setjmp(state.gotcha))
				eret = state.ret;
			else {
				alarm(LOOPED);
				eret = regexec(&preg, s, nmatch, match, eflags);
				alarm(0);
			}
		} else
			eret = regexec(&preg, s, nmatch, match, eflags);

		if(flags & REG_NOSUB) {
			if(eret) {
				report("regexec REG_NOSUB failed: ", re, s, flags);
				doregerror(&preg, eret, state.lineno);
			}
		} else if(eret) {
			if(!streq(ans, "NOMATCH")) {
				report("regexec failed", re, s, flags);
				if(eret != REG_NOMATCH) {
					sfprintf(sfstdout, ": ");
					doregerror(&preg, eret, state.lineno);
				} else
					sfprintf(sfstdout, "\n");
			}
		} else if(streq(ans, "NOMATCH")) {
			report("regexec should fail and didn't: ", re, s, flags);
			matchprint(match, nmatch);
		} else if(streq(ans, "NULL")) {
			if(match[0].rm_so != NOMATCH.rm_so) {
				report("no match but match array assigned: ", re, s, flags);
				matchprint(match, nmatch);
			}
		} else if (matchcheck(nmatch, match, ans, re, s, flags)) {
			if(stk >= 0)
				stkseek(stkstd, stk);
			else
				regfree(&preg);
			flags |= REG_NOSUB;
			goto nosub;
		}
		if(stk >= 0)
			stkseek(stkstd, stk);
		else
			regfree(&preg);
		goto compile;
	}
	sfprintf(sfstdout, "TEST	<regex>, %d tests", testno);
	if(state.goofs)
		sfprintf(sfstdout, ", %d goofs", state.goofs);
	if(state.signals)
		sfprintf(sfstdout, ", %d signals", state.signals);
	sfprintf(sfstdout, ", %d errors\n", state.failures);
	return 0;
}
#pragma prototyped
/*
 * Editor (snarfed from v10, now posix compliant, no hard limits)
 */

static const char id[] = "\n@(#)ed (AT&T Research) 01/01/96\0\n";

#include <ast.h>
#include <error.h>
#include <ls.h>
#include <sfstr.h>
#include <sig.h>

#include <ctype.h>
#include <regex.h>
#include <setjmp.h>

#define BLOCK_LINE	1024
#define BLOCK_TMP	(8*SF_BUFSIZE)

#define BREAK_PAGE	23
#define BREAK_LINE	72

#define LINE_GLOBAL	((off_t)0x80000000)
#define LINE_MARKED	((off_t)0x40000000)
#define LINE_NONE	((off_t)-1)

#define MARK_MIN	'a'
#define MARK_MAX	'z'

#define MATCH_MIN	'0'
#define MATCH_MAX	'9'

#define PRINT		01
#define PRINT_LIST	02
#define PRINT_NUMBER	04

#define REC_IGNORE	001
#define REC_LINE	002
#define REC_SPLICE	004
#define REC_TERMINATE	010
#define REC_TEXT	020

#define BEG(n)		(ed.line+ed.match[n].rm_so)
#define CUR()		(ed.line)
#define END(n)		(ed.line+ed.match[n].rm_eo)
#define HIT(n)		(ed.match[n].rm_eo!=-1)
#define NXT()		(ed.line++)
#define SET(p)		(ed.line=(p))

#define error		fatal
#define trap()		do{if(ed.caught)handle();}while(0);

#define swap(t,a,b)	(ed.swp=(void*)(a),(a)=(b),(b)=(t)ed.swp)

typedef struct
{
	off_t		offset;
	off_t		undo;
	unsigned long	event;
} Line_t;

static int		signals[] = { SIGQUIT, SIGHUP, SIGINT, SIGTERM };

static struct		/* program state -- no other dynamic globals */
{
	struct
	{
	Sfio_t*		file;
	Sfio_t*		global;
	Sfio_t*		help;
	Sfio_t*		line;
	Sfio_t*		prompt;
	Sfio_t*		query;
	Sfio_t*		shell;
	Sfio_t*		substitute;
	Sfio_t*		work;
	}		buffer;
	struct
	{
	int		print;
	int		size;
	}		page;
	struct
	{
	off_t		marks[MARK_MAX - MARK_MIN + 1];
	unsigned long	dol;
	unsigned long	dot;
	}		undo;
	Line_t*		addr1;
	Line_t*		addr2;
	Line_t*		dol;
	Line_t*		dot;
	Line_t*		zero;
	Sfio_t*		iop;
	Sfio_t*		msg;
	Sfio_t*		tmp;
	char*		global;
	char*		line;
	char*		linebreak;
	char*		tmpfile;
	int		caught;
	int		compiled;
	int		evented;
	int		given;
	int		help;
	int		initialized;
	int		interactive;
	int		lastc;
	int		marked;
	int		modified;
	int		peekc;
	int		pending;
	int		print;
	int		prompt;
	int		verbose;
	int		warn_newline;
	int		warn_null;
	jmp_buf		again;
	off_t		marks[MARK_MAX - MARK_MIN + 1];
	off_t		tmpoff;
	regex_t		re;
	regmatch_t	match[MATCH_MAX - MATCH_MIN + 1];
	unsigned long	all;
	unsigned long	bytes;
	unsigned long	event;
	unsigned long	lines;
	void*		swp;
}			ed;

static void		commands(void);
static void		handle(void);
static void		quit(int);

static void
interrupt(int sig)
{
	signal(sig, interrupt);
	if (ed.initialized) {
		if (!ed.caught)
			ed.caught = sig;
	}
	else if (!ed.pending)
		ed.pending = sig;
}

static int
getchr(void)
{
	if (ed.lastc = ed.peekc) {
		ed.peekc = 0;
		return(ed.lastc);
	}
	if (ed.global) {
		if (ed.lastc = *ed.global++)
			return(ed.lastc);
		ed.global = 0;
		return(EOF);
	}
	if ((ed.lastc = sfgetc(sfstdin)) == EOF)
		trap();
	return(ed.lastc);
}

static ssize_t
helpwrite(int fd, const void* buf, size_t len)
{
	ssize_t	n;

	NoP(fd);
	n = ed.help ? sfwrite(ed.msg, buf, len) : ed.verbose ? sfputr(ed.msg, "?", '\n') : 0;
	sfstrset(ed.buffer.help, 0);
	sfwrite(ed.buffer.help, buf, len - 1);
	sfputc(ed.buffer.help, 0);
	return(n);
}

static void
error(int level, ...)
{
	va_list		ap;
	register int	c;

	trap();
	va_start(ap, level);
	errorv(NiL, level, ap);
	va_end(ap);
	if (level >= 2) {
		if (ed.iop) {
			sfclose(ed.iop);
			ed.iop = 0;
			error_info.file = 0;
		}
		if (ed.interactive <= 0 && (ed.interactive = isatty(0)) <= 0)
			quit(1);
		ed.print = 0;
		ed.bytes = 0;
		ed.lines = 0;
		if (ed.global)
			ed.lastc = '\n';
		ed.global = 0;
		ed.peekc = ed.lastc;
		if (ed.lastc)
			while ((c = getchr()) != '\n' && c != EOF)
				;
		longjmp(ed.again, 1);
	}
}

static void
init(void)
{
	register Sfio_t**	ss;
	register int		c;

	ed.interactive = -1;
	ed.msg = sfstdout;
	ed.all = BLOCK_LINE;
	ed.page.size = BREAK_PAGE;
	ed.verbose = 1;
	for (c = 0; c < elementsof(signals); c++)
		if (signal(signals[c], interrupt) == SIG_IGN)
			signal(signals[c], SIG_IGN);
	for (ss = (Sfio_t**)&ed.buffer; ss < (Sfio_t**)(((char*)&ed.buffer) + sizeof(ed.buffer)); ss++) {
		if (!(*ss = sfstropen()))
			error(ERROR_SYSTEM|3, "cannot initialize internal buffer");
		sfputc(*ss, 0);
		sfstrset(*ss, 0);
	}
	sfputr(ed.buffer.help, "?", 0);
	if (!(ed.zero = newof(NiL, Line_t, ed.all, 0)))
		error(ERROR_SYSTEM|3, "out of space [zero]");
}

static char*
getrec(register Sfio_t* sp, register int delimiter, register int flags)
{
	register int	c;
	register char*	glob;

	sfstrset(sp, 0);
	glob = ed.global;
	while ((c = getchr()) != delimiter) {
		if (c == '\n') {
			ed.peekc = c;
			break;
		}
		if (c == EOF) {
			if (glob)
				ed.peekc = (flags & REC_LINE) ? 0 : c;
			else if (delimiter != '\n' || (flags & (REC_LINE|REC_SPLICE)))
				error(2, "unexpected EOF");
			else if (flags & REC_TEXT)
				return(0);
			break;
		}
		if (c == '\\' && ((c = getchr()) != delimiter || (flags & REC_SPLICE) && c != '\n') && c && !(flags & REC_IGNORE))
			sfputc(sp, '\\');
		if (!c)
			error(1, "null character ignored");
		else if (!(flags & REC_IGNORE))
			sfputc(sp, c);
	}
	if (flags & REC_TERMINATE)
		sfputc(sp, c);
	return(sfstruse(sp));
}

static void
putrec(register char* s)
{
	register int	n;
	register char*	t;

	if ((ed.print & PRINT_LIST) && (t = fmtesc(s))) {
		s = t;
		n = strlen(s);
		while (n > BREAK_LINE) {
			n -= BREAK_LINE;
			sfprintf(ed.msg, "%-*.*s\\\n", BREAK_LINE, BREAK_LINE, s);
			s += BREAK_LINE;
		}
		sfprintf(ed.msg, "%s$\n", s);
	}
	else
		sfputr(ed.msg, s, '\n');
}

static void
modify(void)
{
	if (!ed.evented) {
		ed.evented = ed.modified = 1;
		ed.event++;
		ed.undo.dot = ed.dot - ed.zero;
		ed.undo.dol = ed.dol - ed.zero;
		if (ed.marked) {
			register int	c;

			for (c = 0; c < elementsof(ed.marks); c++)
				ed.undo.marks[c] = ed.marks[c];
		}
	}
}

static void
undo(void)
{
	register Line_t*	a1;
	register Line_t*	a3;
	register unsigned long	event;
	int			c;
	off_t			t;
	unsigned long		n;

	c = 0;
	event = ed.event;
	a1 = ed.zero;
	a3 = ed.zero + ed.all;
	while (++a1 < a3)
		if (a1->event == event) {
			c = 1;
			t = a1->offset;
			a1->offset = a1->undo;
			a1->undo = t;
		}
	if (!c)
		error(2, "nothing to undo");
	if (ed.marked)
		for (c = 0; c < elementsof(ed.marks); c++) {
			t = ed.marks[c];
			ed.marks[c] = ed.undo.marks[c];
			ed.undo.marks[c] = t;
		}
	n = ed.dot - ed.zero;
	ed.dot = ed.zero + ed.undo.dot;
	ed.undo.dot = n;
	n = ed.dol - ed.zero;
	ed.dol = ed.zero + ed.undo.dol;
	ed.undo.dol = n;
}

static char*
lineget(off_t off)
{
	char*	s;

	off &= ~(LINE_GLOBAL|LINE_MARKED);
	if (sfseek(ed.tmp, off, SEEK_SET) != off)
		error(ERROR_SYSTEM|2, "temp file read seek error");
	if (!(s = sfgetr(ed.tmp, 0, 0)))
		error(ERROR_SYSTEM|2, "temp file read error");
	return(s);
}

static off_t
lineput(char* s)
{
	off_t	off;

	modify();
	off = ed.tmpoff;
	if (sfseek(ed.tmp, off, SEEK_SET) != off)
		error(ERROR_SYSTEM|2, "temp file write seek error");
	if (sfputr(ed.tmp, s, 0) < 0)
		error(ERROR_SYSTEM|2, "temp file write error");
	if ((ed.tmpoff = sfseek(ed.tmp, 0L, SEEK_CUR)) == (off_t)-1)
		error(ERROR_SYSTEM|2, "temp file tell error");
	return(off);
}

static void
replace(register Line_t* a1, char* s)
{
	register off_t	off;

	off = lineput(s);
	if (a1->offset & LINE_MARKED) {
		register off_t*	mp;

		a1->offset &= ~LINE_GLOBAL;
		off |= LINE_MARKED;
		for (mp = ed.marks; mp < &ed.marks[elementsof(ed.marks)]; mp++)
			if (*mp == a1->offset)
				*mp = off;
	}
	a1->event = ed.event;
	a1->undo = a1->offset;
	a1->offset = off;
}

static void
squeeze(int i)
{
	if (ed.addr1 < ed.zero + i)
		error(2, "at top of file");
	if (ed.addr2 > ed.dol)
		error(2, "at end of file");
	if (ed.addr1 > ed.addr2)
		error(2, "first address exceeds second");
}

static void
nonzero(void)
{
	squeeze(1);
}

static char*
getfile(void)
{
	register char*	s;
	register int	n;
	register int	m;

	if (!(s = sfgetr(ed.iop, '\n', 1))) {
		if (!(s = sfgetr(ed.iop, '\n', -1)))
			return(0);
		ed.warn_newline = 1;
	}
	n = sfslen();
	if ((m = strlen(s)) < n) {
		register char*	t;
		register char*	u;
		register char*	x;

		t = u = s + m;
		x = s + n;
		while (u < x)
			if (!(*t++ = *u++))
				t--;
		*t++ = 0;
		n = t - s;
		ed.warn_null += x - t;
	}
	ed.bytes += n;
	ed.lines++;
	return(s);
}

static char*
getline(void)
{
	register char*	s;

	if ((s = getrec(ed.buffer.line, '\n', REC_TEXT)) && s[0] == '.' && !s[1])
		s = 0;
	return(s);
}

static char*
getbreak(void)
{
	char*	s;

	if ((s = ed.linebreak) && (ed.linebreak = strchr(s, '\n')))
		*ed.linebreak++ = 0;
	return(s);
}

static char*
getcopy(void)
{
	if (ed.addr1 > ed.addr2)
		return(0);
	return(lineget((ed.addr1++)->offset));
}

static void
print(void)
{
	register Line_t* a1;

	nonzero();
	a1 = ed.addr1;
	do {
		if (ed.print & PRINT_NUMBER)
			sfprintf(ed.msg, "%d\t", a1 - ed.zero);
		putrec(lineget((a1++)->offset));
	} while (a1 <= ed.addr2);
	ed.dot = ed.addr2;
	ed.print = 0;
}

static int
getnum(void)
{
	register int c;
	register int r;

	r = 0;
	while ((c = getchr()) >= '0' && c <= '9')
		r = r * 10 + c - '0';
	ed.peekc = c;
	return(r);
}

static void
regfatal(int code)
{
	char	buf[128];

	if (code) {
		regerror(code, 0, buf, sizeof(buf));
		error(2, "%s", buf);
	}
}

static void
compile(int delimiter)
{
	register char*	s;
	int		c;

	s = getrec(ed.buffer.line, delimiter, 0);
	if (*s) {
		if (ed.compiled) {
			ed.compiled = 0;
			regfree(&ed.re);
		}
		if (c = regcomp(&ed.re, s, 0))
			regfatal(c);
		ed.compiled = 1;
	}
	else if (!ed.compiled)
		error(2, "no previous regular expression");
}

static int
execute(Line_t* addr)
{
	register char*	s;
	register int	c;

	trap();
	if (!addr)
		s = CUR();
	else if (addr == ed.zero)
		return(0);
	else
		s = lineget(addr->offset);
	if (c = regexec(&ed.re, s, elementsof(ed.match), ed.match, 0)) {
		if (c != REG_NOMATCH)
			regfatal(c);
		return(0);
	}
	SET(s);
	return(1);
}

static Line_t*
address(void)
{
	register int		c;
	register int		sign;
	register Line_t*	a;
	register Line_t*	b;
	int			opcnt;
	int			nextopand;

	nextopand = -1;
	sign = 1;
	opcnt = 0;
	a = ed.dot;
	do {
		do c = getchr(); while (isspace(c) && c != '\n');
		if (c >= '0' && c <= '9') {
			ed.peekc = c;
			if (!opcnt)
				a = ed.zero;
			a += sign * getnum();
		}
		else switch (c) {

		case '$':
			a = ed.dol;
			/*FALLTHROUGH*/
		case '.':
			if (opcnt)
				error(2, "invalid address");
			break;

		case '\'':
			if ((c = getchr()) == EOF || (c -= MARK_MIN) < 0 || c >= elementsof(ed.marks) || opcnt)
				error(2, "invalid mark");
			a = ed.marked && ed.marks[c] != LINE_NONE ? ed.zero : ed.dol;
			do {
				if (++a > ed.dol)
					error(2, "undefined mark referenced");
			} while (ed.marks[c] != (a->offset & ~LINE_GLOBAL));
			break;

		case '?':
			sign = -sign;
			/*FALLTHROUGH*/
		case '/':
			compile(c);
			b = a;
			for (;;) {
				a += sign;
				if (a <= ed.zero)
					a = ed.dol;
				if (a > ed.dol)
					a = ed.zero;
				if (execute(a))
					break;
				if (a == b)
					error(2, "pattern not found");
			}
			break;

		default:
			if (nextopand == opcnt) {
				a += sign;
				if (a < ed.zero || ed.dol < a)
					continue;       /* error? */
			}
			if (c != '+' && c != '-' && c != '^') {
				ed.peekc = c;
				if (!opcnt)
					a = 0;
				return(a);
			}
			sign = 1;
			if (c != '+')
				sign = -sign;
			nextopand = ++opcnt;
			continue;

		}
		sign = 1;
		opcnt++;
	} while (a >= ed.zero && a <= ed.dol);
	error(2, "address out of range");
	return(0);
}

static void
setwide(void)
{
	if (!ed.given) {
		ed.addr1 = ed.zero + (ed.dol > ed.zero);
		ed.addr2 = ed.dol;
	}
}

static void
setnoaddr(void)
{
	if (ed.given)
		error(2, "invalid address count");
}

static void
newline(void)
{
	register int	warned = 0;

	for (;;)
		switch (getchr()) {

		case EOF:
		case '\n':
			return;

		case 'l':
			ed.print = PRINT_LIST;
			continue;

		case 'n':
			ed.print = PRINT_NUMBER;
			continue;

		case 'p':
			ed.print = PRINT;
			continue;

		default:
			if (!warned) {
				warned = 1;
				error(2, "extra characters at end of command");
			}
			continue;
		}
}

static char*
plural(unsigned long count)
{
	return(count == 1 ? "" : "s");
}

static void
exfile(void)
{
	if (sfclose(ed.iop))
		error(ERROR_SYSTEM|1, "io error");
	ed.iop = 0;
	if (ed.verbose) {
		if (ed.help) {
			sfprintf(ed.msg, "\"%s\" %lu line%s, %lu character%s", error_info.file, ed.lines, plural(ed.lines), ed.bytes, plural(ed.bytes));
			if (ed.warn_null) {
				sfprintf(ed.msg, ", %lu null%s", ed.warn_null, plural(ed.warn_null));
				ed.warn_null = 0;
			}
			if (ed.warn_newline) {
				sfprintf(ed.msg, ", newline appended");
				ed.warn_newline = 0;
			}
			sfputc(ed.msg, '\n');
		}
		else
			sfprintf(ed.msg, "%d\n", ed.bytes);
	}
	if (ed.warn_null || ed.warn_newline) {
		char*	sep = "";

		sfstrset(ed.buffer.line, 0);
		if (ed.warn_null) {
			sfprintf(ed.buffer.line, "%d null character%s ignored", ed.warn_null, plural(ed.warn_null));
			ed.warn_null = 0;
			sep = ", ";
		}
		if (ed.warn_newline) {
			sfprintf(ed.buffer.line, "%snewline appended to last line", sep);
			ed.warn_newline = 0;
		}
		error(1, "%s", sfstruse(ed.buffer.line));
	}
	error_info.file = 0;
}

static void
putfile(void)
{
	register Line_t*	a1;
	register int		n;

	ed.bytes = 0;
	ed.lines = 0;
	a1 = ed.addr1;
	do {
		if ((n = sfputr(ed.iop, lineget((a1++)->offset), '\n')) < 0)
			error(ERROR_SYSTEM|2, "write error");
		ed.bytes += n;
		ed.lines++;
	} while (a1 <= ed.addr2);
	if (sfsync(ed.iop))
		error(ERROR_SYSTEM|2, "write error");
}

static void
quit(int code)
{
	if (ed.tmpfile) {
		remove(ed.tmpfile);
		ed.tmpfile = 0;
	}
	if (ed.verbose && ed.modified && ed.dol != ed.zero) {
		ed.modified = 0;
		error(2, "file changed but not written");
	}
	if (ed.caught == SIGQUIT) {
		signal(ed.caught, SIG_DFL);
		kill(0, ed.caught);
	}
	exit(code);
}

static void
handle(void)
{
	register int	c;
	char*		s;
	char*		b;
	mode_t		mask;

	if (ed.caught == SIGINT) {
		ed.caught = 0;
		ed.lastc = '\n';
		sfputc(ed.msg, '\n');
		error(2, "interrupt");
	}
	for (c = 0; c < elementsof(signals); c++)
		signal(signals[c], SIG_IGN);
	if (ed.dol > ed.zero) {
		ed.addr1 = ed.zero + 1;
		ed.addr2 = ed.dol;
		mask = umask(S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
		b = "ed.hup";
		if (!(ed.iop = sfopen(NiL, b, "w")) && (s = getenv("HOME"))) {
			sfstrset(ed.buffer.line, 0);
			sfprintf(ed.buffer.line, "%s/%s", s, b);
			b = sfstruse(ed.buffer.line);;
			ed.iop = sfopen(NiL, b, "w");
		}
		umask(mask);
		if (!ed.iop)
			error(ERROR_SYSTEM|1, "%s: cannot save changes", b);
		else {
			error_info.file = b;
			putfile();
		}
	}
	ed.modified = 0;
	quit(0);
}

static int
append(char* (*f)(void), Line_t* a)
{
	register char*		s;
	register Line_t*	a1;
	register Line_t*	a2;
	register Line_t*	a3;
	off_t			t;
	long			m;
	long			slide;

	slide = 0;
	ed.dot = a;
	while (s = (*f)()) {
		if ((ed.dol - ed.zero) + 1 >= ed.all) {
#if __sgi__ && !__GNUC__ /* sgi pointer arithmetic bug -- it's fun */
			long	dot = ed.dot - ed.zero;
			long	dol = ed.dol - ed.zero;
#endif
			a3 = ed.zero;
			ed.all += BLOCK_LINE;
			if (!(ed.zero = newof(ed.zero, Line_t, ed.all, 0))) {
				error(ERROR_SYSTEM|1, "no space [zero]");
				ed.caught = SIGHUP;
				trap();
			}
			m = ed.zero - a3;
			slide += m;
#if __sgi__ && !__GNUC__ /* sgi pointer arithmetic bug -- it's fun */
			ed.dot = ed.zero + dot;
			ed.dol = ed.zero + dol;
#else
			ed.dot += m;
			ed.dol += m;
#endif
		}
		t = lineput(s);
		slide++;
		a1 = ++ed.dol;
		a2 = a1 + 1;
		a3 = ++ed.dot;
		while (a1 > a3) {
			(--a2)->event = ed.event;
			a2->undo = a2->offset;
			a2->offset = (--a1)->offset;
		}
		a3->event = ed.event;
		a3->undo = a3->offset;
		a3->offset = t;
	}
	return(slide);
}

static void
add(int i)
{
	if (i && (ed.given || ed.dol > ed.zero)) {
		ed.addr1--;
		ed.addr2--;
	}
	squeeze(0);
	newline();
	append(getline, ed.addr2);
}

static void
page(void)
{
	register int	direction;
	register int	n;

	switch (direction = getchr()) {

	case '-':
	case '.':
	case '+':
		break;

	default:
		ed.peekc = direction;
		direction = '+';
		break;

	}
	if ((n = getnum()) > 0)
		ed.page.size = n;
	newline();
	if (ed.print)
		ed.page.print = ed.print;
	else
		ed.print = ed.page.print;
	switch (direction) {

	case '-':
		ed.addr1 = ed.addr2 - ed.page.size + 1;
		break;

	case '.':
		ed.addr2 += ed.page.size / 2;
		ed.addr1 = ed.addr2 - ed.page.size + 1;
		break;

	case '+':
		ed.addr1 = ed.addr2;
		ed.addr2 += ed.page.size - 1;
		break;

	}
	if (ed.addr1 <= ed.zero)
		ed.addr1 = ed.zero + 1;
	if (ed.addr2 > ed.dol)
		ed.addr2 = ed.dol;
	print();
}

static void
rdelete(register Line_t* a1, register Line_t* a2)
{
	register Line_t*	a3;

	modify();
	a3 = ed.dol;
	ed.dol -= ++a2 - a1;
	ed.dot = a1 > ed.dol ? ed.dol : a1;
	do {
		a1->undo = a1->offset;
		a1->event = ed.event;
		(a1++)->offset = (a2++)->offset;
	} while (a2 <= a3);
	while (a1 <= a3) {
		a1->undo = a1->offset;
		(a1++)->event = ed.event;
	}
}

static void
gdelete(void)
{
	register Line_t*	a1;
	register Line_t*	a2;
	register Line_t*	a3;

	a3 = ed.dol;
	for (a1 = ed.zero; !(a1->offset & LINE_GLOBAL); a1++)
		if (a1 >= a3)
			return;
	modify();
	for (a2 = a1 + 1; a2 <= a3;) {
		a1->event = ed.event;
		a1->undo = a1->offset;
		if (a2->offset & LINE_GLOBAL) {
			a2++;
			ed.dot = a1;
		}
		else
			(a1++)->offset = (a2++)->offset;
	}
	ed.dol = a1 - 1;
	if (ed.dot > ed.dol)
		ed.dot = ed.dol;
	while (a1 <= a3) {
		a1->undo = a1->offset;
		(a1++)->event = ed.event;
	}
}

static void
shell(void)
{
	register char*	s;
	register char*	f = 0;
	register int	c;

	if (ed.given)
		squeeze(ed.dol > ed.zero);
	s = getrec(ed.buffer.line, '\n', 0);
	if (s[0] == '!' && !s[1]) {
		if (!*sfstrbase(ed.buffer.shell))
			error(2, "no saved shell command");
		f = sfstrbase(ed.buffer.file);
	}
	else if (!s[0])
		error(2, "empty shell command");
	else
		swap(Sfio_t*, ed.buffer.shell, ed.buffer.line);
	s = sfstrbase(ed.buffer.shell);
	sfstrset(ed.buffer.line, 0);
	sfputc(ed.buffer.line, '!');
	while (c = *s++) {
		if (c == '\\') {
			if (*s != '%')
				sfputc(ed.buffer.line, c);
			sfputc(ed.buffer.line, *s++);
		}
		else if (c == '%')
			sfputr(ed.buffer.line, f = sfstrbase(ed.buffer.file), -1);
		else
			sfputc(ed.buffer.line, c);
	}
	if (ed.given) {
		if (!ed.tmpfile && !(ed.tmpfile = pathtemp(NiL, NiL, error_info.id)))
			error(ERROR_SYSTEM|2, "cannot generate temp file name");
		if (!(ed.iop = sfopen(NiL, ed.tmpfile, "w")))
			error(ERROR_SYSTEM|2, "%s: cannot create temp file", ed.tmpfile);
		error_info.file = ed.tmpfile;
		if (ed.dol > ed.zero)
			putfile();
		exfile();
		ed.bytes = 0;
		ed.lines = 0;
		sfprintf(ed.buffer.line, " < %s", ed.tmpfile);
		s = sfstruse(ed.buffer.line);
		if (!(ed.iop = sfpopen(NiL, s + 1, "r")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", s);
		error_info.file = s;
		rdelete(ed.addr1, ed.addr2);
		append(getfile, ed.dot);
		exfile();
		remove(ed.tmpfile);
	}
	else {
		s = sfstruse(ed.buffer.line) + 1;
		if (f)
			putrec(s);
		if (!(ed.iop = sfpopen(NiL, s, "")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", s);
		if (sfclose(ed.iop)) {
			ed.iop = 0;
			error(ERROR_SYSTEM|2, "%s: shell command exit error", s);
		}
		if (ed.verbose)
			putrec("!");
	}
}

static void
edit(void)
{
	register off_t*	mp;

	if (ed.tmp) {
		sfclose(ed.tmp);
		ed.tmp = 0;
	}
	ed.tmpoff = 0;
	if (!(ed.tmp = sftmp(BLOCK_TMP)))
		error(ERROR_SYSTEM|3, "cannot create temp file");
	for (mp = ed.marks; mp < &ed.marks[elementsof(ed.marks)]; )
		*mp++ = LINE_NONE;
	ed.marked = 0;
	ed.event++;
	ed.dot = ed.dol = ed.zero;
	if (!ed.initialized) {
		ed.initialized = 1;
		if (ed.pending)
			ed.caught = ed.pending;
	}
}

static void
filename(int c)
{
	register char*	p;
	register int	sh = 0;

	ed.bytes = 0;
	ed.lines = 0;
	p = getrec(ed.buffer.line, '\n', REC_LINE);
	if (*p) {
		if (!isspace(*p))
			error(2, "no space after command");
		for (p++; isspace(*p); p++)
			;
		if (!*p)
			error(2, "file name expected");
		if (c != 'f') {
			if (*p == '!') {
				p++;
				sh = 1;
			}
			else if (*p == '\\' && *(p + 1) == '!')
				p++;
		}
		if (!sh && (!*sfstrbase(ed.buffer.file) || c == 'e' || c == 'f')) {
			sfstrset(ed.buffer.file, 0);
			sfputr(ed.buffer.file, p, 0);
		}
		if (c == 'f')
			return;
	}
	else if (c == 'f')
		return;
	else if (!*(p = sfstrbase(ed.buffer.file)))
		error(2, "file name expected");
	if (c == 'e') {
		edit();
		ed.addr2 = ed.zero;
	}
	if (sh) {
		if (!(ed.iop = sfpopen(NiL, p, (c == 'e' || c == 'r') ? "r" : "w")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", p);
		p--;
	}
	else if (c == 'e' || c == 'r') {
		if (!(ed.iop = sfopen(NiL, p, "r")))
			error(ERROR_SYSTEM|2, "%s: cannot read", p);
	}
	else if ((c != 'W' || !(ed.iop = sfopen(NiL, p, "a"))) && !(ed.iop = sfopen(NiL, p, "w")))
		error(ERROR_SYSTEM|2, "%s: cannot write", p);
	error_info.file = p;
}

static void
global(int sense, int query)
{
	register char*		s;
	register int		c;
	register Line_t*	a1;

	if (ed.global)
		error(2, "recursive global not allowed");
	setwide();
	squeeze(ed.dol > ed.zero);
	if ((c = getchr()) == '\n')
		error(2, "incomplete global expression");
	compile(c);
	if (query)
		newline();
	else {
		s = getrec(ed.buffer.global, '\n', REC_SPLICE|REC_TERMINATE);
		if (s[0] == '\n' && !s[1])
			sfputr(ed.buffer.global, "p\n", 0);
	}
	for (a1 = ed.zero; a1 <= ed.dol; a1++) {
		a1->offset &= ~LINE_GLOBAL;
		if (a1 >= ed.addr1 && a1 <= ed.addr2 && execute(a1) == sense)
			a1->offset |= LINE_GLOBAL;
	}

	/* special case: g/.../d (avoid n^2 algorithm) */

	if (!query && s[0] == 'd' && s[1] == '\n' && !s[2])
		gdelete();
	else {
		for (a1 = ed.zero; a1 <= ed.dol; a1++) {
			if (a1->offset & LINE_GLOBAL) {
				a1->offset &= ~LINE_GLOBAL;
				ed.dot = a1;
				if (query) {
					putrec(lineget(a1->offset));
					if ((c = getchr()) == EOF)
						break;
					else if (c == '\n')
						continue;
					else if (c == '&') {
						newline();
						if (!*(ed.global = sfstrbase(ed.buffer.query)))
							error(2, "no saved command");
					}
					else {
						ed.peekc = c;
						ed.global = getrec(ed.buffer.query, '\n', REC_TERMINATE);
					}
				}
				else
					ed.global = s;
				commands();
				a1 = ed.zero;
			}
		}
	}
}

static void
join(void)
{
	register Line_t*	a1;

	nonzero();
	sfstrset(ed.buffer.work, 0);
	for (a1 = ed.addr1; a1 <= ed.addr2;)
		sfputr(ed.buffer.work, lineget((a1++)->offset), -1);
	a1 = ed.dot = ed.addr1;
	replace(a1, sfstruse(ed.buffer.work));
	if (a1 < ed.addr2)
		rdelete(a1 + 1, ed.addr2);
}

static int
compsub(void)
{
	register int	seof;
	register int	c;

	seof = getchr();
	if (isspace(seof))
		error(2, "invalid or missing delimiter");
	compile(seof);
	sfstruse(ed.buffer.substitute);
	for (;;) {
		c = getchr();
		if (c == '\\') {
			sfputc(ed.buffer.substitute, c);
			c = getchr();
		}
		else if (c == '\n' || c == EOF) {
			if (!ed.global || !ed.global[0]) {
				ed.peekc = c;
				ed.print |= PRINT;
				break;
			}
		}
		else if (c == seof)
			break;
		else if (c == '%' && !sfstrtell(ed.buffer.substitute) && ((ed.peekc = getchr()) == '\n' || ed.peekc == EOF || ed.peekc == seof)) {
			if (!*sfstrbase(ed.buffer.substitute))
				error(2, "no saved replacement string");
			sfstrset(ed.buffer.substitute, sfstrsize(ed.buffer.substitute) - 1);
			continue;
		}
		sfputc(ed.buffer.substitute, c);
	}
	sfputc(ed.buffer.substitute, 0);
	if ((ed.peekc = getchr()) == 'g') {
		ed.peekc = 0;
		newline();
		return(-1);
	}
	c = getnum();
	newline();
	return(c);
}

static void
dosub(void)
{
	register char*	s;
	register int	c;
	register int	n;

	sfstrset(ed.buffer.work, 0);
	if (n = BEG(0) - CUR())
		sfwrite(ed.buffer.work, CUR(), n);
	s = sfstrbase(ed.buffer.substitute);
	while (c = *s++) {
		if (c == '&') {
			if (n = END(0) - BEG(0))
				sfwrite(ed.buffer.work, BEG(0), n);
			continue;
		}
		if (c == '\\') {
			c = *s++;
			if (c >= MATCH_MIN && c <= MATCH_MAX) {
				c -= MATCH_MIN;
				if (HIT(c) && (n = END(c) - BEG(c)))
					sfwrite(ed.buffer.work, BEG(c), n);
				continue;
			}
		}
		sfputc(ed.buffer.work, c);
	}
	n = sfstrtell(ed.buffer.work);
	sfputr(ed.buffer.work, END(0), 0);
	swap(Sfio_t*, ed.buffer.work, ed.buffer.line);
	SET(sfstrbase(ed.buffer.line) + n);
}

static void
substitute(int inglob)
{
	register Line_t*	a1;
	register int		m;
	int			g;
	int			n;

	n = getnum();
	g = compsub();
	if (g > 0) {
		if (n)
			error(2, "only one substitute count expected");
		n = g;
		g = 0;
	}
	for (a1 = ed.addr1; a1 <= ed.addr2; a1++) {
		if (execute(a1)){
			m = n;
			do {
				int	span = END(0) - BEG(0);

				if (--m <= 0) {
					dosub();
					if (!g)
						break;
					if (!span) {
						if (!*END(0))
							break;
						NXT();
					}
				}
			} while (execute(NiL));
			if (m <= 0) {
				char*	s;
				char*	e;

				inglob = 1;
				s = sfstrbase(ed.buffer.line);
				if (e = strchr(s, '\n'))
					*e++ = 0;
				replace(a1, s);
				if (e) {
					ed.linebreak = e;
					m = append(getbreak, a1);
					a1 += m;
					ed.addr2 += m;
				}
			}
		}
	}
	if (!inglob)
		error(2, "global pattern not found");
}

static void
reverse(register Line_t* a1, register Line_t* a2)
{
	modify();
	while (--a2 > a1) {
		a1->event = a2->event = ed.event;
		a2->undo = a2->offset;
		a2->offset = a1->undo = a1->offset;
		(a1++)->offset = a2->undo;
	}
}

static void
move(int cflag)
{
	register Line_t*	adt;
	register Line_t*	ad1;
	register Line_t*	ad2;

	nonzero();
	if (!(adt = address()))
		error(2, "invalid move destination");
	newline();
	if (cflag) {
		unsigned long	m;

		ad1 = ed.dol;
		m = append(getcopy, ad1++);
		ad2 = ed.dol;
		ad1 += m;
		adt += m;
	}
	else {
		ad2 = ed.addr2;
		for (ad1 = ed.addr1; ad1 <= ad2; ad1++)
			ad1->offset &= ~LINE_GLOBAL;
		ad1 = ed.addr1;
	}
	ad2++;
	if (adt < ad1) {
		ed.dot = adt + (ad2 - ad1);
		if (++adt == ad1)
			return;
		reverse(adt, ad1);
		reverse(ad1, ad2);
		reverse(adt, ad2);
	}
	else if (adt >= ad2) {
		ed.dot = adt++;
		reverse(ad1, ad2);
		reverse(ad2, adt);
		reverse(ad1, adt);
	}
	else
		error(2, "move would do nothing");
}

static void
commands(void)
{
	register Line_t*	a1;
	register int		c;
	register int		n;
	char*			s;
	int			lastsep;

	for (;;) {
		trap();
		if (ed.print) {
			ed.addr1 = ed.addr2 = ed.dot;
			print();
		}
		if (!ed.global) {
			ed.evented = 0;
			if (ed.prompt > 0)
				sfputr(ed.msg, sfstrbase(ed.buffer.prompt), -1);
		}
		if ((c = getchr()) == ',' || c == ';') {
			ed.given = 1;
			ed.addr1 = (lastsep = c) == ',' ? ed.zero + 1 : ed.dot;
			a1 = ed.dol;
			c = getchr();
		}
		else {
			ed.addr1 = 0;
			ed.peekc = c;
			c = '\n';
			for (;;) {
				lastsep = c;
				a1 = address();
				c = getchr();
				if (c != ',' && c != ';')
					break;
				if (lastsep == ',')
					error(2, "invalid address");
				if (!a1) {
					a1 = ed.zero + 1;
					if (a1 > ed.dol)
						a1--;
				}
				ed.addr1 = a1;
				if (c == ';')
					ed.dot = a1;
			}
			if (lastsep != '\n' && !a1)
				a1 = ed.dol;
		}
		if (!(ed.addr2 = a1)) {
			ed.given = 0;
			ed.addr2 = ed.dot;	
		}
		else
			ed.given = 1;
		if (!ed.addr1)
			ed.addr1 = ed.addr2;
		switch (c) {

		case 'a':
			add(0);
			continue;

		case 'c':
			nonzero();
			newline();
			rdelete(ed.addr1, ed.addr2);
			append(getline, ed.addr1 - 1);
			continue;

		case 'd':
			nonzero();
			newline();
			rdelete(ed.addr1, ed.addr2);
			continue;

		case 'E':
			ed.modified = 0;
			c = 'e';
			/*FALLTHROUGH*/
		case 'e':
			setnoaddr();
			if (ed.verbose && ed.modified) {
				ed.modified = 0;
				error(2, "modified data not written");
			}
			/*FALLTHROUGH*/
		case 'r':
			filename(c);
			setwide();
			squeeze(0);
			c = ed.zero != ed.dol;
			append(getfile, ed.addr2);
			ed.modified = c;
			exfile();
			continue;

		case 'f':
			setnoaddr();
			filename(c);
			putrec(sfstrbase(ed.buffer.file));
			continue;

		case 'G':
			global(1, 1);
			continue;

		case 'g':
			global(1, 0);
			continue;

		case 'H':
			ed.help = !ed.help;
			/*FALLTHROUGH*/
		case 'h':
			setnoaddr();
			newline();
			if (ed.help || c == 'h')
				sfputr(ed.msg, sfstrbase(ed.buffer.help), '\n');
			continue;

		case 'i':
			add(-1);
			continue;

		case 'j':
			if (!ed.given)
				ed.addr2++;
			newline();
			join();
			continue;

		case 'k':
			nonzero();
			if ((c = getchr()) == EOF || (c -= MARK_MIN) < 0 || c >= elementsof(ed.marks))
				error(2, "invalid mark");
			newline();
			ed.addr2->offset |= LINE_MARKED;
			ed.marks[c] = ed.addr2->offset & ~LINE_GLOBAL;
			ed.marked = 1;
			continue;

		case 'm':
			move(0);
			continue;

		case 'n':
			ed.print |= PRINT_NUMBER;
			newline();
			print();
			continue;

		case '\n':
			if (!a1) {
				a1 = ed.dot + 1;
				ed.addr2 = a1;
				ed.addr1 = a1;
			}
			if (lastsep == ';')
				ed.addr1 = a1;
			print();
			continue;

		case 'l':
			ed.print |= PRINT_LIST;
			/*FALLTHROUGH*/
		case 'p':
			newline();
			print();
			continue;

		case 'P':
			setnoaddr();
			s = getrec(ed.buffer.line, '\n', 0);
			if (*s || !(ed.prompt = -ed.prompt) && (s = "*")) {
				sfstrset(ed.buffer.prompt, 0);
				sfputr(ed.buffer.prompt, s, 0);
				ed.prompt = 1;
			}
			continue;

		case 'Q':
			ed.modified = 0;
			/*FALLTHROUGH*/
		case 'q':
			setnoaddr();
			newline();
			quit(0);
			continue;

		case 'S':
			setnoaddr();
			newline();
			sfprintf(ed.msg, "file=\"%s\"%s%s%s prompt=\"%s\" tmp=%lu%s event=%lu version=%s\n", sfstrbase(ed.buffer.file), ed.modified ? " modified" : "", ed.help ? " help" : "", ed.verbose ? " verbose" : "", sfstrbase(ed.buffer.prompt), ed.tmpoff, ed.tmpoff > BLOCK_TMP ? "[file]" : "", ed.event, strrchr(id, ' ') + 1);
			continue;

		case 's':
			nonzero();
			substitute(ed.global != 0);
			continue;

		case 't':
			move(1);
			continue;

		case 'u':
			setnoaddr();
			newline();
			undo();
			continue;

		case 'V':
			global(0, 1);
			continue;

		case 'v':
			global(0, 0);
			continue;

		case 'W':
		case 'w':
			setwide();
			squeeze(ed.dol > ed.zero);
			if ((n = getchr()) != 'q' && n != 'Q') {
				ed.peekc = n;
				n = 0;
			}
			filename(c);
			if (ed.dol > ed.zero)
				putfile();
			exfile();
			if (n == 'Q' || ed.addr1 <= ed.zero + 1 && ed.addr2 == ed.dol)
				ed.modified = 0;
			if (n)
				quit(0);
			continue;

		case 'z':
			nonzero();
			page();
			continue;

		case '=':
			setwide();
			squeeze(0);
			newline();
			sfprintf(ed.msg, "%d\n", ed.addr2 - ed.zero);
			continue;

		case '!':
			shell();
			continue;

		case '#':
			setnoaddr();
			getrec(ed.buffer.line, '\n', REC_IGNORE);
			continue;

		case EOF:
			return;

		}
		error(2, "unknown command");
	}
}

int
main(int argc, char** argv)
{
	NoP(argc);
	error_info.id = "ed";
	error_info.write = helpwrite;
	init();
	for (;;)
	{
		for (;;) {
			switch (optget(argv, "hop:[prompt]qs [file]")) {

			case 'h':
				ed.help = 1;
				continue;

			case 'o':
				ed.msg = sfstderr;
				sfstrset(ed.buffer.file, 0);
				sfputr(ed.buffer.file, "/dev/stdout", 0);
				continue;

			case 'p':
				sfstrset(ed.buffer.prompt, 0);
				sfputr(ed.buffer.prompt, opt_info.arg, 0);
				ed.prompt = 1;
				continue;

			case 'q':
				signal(SIGQUIT, SIG_DFL);
				ed.verbose = 1;
				continue;

			case 's':
				ed.verbose = 0;
				continue;

			case 0:
				break;

			case '?':
				error(ERROR_USAGE|4, opt_info.arg);
				break;

			case ':':
				error(2, opt_info.arg);
				break;

			}
			break;
		}
		if (!*(argv += opt_info.index) || **argv != '-' || *(*argv + 1))
			break;
		ed.verbose = 0;
	}
	if (*argv) {
		if (*(argv + 1))
			error(ERROR_USAGE|4, opt_info.arg);
		sfprintf(ed.buffer.global, "e %s", *argv);
		ed.global = sfstruse(ed.buffer.global);
	}
	edit();
	sfslowio(sfstdin);
	setjmp(ed.again);
	commands();
	quit(0);
	exit(0);
}
#pragma prototyped

#include <ast.h>
#include <ctype.h>
#include <error.h>
#include <regex.h>

static const char id[] = "\n@(#)grep (AT&T Research) 01/01/96\0\n";

/*
 * snarfed from Doug McElroy's C++ version
 *
 * this grep is based on the Posix re package.
 * unfortunately it has to have a nonstandard interface.
 * 1. fgrep does not have usual operators. REG_LITERAL
 * caters for this.
 * 2. grep allows null expressions, hence REG_NULL.
 * 3. it may be possible to combine the multiple 
 * patterns of grep into single patterns.  important
 * special cases are handled by regcomb().
 * 4. anchoring by -x has to be done separately from
 * compilation (remember that fgrep has no ^ or $ operator),
 * hence REG_LEFT|REG_RIGHT.  (An honest, but slow alternative:
 * run regexec with REG_NOSUB off and nmatch=1 and check
 * whether the match is full length)
 */

typedef struct Item			/* list item			*/
{
	struct Item*	next;		/* next in list			*/
	union
	{
	regex_t		re;		/* re value - sue me for waste	*/
	char*		string;		/* string value			*/
	}		value;
} Item_t;

typedef struct				/* generic list			*/
{
	Item_t*		head;		/* list head			*/
	Item_t*		tail;		/* list tail			*/
} List_t;

static struct				/* program state		*/
{
	List_t		files;		/* pattern file list		*/
	List_t		patterns;	/* pattern list			*/
	List_t		res;		/* re list			*/

	int		code;		/* no hits exit code		*/
	int		hits;		/* if any patterns hit		*/
	int		options;	/* regex options		*/

	unsigned char	count;		/* count number of hits		*/
	unsigned char	list;		/* list files with hits		*/
	unsigned char	match;		/* match sense			*/
	unsigned char	query;		/* return status but no output	*/
	unsigned char	number;		/* line numbers			*/
	unsigned char	prefix;		/* print file prefix		*/
	unsigned char	suppress;	/* no unopenable file messages	*/
} state;

static void
fatal(int result)
{
	char	buf[128];

	if (result && result != REG_NOMATCH)
	{
		regerror(result, 0, buf, sizeof(buf));
		error(3, "%s", buf);
	}
}

static void
addre(List_t* p, char* s)
{
	int	result;
	Item_t*	x;

	if (!(x = newof(0, Item_t, 1, 0)))
		error(ERROR_SYSTEM|3, "out of space (pattern `%s')", s);
	if (result = regcomp(&x->value.re, s, state.options))
		fatal(result);
	if (!p->head)
		p->head = p->tail = x;
	else if (regcomb(&p->tail->value.re, &x->value.re))
		p->tail = p->tail->next = x;
	else free(x);
}

static void
addstring(List_t* p, char* s)
{
	Item_t*	x;

	if (!(x = newof(0, Item_t, 1, 0)))
		error(ERROR_SYSTEM|3, "out of space (string `%s')", s);
	x->value.string = s;
	if (p->head) p->tail->next = x;
	else p->head = x;
	p->tail = x;
}

/*
 * the update s = t+1 flagged below is formally illegal when
 * t==0, but what run-time system will catch it?
 */

static void
compile(void)
{
	int	i;
	int	line;
	char*	s;
	char*	t;
	char*	file;
	Item_t*	x;
	Sfio_t*	f;

	for (x = state.patterns.head; x; x = x->next)
		for (t = s = x->value.string; t; s = t + 1) /* see above */
		{
			if (t = strchr(s, '\n'))
				*t = 0;
			addre(&state.res, s);
		}	
	for (x = state.files.head; x; x = x->next)
	{
		s = x->value.string;
		if (f = sfopen(NiL, s, "r"))
		{
			file = error_info.file;
			error_info.file = s;
			line = error_info.line;
			error_info.line = 0;
			while (s = sfgetr(f, '\n', 1))
			{
				error_info.line++;
				addre(&state.res, s);
			}
			error_info.file = file;
			error_info.line = line;
			sfclose(f);
		}
		else if (!state.suppress)
			error(ERROR_SYSTEM|4, "%s: cannot open", s);
		else state.code = 2;
	}
	if (!(x = state.res.head))
		error(3, "no pattern#1");
}

static void
execute(Sfio_t* input, char* name)
{
	char*		s;
	char*		file;
	Item_t*		x;
	int		result;
	int		line;
	unsigned long	hits = 0;
	
	file = error_info.file;
	if (!(error_info.file = name))
		name = "(standard input)";
	line = error_info.line;
	error_info.line = 0;
	while (s = sfgetr(input, '\n', 1))
	{
		error_info.line++;
		for (x = state.res.head; x; x = x->next)
		{
			if (!(result = regexec(&x->value.re, s, 0, 0, 0)))
				break;
			if (result != REG_NOMATCH)
				fatal(result);
		}
		if ((x != 0) == state.match)
		{
			hits++;
			if (state.query || state.list)
				break;
			if (state.count)
				continue;
			if (state.prefix)
				sfprintf(sfstdout, "%s:", name);
			if (state.number)
				sfprintf(sfstdout, "%d:", error_info.line);
			sfprintf(sfstdout, "%s\n", s);
		}
	}
	error_info.file = file;
	error_info.line = line;
	if (hits)
	{
		state.hits = 1;
		if (state.query)
			return;
		if (state.list)
			sfprintf(sfstdout, "%s\n", name);
	}
	if (!state.list && state.count)
	{
		if (state.prefix)
			sfprintf(sfstdout, "%s:", name);
		sfprintf(sfstdout, "%d\n", hits);
	}
}

main(int argc, char** argv)
{
	int	c;
	char*	s;
	Sfio_t*	f;

	state.match = 1;
	state.options = REG_NOSUB|REG_NULL;
	state.code = 1;
	if (s = strrchr(argv[0], '/')) s++;
	else s = argv[0];
	switch (*s)
	{
	case 'a':
	case 'A':
		s = "agrep";
		state.options |= REG_AUGMENTED;
		break;
	case 'e':
	case 'E':
		s = "egrep";
		state.options |= REG_EXTENDED;
		break;
	case 'f':
	case 'F':
		s = "fgrep";
		state.options |= REG_LITERAL;
		break;
	default:
		s = "grep";
		break;
	}
	error_info.id = s;
	while (c = optget(argv, "AEFchilqnsvxe:[pattern]f:[file] [file ...]"))
		switch (c)
		{
		case 'A':
			state.options |= REG_AUGMENTED;
			break;
		case 'E':
			state.options |= REG_EXTENDED;
			break;
		case 'F':
			state.options |= REG_LITERAL;
			break;
		case 'c':
			state.count = 1;
			break;
		case 'e':
			addstring(&state.patterns, opt_info.arg);
			break;
		case 'f':
			addstring(&state.files, opt_info.arg);
			break;
		case 'h':
			state.prefix = 0;
			break;
		case 'i':
			state.options |= REG_ICASE;
			break;
		case 'l':
			state.list = 1;
			break;
		case 'n':
			state.number = 1;
			break;
		case 'q':
			state.query = 1;
			break;
		case 's':
			state.suppress = 1;
			break;
		case 'v':
			state.match = 0;
			break;
		case 'x':
			state.options |= REG_LEFT|REG_RIGHT;
			break;
		case '?':
			error(ERROR_USAGE|4, opt_info.arg);
			break;
		case ':':
			error(2, opt_info.arg);
			break;
		}
	argv += opt_info.index;
	if ((state.options & (REG_AUGMENTED|REG_LITERAL)) == (REG_AUGMENTED|REG_LITERAL))
		error(3, "-A and -F are incompatible");
	if ((state.options & (REG_EXTENDED|REG_LITERAL)) == (REG_EXTENDED|REG_LITERAL))
		error(3, "-E and -F are incompatible");
	if (!state.files.head && !state.patterns.head)
	{
		if (!argv[0])
			error(3, "no pattern");
		addstring(&state.patterns, *argv++);
	}
	compile();
	if (!argv[0])
		execute(sfstdin, NiL);
	else
	{
		if (!state.prefix && argv[1])
			state.prefix = 1;
		while (s = *argv++)
		{
			if (f = sfopen(NiL, s, "r"))
			{
				execute(f, s);
				sfclose(f);
			}
			else if (!state.suppress)
				error(ERROR_SYSTEM|4, "%s: cannot open", s);
			else state.code = 2;
			if (state.query && state.hits)
				break;
		}
	}
	exit(state.hits ? 0 : state.code);
}
#pragma prototyped

#include <ast.h>
#include <error.h>

#include "regex.h"

typedef unsigned char uchar;

typedef struct {
	uchar *w;		/* write pointer */
	uchar *e;		/* end */
	uchar *s;		/* start */
} Text;

extern void compile(Text *script, Text *raw);
extern void execute(Text *script, Text *input);
extern int recomp(Text *script, Text *t, int seof);
extern int match(uchar *re, Text *data, int gflag);
extern int substitute(regex_t*, Text* data, uchar *rhs, int gf);
extern regex_t *readdr(int addr);
extern void tcopy(Text *from, Text *to);
void printscript(Text *script);
extern void vacate(Text*);
extern void synwarn(char*);
extern void syntax(char*);
extern int readline(Text*);
extern int ateof(void);
extern void coda(void);

#define exch(a, b, t) ((t)=(a), (a)=(b), (b)=(t))
	
	/* space management; assure room for n more chars in Text */
#define assure(/*Text*/t, /*int*/ n) 		\
	do if((t)->s==0 || (t)->w>=(t)->e-n-1) grow(t, n);while(0)
extern void grow(Text*, int);

	/* round character pointer up to integer pointer.
	   portable to the cray; simpler tricks are not */

#define intp(/*uchar**/p) (int*)(p + sizeof(int) - 1 \
			- (p+sizeof(int)-1 - (uchar*)0)%sizeof(int))

extern int reflags;
extern int recno;
extern int nflag;
extern int qflag;
extern int sflag;
extern int bflag;
extern char *stdouterr;

extern Text files;

/* SCRIPT LAYOUT

   script commands are packed thus:
   0,1,or2 address words signed + for numbers - for regexp
   if 2 addresses, then another word indicates activity
	positive: active, the record number where activated
	negative: inactive, sign or-ed with number where deactivated
   instruction word
	high byte IMASK+flags; flags are NEG and SEL
	next byte command code (a letter)
	next two bytes, length of this command, including addrs
        (length is a multiple of 4; capacity could be expanded
	by counting the length in words instead of bytes)
   after instruction word
	on s command
		offset of regexp in rebuf
		word containing flags p,w plus n (g = >n=0)
		replacement text
		word containing file designator, if flag w
	on y command
		256-byte transliteration table
	on b and t command
		offset of label in script
*/

#define BYTE		CHAR_BIT
#define IMASK		0xC0000000	/* instruction flag */
#define NEG  		0x01000000	/* instruction written with ! */
#define LMASK		0xffff		/* low half word */
#define AMASK		0x7fffffff	/* address mask, clear sign bit */
#define INACT		(~AMASK)	/* inactive bit, the sign bit */
#define DOLLAR		AMASK		/* huge address */
#define REGADR		(~AMASK)	/* context address */
#define PFLAG		0x80000000	/* s/../../p */
#define WFLAG		0x40000000	/* s/../../g */

extern int pack(int neg, int cmd, int length);
extern int *instr(uchar*);
#define code(/*int*/ inst) ((inst)>>2*BYTE & 0xff)
#define nexti(/*uchar**/ p) ((p) + (*instr(p)&LMASK))
#pragma prototyped

#include "sed.h"

static const char id[] = "\n@(#)sed (AT&T Research) 01/01/96\0\n";

void	readscript(Text*, char*);
void	copyscript(Text*, uchar*);
void	initinput(int, char **);
Sfio_t*	aopen(char*);

#define ustrncmp(a,b,c) (uchar*)strncmp((char*)(a), (char*)(b), c)

int reflags;		/* regcomp() flags */
int recno;		/* current record number */
int nflag;		/* nonprint option */
int qflag;		/* command q executed */
int sflag;		/* substitution has occurred */
int bflag;		/* strip leading blanks from c,a,i <text> */

main(int argc, char **argv)
{
	int c;
	static Text script;
	static Text data;
	error_info.id = "sed";
	while (c = optget(argv, "bdne:[expression]f:[script]AE [file ...]"))
		switch (c)
		{
		case 'A':
			reflags |= REG_AUGMENTED;
			break;
		case 'E':
			reflags |= REG_EXTENDED;
			break;
		case 'b':
			bflag++;
			break;
		case 'e':
			copyscript(&data, (uchar*)opt_info.arg);
			break;
		case 'f':
			readscript(&data, opt_info.arg);
			break;
		case 'n':
			nflag++;
			break;
		case '?':
			error(ERROR_USAGE|4, opt_info.arg);
			break;
		case ':':
			error(2, opt_info.arg);
			break;
		}
	if (error_info.errors)
		error(ERROR_USAGE|4, optusage(NiL));
	argv += opt_info.index;
	argc -= opt_info.index;
	if(data.s == 0) {
		if(!*argv)
			error(3, "no script");
		copyscript(&data, (uchar*)*argv++);
		argc--;
	}
	if(ustrncmp(data.s, "#n", 2) == 0)
		nflag = 1;
	copyscript(&data, (uchar*)"\n\n");  /* e.g. s/a/\ */
	compile(&script, &data);
#if DEBUG
	printscript(&script);
#endif

	initinput(argc, argv);
	for(;;) {
		data.w = data.s;
		if(!readline(&data))
			break;
		execute(&script, &data);
	}
	if(sfclose(sfstdout) == EOF)
		error(3, stdouterr);
	return 0;
}

void
grow(Text *t, int n)
{
	int w = t->w - t->s;
	int e = t->e - t->s + (n/SF_BUFSIZE+1)*SF_BUFSIZE;
	t->s = (uchar*)realloc(t->s, e);
	if(t->s == 0)
		error(3, "out of space");
	t->w = t->s + w;
	t->e = t->s + e;
}

/* BUG: a segment that ends with a comment whose
   last character is \ causes a diagnostic */

void
safescript(Text *t)
{
	if(t->w > t->s+1 && t->w[-2] == '\\')
		error(1, "script segment ends with \\");
}

void
readscript(Text *t, char *s)
{
	int n;
	Sfio_t *f = aopen(s);
	for(;;) {
		assure(t, 4);
		n = sfread(f, t->w, t->e - t->w - 3);
		if(n <= 0)
			break;
		t->w += n;
	}
	sfclose(f);
	if(t->w > t->s && t->w[-1] != '\n') {
		*t->w++ = '\n';
		error(1, "newline appended to script segment");
	}
	*t->w = 0;
	safescript(t);
}

void
copyscript(Text *t, uchar *s)
{
	do {
		assure(t, 2);
	} while(*t->w++ = *s++);
	if(--t->w > t->s && t->w[-1] != '\n') {
		*t->w++ = '\n';
		*t->w = 0;
	}
	safescript(t);
}

/* DATA INPUT */

struct {
	int iargc;		/* # of files not fully read */
	char **iargv;		/* current file */
	Sfio_t *ifile;		/* current input file */
} input;

int
readline(Text *t)
{
	char*	s;
	int	c;

	coda();
	if (qflag || ateof())
		return 0;
	while (!(s = sfgetr(input.ifile, '\n', 1)))
	{
		if (s = sfgetr(input.ifile, '\n', -1))
		{
			error(1, "newline appended");
			break;
		}
		error_info.file = 0;
		error_info.line = 0;
		if (--input.iargc <= 0)
			return 0;
		sfclose(input.ifile);
		input.ifile = aopen(*++input.iargv);
		error_info.file = *input.iargv;
	}
	c = sfslen();
	assure(t, c);
	memcpy(t->w, s, c);
	t->w += c - 1;

	/*
	 * peek ahead to identify line $
	 */

	if ((c = sfgetc(input.ifile)) != EOF)
		sfungetc(input.ifile, c);
	else if (input.iargc == 1)
		input.iargc = 0;
	error_info.line++;
	recno++;
	sflag = 0;
	return 1;
}	

int 
ateof(void)
{
	return input.iargc <= 0;
}	

void
initinput(int argc, char **argv)
{
	input.iargc = argc;
	input.iargv = argv;
	if(input.iargc == 0) {
		input.iargc = 1;	/* for ateof() */
		input.ifile = sfstdin;
	} else {
		input.ifile = aopen(*input.iargv);
		error_info.file = *input.iargv;
	}
}

Sfio_t *
aopen(char *s)
{
	Sfio_t *f = sfopen(NiL, s, "r");
	if(f == 0)
		error(ERROR_SYSTEM|3, "%s: cannot open", s);
	return f;
}

#if DEBUG & 1

/* debugging code 1; compile and execute stubs.
   simply prints the already collected script and
   prints numbered input lines */

void
compile(Text *script, Text *t)
{
	uchar *s = t->s;
	assure(script, 1);
	*script->w++ = 0;
	while(*s) sfputc(sfstdout, *s++);
}

void
execute(Text *x, Text *y)
{
	x = x;		
	sfprintf(sfstdout, "%d: %s", recno, y->s);
}

#endif
#pragma prototyped

#include "sed.h"

#include <ctype.h>

#define ustrlen(p) strlen((char*)(p))
#define ustrcmp(p, q) strcmp((char*)(p), (char*)(q))
#define ustrcpy(p, q) (uchar*)strcpy((char*)(p), (char*)(q))
#define ustrchr(p, c) (uchar*)strchr((char*)(p), c)

int blank(Text*);
void fixlabels(Text*);
void fixbrack(Text*);
void ckludge(Text*, int, int, int, Text*);
int addr(Text*, Text*);
int pack(int, int, int);
int* instr(uchar*);
uchar *succi(uchar*);

#if DEBUG
extern void regdump(regex_t*);	/* secret entry into regex pkg */
#endif

int semicolon;
Text rebuf;

uchar adrs[256] = {	/* max no. of addrs, 3 is illegal */
	0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, /* <nl> */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 2, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* !# */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 1, 3, 3, /* := */
	3, 3, 3, 3, 2, 3, 3, 2, 2, 3, 3, 3, 3, 3, 2, 3, /* DGHN */
	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* P */
	3, 1, 2, 2, 2, 3, 3, 2, 2, 1, 3, 3, 2, 3, 2, 3, /* a-n */
	2, 1, 2, 2, 2, 3, 3, 2, 2, 2, 3, 2, 3, 0, 3, 3, /* p-y{} */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
};

#define Ec Tc	/* commands that have same compilation method */
#define Dc Tc
#define Gc Tc
#define Hc Tc
#define Nc Tc
#define Pc Tc
#define dc Tc
#define gc Tc
#define hc Tc
#define lc Tc
#define nc Tc
#define pc Tc
#define qc Tc
#define xc Tc
#define tc bc
#define ic ac
#define cc ac

uchar *synl;	/* current line pointer for syntax errors */

/* COMMAND LAYOUT */

int
blank(Text *t)
{
	if(*t->w==' ' || *t->w=='\t') {
		t->w++;
		return 1;
	} else
		return 0;
}

int *
instr(uchar *p)		/* get address of command word */
{
	int *q = (int*)p;
	while((*q & IMASK) != IMASK)
		q++;
	return q;
}

uchar *
succi(uchar *p)
{
	int *q = instr(p);
	if(code(*q) == '{')
		return (uchar*)(q+1);
	else
		return p + (*q & LMASK);
}

int
pack(int neg, int cmd, int length)
{
	int l = length & LMASK;
	if(length != l)
		syntax("<command-list> or <text> too long");
	return IMASK | neg | cmd << 2*BYTE | l;
}

void
putint(Text *s, int n)
{
	assure(s, sizeof(int));
	*(int*)s->w = n;
	s->w += sizeof(int);
}

int
number(Text *t)
{
	unsigned n = 0;
	while(isdigit(*t->w)) {
		if(n > (INT_MAX-9)/10)
			syntax("number too big");
		n = n*10 + *t->w++ - '0';
	}
	return n;
}	

int
addr(Text *script, Text *t)
{
	int n;
	switch(*t->w) {
	default:
		return 0;
	case '$':
		t->w++;
		n = DOLLAR;
		break;
	case '\\':
		t->w++;
		if(*t->w=='\n' ||*t->w=='\\')
			syntax("bad regexp delimiter");
	case '/':
		n = recomp(&rebuf, t, *t->w++) | REGADR;
		break;
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		n = number(t);
		if(n == 0)
			syntax("address is zero");
	}
	putint(script, n);
	return 1;
}

regex_t *
readdr(int x)
{
	return (regex_t*)(rebuf.s + (x&AMASK));
}

/* LABEL HANDLING */

/* the labels array consists of int values followed by strings.
   value -1 means unassigned; other values are relative to the
   beginning of the script 

   on the first pass, every script ref to a label becomes the
   integer offset of that label in the labels array, or -1 if
   it is a branch to the end of script

   on the second pass (fixlabels), the script ref is replaced
   by the value from the labels array. */

Text labels;

int *
lablook(uchar *l, Text *labels)
{
	uchar *p, *q;
	int n;
	assure(labels, 1);
	for(p = labels->s; p < labels->w; ) {
		q = p + sizeof(int);
		if(ustrcmp(q, l) == 0)
			return (int*)p;
		q += ustrlen(q) + 1;
		p = (uchar*)intp(q);
	}
	n = ustrlen(l);
	assure(labels, sizeof(int)+n+1+sizeof(int));
	*(int*)p = -1;
	q = p + sizeof(int);
	ustrcpy(q, l);
	q += ustrlen(q) + 1;
	labels->w = (uchar*)intp(q);
	return (int*)p;
}

/* find pos in label list; assign value i to label if i>=0 */

int
getlab(Text *t, int i)
{
	int *p;
	uchar *u;
	while(blank(t));	/* not exactly posix */
	for(u=t->w; *t->w!='\n'; t->w++)
		if(!isprint(*t->w) || *t->w==' ')
			synwarn("invisible character in name");
	if(u == t->w)
		return -1;
	*t->w = 0;
	p = lablook(u, &labels);
	if(*p == -1)
		*p = i;
	else if(i != -1)
		syntax("duplicate label");
	*t->w = '\n';
	return (uchar*)p - labels.s;
}

void
Cc(Text *script, Text *t)	/* colon */
{
	if(getlab(t, script->w - sizeof(int) - script->s) == -1)
		syntax("missing label");
}

void
bc(Text *script, Text *t)
{
	int g;
	g = getlab(t, -1);	/* relative pointer to label list */
	putint(script, g);
}
			
void
fixlabels(Text *script)
{
	uchar *p;
	int *q;
	for(p=script->s; p<script->w; p=succi(p)) {
		q = instr(p);
		switch(code(*q)) {
		case 't':
		case 'b':
			if(q[1] == -1)
				q[1] = script->w - script->s;
			else if(*(int*)(labels.s+q[1]) != -1)
				q[1] = *(int*)(labels.s+q[1]);
			else
				error(3, "undefined label: %s",
					labels.s+q[1]+sizeof(int));
		}
	}
	free(labels.s);
}

/* FILES */

Text files;

void
rc(Text *script, Text *t)
{
	uchar *u;
	if(!blank(t))
		synwarn("no space before file name");
	while(blank(t)) ;
	for(u=t->w; *t->w!='\n'; t->w++) ;
	if(u == t->w)
		syntax("missing file name");
	*t->w = 0;
	putint(script, (uchar*)lablook(u, &files) - files.s);
	*t->w = '\n';
}

void
wc(Text *script, Text *t)
{
	int *p;
	rc(script, t);
	p = (int*)(files.s + ((int*)script->w)[-1]);
	if(*p != -1)
		return;
	*(Sfio_t**)p = sfopen(NiL, (char*)(p+1), "w");
	if(*p == 0)
		syntax("can't open file for writing");
}

/* BRACKETS */

Text brack;

/* Lc() stacks (in brack) the location of the { command word.
   Rc() stuffs into that word the offset of the } sequel
   relative to the command word.
   fixbrack() modifies the offset to be relative to the
   beginning of the instruction, including addresses. */

void				/* { */
Lc(Text *script, Text *t)
{
	while(blank(t));
	putint(&brack, script->w - sizeof(int) - script->s);
}

void				/* } */
Rc(Text *script, Text *t)
{
	int l;
	int *p;
	t = t;
	if(brack.w == 0 || (brack.w-=sizeof(int)) < brack.s)
		syntax("unmatched }");
	l = *(int*)brack.w;
	p = (int*)(script->s + l);
	l = script->w - script->s - l;
	if(l >= LMASK - 3*sizeof(int))	/* fixbrack could add 3 */
		syntax("{command-list} too long)");
	*p = (*p&~LMASK) | l;
}

void
fixbrack(Text *script)
{
	uchar *p;
	int *q;
	if(brack.w == 0)
		return;
	if(brack.w > brack.s)
		syntax("unmatched {");
	for(p=script->s; p<script->w; p=succi(p)) {
		q = instr(p);
		if(code(*q) == '{')
			*q += (uchar*)q - p;
	}
	free(brack.s);
}

/* EASY COMMANDS */

void
Xc(Text *script, Text *t)	/* # */
{
	script = script;	/* avoid use/set diagnostics */
	if(t->s[1]=='n')
		nflag = 1;
	while(*t->w != '\n')
		t->w++;
}

void
Ic(Text *script, Text *t)	/* ignore */
{
	script = script;
	t->w--;
}

void
Tc(Text *script, Text *t)	/* trivial to compile */
{
	script = script;
	t = t;
}

void
xx(Text *script, Text *t)
{
	script = script;
	t = t;
	syntax("unknown command");
}

/* MISCELLANY */

void
ac(Text *script, Text *t)
{
	if(*t->w++ != '\\' || *t->w++ != '\n')
		syntax("\\<newline> missing after command");
	for(;;) {
		while(bflag && blank(t)) ;
		assure(script, 2 + sizeof(int));
		switch(*t->w) {
		case 0:
			error(ERROR_PANIC|4, "bug: missed end of <text>");
		case '\n':
			*script->w++ = *t->w;
			*script->w++ = 0;
			script->w = (uchar*)intp(script->w);
			return;
		case '\\':
			t->w++;
		default:
			*script->w++ = *t->w++;
		}
	}
}
void
yc(Text *script, Text *t)
{
	int i;
	int delim = *t->w++;
	uchar *s = script->w;
	uchar *p, *q;
	if(delim == '\n' || delim=='\\')
		syntax("missing delimiter");
	assure(script, 256);
	for(i=0; i<256; i++) 
		s[i] = 0;
	for(q=t->w; *q!=delim; q++)
		if(*q == '\n')
			syntax("missing delimiter");
		else if(*q=='\\' && q[1]==delim)
			q++;
	for(p=t->w, q++; *p != delim; p++, q++) {
		if(*p=='\\' && p[1]==delim)
			p++;
		if(*q == '\n')
			syntax("missing delimiter");
		if(*q == delim)
			syntax("string lengths differ");
		if(*q=='\\' && q[1]==delim)
			q++;
		if(s[*p] && s[*p]!=*q)
			syntax("ambiguous map");
		if(s[*p])
			synwarn("redundant map");
		s[*p] = *q;
	}
	if(*q++ != delim)
		syntax("string lengths differ");
	for(i=0; i<256; i++)
		if(s[i] == 0)
			s[i] = i;
	t->w = q;
	script->w += 256;
}

void
sc(Text *script, Text *t)
{
	int c, flags, re, nsub;
	int *q;
	int n = -1;
	int delim = *t->w++;
	switch(delim) {
	case '\n':
	case '\\':
		syntax("improper delimiter");
	}
	re = recomp(&rebuf, t, delim);
	putint(script, re);
	nsub = readdr(re)->re_nsub;
	flags = script->w - script->s;
	putint(script, 0);		/* space for flags */
	while((c=*t->w++) != delim) {
		assure(script, 3+sizeof(int*));
		if(c == '\n')
			syntax("unterminated command");
		else if(c == '\\') {
			int d = *t->w++;
			if(d==delim)
				;
			else if(d=='&' || d=='\\')
				*script->w++ = c;
			else if(d>='0' && d<='9') {
				if(d > '0'+nsub)
					syntax("improper backreference");
				*script->w++ = c;
			}
			c = d;
		}
		*script->w++ = c;
	}
	*script->w++ = 0;
	script->w = (uchar*)intp(script->w);
	q = (int*)(script->s + flags);
	*q = 0;
	for(;;) {
		switch(*t->w) {
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			if(n != -1)
				syntax("extra flags");
			n = number(t);
			if(n == 0 || (n&(PFLAG|WFLAG)) != 0)
				syntax("count out of range");
			continue;
		case 'p':
			if(*q & PFLAG)
				syntax("extra flags");
			t->w++;
			*q |= PFLAG;
			continue;
		case 'g':
			t->w++;
			if(n != -1)
				syntax("extra flags");
			n = 0;
			continue;
		case 'w':
			t->w++;
			*q |= WFLAG;	 
			wc(script, t);
		}
		break;
	}
	*q |= n==-1? 1: n;
}		

void
synwarn(char *s)
{
	uchar *t = ustrchr(synl, '\n');
	error(1, "%s: %.*s", s, t-synl, synl);
}

void
syntax(char *s)
{
	uchar *t = ustrchr(synl, '\n');
	error(3, "%s: %.*s", s, t-synl, synl);
}

#if DEBUG

void
printscript(Text *script)
{
	uchar *s;
	int *q;
	for(s=script->s; s<script->w; s = succi(s)) {
		q = (int*)s;
		if((*q&IMASK) != IMASK) {
			if((*q&REGADR) == 0)
				printf("%d", *q);
			else
				regdump((regex_t*)(*q & AMASK));
			q++;
		}
		if((*q&IMASK) != IMASK) {
			if((*q&REGADR) == 0)
				printf(",%d", *q);
			else
				regdump((regex_t*)(*q & AMASK));
			q += 2;
		}
		if(code(*q) == '\n')
			continue;
		printf("%s%c\n", *q&NEG?"!":"", code(*q));
	}	
}

#endif

#if DEBUG & 2

/* debugging code 2; execute stub.
   prints the compiled script (without arguments)
   then each input line with line numbers */

void
execute(Text *script, Text *y)
{
	if(recno == 1)
		printscript(script);
	printf("%d:%s",recno,y->s);
}

#endif

typedef void (*cmdf)(Text*, Text*);

static cmdf docom[128] = {
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,Ic,xx,xx,xx,xx,xx, /* <nl> */
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,
	xx,Ic,xx,Xc,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx, /* !# */
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,Cc,Ic,xx,Ec,xx,xx, /* :;= */
	xx,xx,xx,xx,Dc,xx,xx,Gc,Hc,xx,xx,xx,xx,xx,Nc,xx, /* DGHN */
	Pc,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx, /* P */
	xx,ac,bc,cc,dc,xx,xx,gc,hc,ic,xx,xx,lc,xx,nc,xx, /* a-n */
	pc,qc,rc,sc,tc,xx,xx,wc,xc,yc,xx,Lc,xx,Rc,xx,xx  /* p-y{} */
};


void
compile(Text *script, Text *t)
{
	int loc;	/* progam counter */
	int neg;	/* ! in effect */
	int cmd;
	int naddr;
	int *q;		/* address of instruction word */
	t->w = t->s;	/* here w is a read pointer */
	while(*t->w) {
		assure(script, 4*sizeof(int));
		loc = script->w - script->s;
		synl = t->w;
		naddr = 0;
		while(blank(t)) ;
		naddr += addr(script, t);
		if(naddr && *t->w ==',') {
			t->w++;
			naddr += addr(script, t);
			if(naddr < 2)
				syntax("missing address");
		}
		q = (int*)script->w;
		if(naddr == 2)
			*q++ = INACT;
		script->w = (uchar*)(q+1);
		neg = 0;
		for(;;) {
			while(blank(t));
			cmd = *t->w++;
			if(neg && docom[cmd&0xff]==Ic)
				syntax("improper !");
			if(cmd != '!')
				break;
			neg = NEG;
		}
		if(!neg) {
			switch(adrs[cmd]) {
			case 1:
				if(naddr <= 1)
					break;
			case 0:
				if(naddr == 0)
					break;
				syntax("too many addresses");
			}
		}
		(*docom[cmd&0xff])(script, t);
		switch(*t->w) {
		case 0:
			script->w = script->s + loc;
			break;
		default:
			if(cmd == '{')
				break;
			syntax("junk after command");
		case ';':
			if(!semicolon++)
				synwarn("semicolon separators");
		case '\n':
				t->w++;
		}
		*q = pack(neg,cmd,script->w-script->s-loc);
	}
	fixbrack(script);
	fixlabels(script);
}
#pragma prototyped

#include "sed.h"

#include <ctype.h>

#define ustrchr(p, c) (uchar*)strchr((char*)(p), c)

int selected(uchar*, Text*);

#define Re Ie
#define Ce Ie
#define Se Ie
#define re ae

#define IBUG "interpreter bug %d"
char *stdouterr = "writing standard output";

Text hold;

void
cputchar(int c)
{
	if(sfputc(sfstdout, c) == EOF)
		error(3, stdouterr);
}

void
writeline(Text *data)
{
	int n = data->w - data->s;
	if(sfwrite(sfstdout, data->s, n) != n)
		error(ERROR_SYSTEM|3, stdouterr);
	cputchar('\n');
}

/* return 1 if action is to be taken on current line,
         -1 if (numeric) address has been passed,
	  0 otherwise*/
int
sel1(int addr, Text *data)
{
	if(addr & REGADR)
		return regexec(readdr(addr),(char*)data->s,0,0,0) == 0;
	if(addr == recno)
		return 1;
	if(addr == DOLLAR)
		return ateof();
	if(addr < recno)
		return -1;
	return 0;
}

/* return 2 on non-final line of a selected range,
          1 on any other selected line,
	  0 on non-selected lines 
   (the 1-2 distinction matters only for 'c' commands) */

int
selected(uchar *pc, Text *data)
{
	int active;
	int *ipc = (int*)pc;	/* points to address words */
	int *q = instr(pc);	/* points to instruction word */
	int neg = !!(*q & NEG);
	switch(q - ipc)	{
	case 0:			/* 0 address */
		return !neg;
	case 1:			/* 1 address */
		return neg ^ sel1(ipc[0], data)==1;
	case 2:
		error(ERROR_PANIC|4, IBUG,1);
	case 3:			/* 2 address */
		q--;		/* points to activity indicator */
		active = !(*q & INACT);
		if((*q&AMASK) < recno) {
			switch(sel1(ipc[active], data)) {
			case 0:
				if((active&ateof()) == 0)
					break;
			case 1:
				*q = recno;
				if(active)
					*q |= INACT;
				return (neg^1) << (!active&!ateof());
			case -1:
				if(active) {
					*q = recno | INACT;
					return neg;
				}
			}
		}
		return (neg^active) << 1;
	default:
		error(ERROR_PANIC|4, IBUG,2);
		return 0;	/* dummy */
	}
}

void
vacate(Text *t)
{
	assure(t, 1);
	t->w = t->s;
	*t->w = 0;
}

void
tcopy(Text *from, Text *to)
{
	int n = from->w - from->s;
	assure(to, n+1);
	memmove(to->w, from->s, n);
	to->w += n;
	*to->w = 0;
}
	

/* EASY COMMANDS */

uchar *
vv(Text *script, uchar *pc, Text *data)
{
	script = script;
	pc = pc;
	data = data;
	error(ERROR_PANIC|4, IBUG,3);
	return 0;	/* dummy */
}

uchar *
be(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return script->s + instr(pc)[1];
}

uchar *
de(Text *script, uchar *pc, Text *data)
{
	pc = pc;
	vacate(data);
	return 0;
}

uchar *
De(Text *script, uchar *pc, Text *data)
{
	int n;
	uchar *end = (uchar*)ustrchr(data->s, '\n');
	if(end == 0)
		return de(script, pc, data);
	end++;
	n = data->w - end;
	memmove(data->s, end, n+1);
	data->w = data->s + n;
	return script->s;
}

uchar *
Ee(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	if(sfprintf(sfstdout, "%d\n", recno) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return nexti(pc);
}

uchar *
Ge(Text *script, uchar *pc, Text *data)
{
	script = script;
	if(hold.s == 0) 
		vacate(&hold);
	if(data->w > data->s)
		*data->w++ = '\n';
	tcopy(&hold, data);
	return nexti(pc);
}

uchar *
ge(Text *script, uchar *pc, Text *data)
{
	vacate(data);
	return Ge(script, pc, data);
}

uchar *
He(Text *script, uchar *pc, Text *data)
{
	script = script;
	assure(&hold, 1);
	*hold.w++ = '\n';
	tcopy(data, &hold);
	return nexti(pc);
}

uchar *
he(Text *script, uchar *pc, Text *data)
{
	script = script;
	vacate(&hold);
	tcopy(data, &hold);
	return nexti(pc);
}

uchar *
Ie(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return nexti(pc);
}

uchar *
ie(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	if(sfprintf(sfstdout, "%s", (char*)(instr(pc)+1)) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return nexti(pc);
}

uchar *
Le(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return (uchar*)(instr(pc)+1);
}

uchar *
Ne(Text *script, uchar *pc, Text *data)
{
	assure(data, 1);
	*data->w++ = '\n';
	if(readline(data))
		return nexti(pc);
	*--data->w = 0;
	return de(script, pc, data);
}

uchar *
ne(Text *script, uchar *pc, Text *data)
{
	if(!nflag)
		writeline(data);
	vacate(data);
	if(readline(data))
		return nexti(pc);
	return 0;
}

uchar *
Pe(Text *script, uchar *pc, Text *data)
{
	int n;
	uchar *end = ustrchr(data->s, '\n');
	if(end == 0)
		n = data->w - data->s;
	else
		n = end - data->s;
	if(sfwrite(sfstdout, data->s, n) != n)
		error(ERROR_SYSTEM|3, stdouterr);
	cputchar('\n');
	script = script;
	return nexti(pc);
}

uchar *
pe(Text *script, uchar *pc, Text *data)
{
	writeline(data);
	script = script;
	return nexti(pc);
}

uchar *
qe(Text *script, uchar *pc, Text *data)
{
	pc = pc;
	data = data;
	qflag++;
	return script->w;
}

uchar *
te(Text *script, uchar *pc, Text *data)
{
	int tflag = sflag;
	sflag = 0;
	if(tflag)
		return be(script, pc, data);
	else
		return nexti(pc);
}

uchar *
ww(Text *script, uchar *pc, Text *data, int offset)
{
	int *q = (int*)(files.s + offset);
	Sfio_t *f = *(Sfio_t**)q;
	int n = data->w - data->s;
	assure(data, 1);
	*data->w = '\n';
	if(sfwrite(f, data->s, n+1) != n+1 ||
	   sfsync(f) == EOF)	/* in case of subsequent r */
		error(ERROR_SYSTEM|3, "%s: cannot write", (char*)(q+1));
	*data->w = 0;
	script = script;
	return nexti(pc);
}

uchar *
we(Text *script, uchar *pc, Text *data)
{
	return ww(script, pc, data, instr(pc)[1]);
}

uchar *
xe(Text *script, uchar *pc, Text *data)
{
	uchar *t;
	script = script;
	if(hold.s == 0)
		vacate(&hold);
	exch(data->s, hold.s, t);
	exch(data->e, hold.e, t);
	exch(data->w, hold.w, t);
	return nexti(pc);
}

uchar *
ye(Text *script, uchar *pc, Text *data)
{
	uchar *s = (uchar*)data->s;
	uchar *w = (uchar*)data->w;
	uchar *tbl = (uchar*)(instr(pc)+1);
	for( ; s<w; s++)
		*s = tbl[*s];
	script = script;
	return nexti(pc);
}

/* MISCELLANY */

uchar *
se(Text *script, uchar *pc, Text *data)
{
	int *q = instr(pc);
	int flags = q[2];
	uchar *p = (uchar*)(flags&WFLAG? q+4: q+3);
	int n = flags & ~(PFLAG|WFLAG);

	sflag = substitute(readdr(q[1]), data, p, n);
	if(!sflag)
		return nexti(pc);
	if(flags & PFLAG)
		pe(script, pc, data);
	if(flags & WFLAG)
		return ww(script, pc, data, ((int*)nexti(pc))[-1]);
	return nexti(pc);
}

struct { char p, q; } digram[] = {
	'\\',	'\\',
	'\a',	'a',
	'\b',	'b',
	'\f',	'f',
	'\n',	'n',
	'\r',	'r',
	'\t',	't',
	'\v',	'v',
};

uchar *
le(Text *script, uchar *pc, Text *data)
{
	int i = 0;
	int j;
	uchar *s;
	script = script;
	for(s=data->s; s<data->w; s++, i++) {
		if(i >= 60) {
			cputchar('\\');
			cputchar('\n');
			i = 0;
		}
		for(j=0; j<sizeof(digram)/sizeof(*digram); j++)
			if(*s == digram[j].p) {
				cputchar('\\');
				cputchar(digram[j].q);
				goto cont;
			}
		if(!isprint(*s)) {
			if(sfprintf(sfstdout, "\\%3.3o", *s) <= 0)
				error(ERROR_SYSTEM|3, stdouterr);
		} else
			cputchar(*s);
	cont:	;
	}
	cputchar('$');
	cputchar('\n');
	return nexti(pc);
}	

/* END-OF-CYCLE STUFF */

Text todo;

uchar *
ae(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	assure(&todo, sizeof(uchar*));
	*(uchar**)todo.w = pc;
	todo.w += sizeof(uchar*);
	return nexti(pc);
}

uchar *
ce(Text *script, uchar *pc, Text *data)
{	
	if(sfprintf(sfstdout, "%s", (char*)(instr(pc)+1)) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return de(script, pc, data);
}

void
coda(void)
{
	int *q;
	uchar *p;
	Sfio_t *f;
	if(todo.s == 0)
		return;
	for(p=todo.s; p<todo.w; p+=sizeof(int)) {
		q = instr(*(uchar**)p);
		switch(code(*q)) {
		case 'a':
			if(sfprintf(sfstdout, "%s", (char*)(q+1)) <= 0)
				error(ERROR_SYSTEM|3, stdouterr);
			continue;
		case 'r':
			f = sfopen(NiL, (char*)(files.s+q[1]+sizeof(int)), "r");
			if(f == 0)
				continue;
			if (sfmove(f, sfstdout, SF_UNBOUND, -1) < 0 || !sfeof(f) || sferror(sfstdout))
				error(ERROR_SYSTEM|3, stdouterr);
			sfclose(f);
			continue;
		default:
			error(ERROR_PANIC|4, IBUG,5);
		}
	}
	vacate(&todo);
}

/* execution functions return pointer to next instruction */

typedef uchar* (*exef)(Text*, uchar *, Text*);

static exef excom[128] = {
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,Ie,vv,vv,vv,vv,vv,
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,
	vv,vv,vv,Ie,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv, /* # */
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,Ce,Se,vv,Ee,vv,vv, /* :;= */
	vv,vv,vv,vv,De,vv,vv,Ge,He,vv,vv,vv,vv,vv,Ne,vv, /* DGHN */
	Pe,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv, /* P */
	vv,ae,be,ce,de,vv,vv,ge,he,ie,vv,vv,le,vv,ne,vv, /* a-n */
	pe,qe,re,se,te,vv,vv,we,xe,ye,vv,Le,vv,Re,vv,vv  /* p-y{} */
};

void
execute(Text *script, Text *data)
{
	uchar *pc;
	int sel;
	for(pc = script->s; pc < script->w; ) {
		sel = selected(pc, data);
		if(sel) {
			int cmd = code(*instr(pc));
			if(sel==2 && cmd=='c')
				cmd = 'd';
			pc = (*excom[cmd])(script, pc, data);
			if(pc == 0)
				return;
		} else
			pc = nexti(pc);
	}
	if(!nflag)
		writeline(data);
}
#pragma prototyped

#include "sed.h"

void docopy(uchar *where, int n);
int dosub(uchar *where, uchar *rp);

Text retemp;	/* holds a rewritten regex, without delimiter */

int
recomp(Text *rebuf, Text *t, int delim)
{
	static int lastre;
	uchar *w;
	vacate(&retemp);
	for(w=t->w; ; retemp.w++,w++) {
		assure(&retemp, 2);
		*retemp.w = *w;
		if(*w == delim)
			break;
		else if(*w==0 || *w=='\n')
			syntax("unterminated address");
		else if(*w != '\\')
			continue;
		else if(*++w==delim)
			*retemp.w = delim;
		else if(*w == 'n')
			*retemp.w = '\n';
		else if(*w==0 || *w=='\n')
			syntax("unterminated regular expression");
		else {
			assure(&retemp, 2);
			*++retemp.w = *w;
		}
	}
	*retemp.w = 0;

	assure(rebuf, sizeof(regex_t));
	if(*retemp.s) {
		if(regcomp((regex_t*)rebuf->w,(char*)retemp.s,reflags))
			syntax("bad regular expression");
		lastre = rebuf->w - rebuf->s;
		rebuf->w += sizeof(regex_t);
	} else if(rebuf->w == rebuf->s)
		syntax("no previous regular expression");
	t->w = w + 1;
	return lastre;
}

Text gendata;

#define NMATCH 10
regmatch_t matches[NMATCH];
#define so matches[0].rm_so
#define eo matches[0].rm_eo

int
substitute(regex_t *re, Text* data, uchar *rhs, int n)
{
	Text t;
	uchar *where = data->s;
	if(regexec(re, (char*)data->s, NMATCH, matches, 0))
		return 0;
	vacate(&gendata);
	if(n == 0)
		do {
			docopy(where, so);
			if(!dosub(where, rhs))
				return 0;
			where += eo;
			if(eo == so)
				if(where < data->w)
					docopy(where++, 1);
				else
					goto done;
		} while(regexec(re, (char*)where, NMATCH, matches, REG_NOTBOL) == 0);
	else {
		while(--n > 0) {
			where += eo;
			if(eo == so)
				if(where < data->w)
					where++;
				else
					return 0;
			if(regexec(re, (char*)where, NMATCH, matches, REG_NOTBOL))
				return 0;
		}
		docopy(data->s, where-data->s+so);
		if(!dosub(where, rhs))
			return 0;
		where += eo;
	}			
	eo = so = data->w - where;
	docopy(where, so);
done:
	exch(gendata, *data, t);
	return 1;
}

void
docopy(uchar *where, int n)
{
	assure(&gendata, n+1);
	memmove(gendata.w, where, n);
	gendata.w += n;
	*gendata.w = 0;
}

	/* interpretation problem: if there is no match for \1, say,
           does the substitition occur?  dosub uses a null string.
	   a change where indicated will abort the substitution */
	
int
dosub(uchar *where, uchar *rp)
{
	int c, n;
	regmatch_t *m;

	while(c = *rp++) {
		if(c == '\\') {
			c = *rp++;
			if (c >= '1' && c <= '9') {
				m = matches + c - '0';
				if(m->rm_eo == -1)
					continue;   /* or return 0 */
				n = m->rm_eo - m->rm_so;
				assure(&gendata, n);
				memmove(gendata.w,where+m->rm_so,n);
				gendata.w += n;
				continue;
			}
		} else if(c == '&') {
				assure(&gendata, eo-so);
				memmove(gendata.w,where+so,eo-so);
				gendata.w += eo-so;
				continue;
		}
		assure(&gendata, 1);
		*gendata.w++ = c;
	}
	return 1;
}
#pragma prototyped

/*
 * regular-expression tester
 *
 * usage: testre <testre.dat
 * see comments in testre.dat for description of format
 */

static const char id[] = "\n@(#)testre (AT&T Research) 01/01/96\0\n";

#include <ast.h>
#include <ctype.h>
#include <regex.h>
#include <setjmp.h>
#include <sig.h>
#include <stk.h>

#define LOOPED		2

#define NOTEST		(~0)
#ifndef REG_LEFT
#define REG_LEFT	NOTEST
#endif
#ifndef REG_MINIMAL
#define REG_MINIMAL	NOTEST
#endif
#ifndef REG_NULL
#define REG_NULL	NOTEST
#endif
#ifndef REG_RIGHT
#define REG_RIGHT	NOTEST
#endif

#define REG_UNKNOWN	(-1)

#ifndef REG_ENEWLINE
#define REG_ENEWLINE	(REG_UNKNOWN-1)
#endif
#ifndef REG_ENULL
#define REG_ENULL	(REG_UNKNOWN-2)
#endif
#ifndef REG_ECOUNT
#define REG_ECOUNT	(REG_UNKNOWN-3)
#endif
#ifndef REG_BADESC
#define REG_BADESC	(REG_UNKNOWN-4)
#endif
#ifndef REG_EMEM
#define REG_EMEM	(REG_UNKNOWN-5)
#endif
#ifndef REG_ELOOP
#define REG_ELOOP	(REG_UNKNOWN-6)
#endif
#ifndef REG_EBUS
#define REG_EBUS	(REG_UNKNOWN-7)
#endif
#ifndef REG_EFAULT
#define REG_EFAULT	(REG_UNKNOWN-8)
#endif

static const struct { int code; char* name; } codes[] = {
	REG_UNKNOWN,	"UNKNOWN",
	REG_NOMATCH,	"NOMATCH",
	REG_BADPAT,	"BADPAT",
	REG_ECOLLATE,	"ECOLLATE",
	REG_ECTYPE,	"ECTYPE",
	REG_EESCAPE,	"EESCAPE",
	REG_ESUBREG,	"ESUBREG",
	REG_EBRACK,	"EBRACK",
	REG_EPAREN,	"EPAREN",
	REG_EBRACE,	"EBRACE",
	REG_BADBR,	"BADBR",
	REG_ERANGE,	"ERANGE",
	REG_ESPACE,	"ESPACE",
	REG_BADRPT,	"BADRPT",
	REG_ENEWLINE,	"ENEWLINE",
	REG_ENULL,	"ENULL",
	REG_ECOUNT,	"ECOUNT",
	REG_BADESC,	"BADESC",
	REG_EMEM,	"EMEM",
	REG_ELOOP,	"ELOOP",
	REG_EBUS,	"EBUS",
	REG_EFAULT,	"EFAULT",
};

static struct
{
	int	failures;
	int	goofs;
	int	lineno;
	int	ret;
	int	signals;
	char*	which;
	jmp_buf	gotcha;
} state;

static void
report(char* comment, char* re, char* s, int flags)
{
	state.failures++;
	sfprintf(sfstdout, "%d:", state.lineno);
	if(re) {
		sfprintf(sfstdout, "%s", re);
		if(s)
			sfprintf(sfstdout, " versus %s", s);
	}
	sfprintf(sfstdout, " %s%s %s", state.which, (flags & REG_NOSUB) ? " NOSUB" : "", comment);
}

static void
bad(char* comment, char* re, char* s)
{
	sfprintf(sfstdout,  "bad test case ");
	report(comment, re, s, 0);
	exit(1);
}

static void
doregerror(regex_t* preg, int code, int lineno)
{
	char*	msg;
	char	buf[200];

	switch (code)
	{
	case REG_EBUS:
		msg = "bus error";
		break;
	case REG_EFAULT:
		msg = "memory fault";
		break;
	case REG_ELOOP:
		msg = "did not terminate";
		break;
	default:
		regerror(code, preg, msg = buf, sizeof buf);
		break;
	}
	sfprintf(sfstdout, "%s\n", msg);
}

static int
readfield(char* f, char end)
{
	int	c;

	for(;;) {
		*f = 0;
		c = sfgetc(sfstdin);
		if(c == EOF)
			return 1;
		if(c == end)
			break;
		if(c == '\n')
			return 1;
		*f++ = c;
	} 
	if(c == '\t') {
		while(c == end)
			c = sfgetc(sfstdin);
		sfungetc(sfstdin, c);
	}
	return 0;
}

static int
hex(int c)
{
	return	isdigit(c) ? c-'0' :
		isupper(c) ? c-'A' :
		c-'a'+10;
}

static void
escape(char* s)
{
	char*	t;

	for(t=s; *t=*s; s++, t++) {
		if(*s != '\\')
			continue;
		switch(*++s) {
		case 0:
			*++t = 0;
			break;
		case 'n':
			*t = '\n';
			break;
		case 'x':
			if(!isxdigit(s[1]) || !isxdigit(s[2]))
				bad("bad \\x\n", NiL, NiL);
			*t = hex(*++s) << 4;
			*t |= hex(*++s);
			break;
		default:
			s--;
		}
	}
}

static int
readline(char* spec, char* re, char* s, char* ans)
{
	int	c;

	switch(c = sfgetc(sfstdin)) {
	case EOF:
		return 0;
	case '#':
		while(c != '\n')
			c = sfgetc(sfstdin);
	case '\n':
		*spec = 0;
		return 1;
	}
	sfungetc(sfstdin, c);
	if(readfield(spec, '\t')) return 0;
	if(readfield(re, '\t')) return 0;
	if(readfield(s, '\t')) return 0;
	if(readfield(ans, '\n')) return 0;
	escape(re);
	escape(s);
	return 1;
}

static void
matchprint(regmatch_t* match, int nmatch)
{
	int	i;

	for( ; nmatch>0; nmatch --)
		if(match[nmatch-1].rm_so != -1)
			break;
	for(i=0; i<nmatch; i++) {
		sfprintf(sfstdout, "(");
		if(match[i].rm_so == -1)
			sfprintf(sfstdout, "?");
		else
			sfprintf(sfstdout, "%d", match[i].rm_so);
		sfprintf(sfstdout, ",");
		if(match[i].rm_eo == -1)
			sfprintf(sfstdout, "?");
		else
			sfprintf(sfstdout, "%d", match[i].rm_eo);
		sfprintf(sfstdout, ")");
	}
	sfprintf(sfstdout, "\n");
}

static int
matchcheck(int nmatch, regmatch_t* match, char* ans, char* re, char* s, int flags)
{
	char*	p;
	int	i;
	int	m;
	int	n;

	for(i = 0, p = ans; i<nmatch && *p; i++) {
		if(*p++ != '(')
			bad("improper answer\n", re, s);
		if(*p == '?') {
			m = -1;
			p++;
		} else
			m = strtol(p, &p, 10);
		if(*p++ != ',')
			bad("improper answer\n", re, s);
		if(*p == '?') {
			n = -1;
			p++;
		} else
			n = strtol(p, &p, 10);
		if(*p++ != ')')
			bad("improper answer\n", re, s);
		if(m!=match[i].rm_so || n!=match[i].rm_eo) {
			report("match was: ", re, s, flags);
			matchprint(match, nmatch);
			return 0;
		}
	}
	for( ; i<nmatch; i++) {
		if(match[i].rm_so!=-1 || match[i].rm_eo!=-1) {
			report("match was: ", re, s, flags);
			matchprint(match, nmatch);
			return 0;
		}
	}
	return 1;
}

static void
gotcha(int sig)
{
	signal(sig, gotcha);
	alarm(0);
	state.signals++;
	switch (sig)
	{
	case SIGALRM:
		state.ret = REG_ELOOP;
		break;
	case SIGBUS:
		state.ret = REG_EBUS;
		break;
	case SIGSEGV:
		state.ret = REG_EFAULT;
		break;
	}
	sigunblock(sig);
	longjmp(state.gotcha, 1);
}

static void*
stkresize(void* handle, void* p, size_t n)
{
	void*	x;

	if (!n || !(x = stkalloc((Stk_t*)handle, n)))
		return 0;
	if (p)
		memcpy(x, p, n / 2);
	return x;
}

main(int argc, char** argv)
{
	regmatch_t	NOMATCH;
	int		flags;
	int		cflags;
	int		eflags;
	int		are;
	int		bre;
	int		ere;
	int		kre;
	int		lre;
	int		sre;
	char		spec[10];
	char		re[1000];
	char		s[100000];
	char		ans[500];
	char		msg[500];
	regmatch_t	match[100];
	regex_t		preg;
	char*		p;
	int		nmatch;
	int		cret;
	int		eret;
	int		i;
	int		expected;
	int		got;
	int		len;

	int		catch = 0;
	int		testno = 0;
	int		verbose = 0;
	off_t		stk = -1;

	sfprintf(sfstdout, "TEST	<regex>");
	while((p = *++argv) && *p == '-')
		for(;;)
		{
			switch(*++p)
			{
			case 0:
				break;
			case 'c':
				catch = 1;
				sfprintf(sfstdout, ", catch");
				continue;
			case 's':
#ifdef REG_AUGMENTED
				stk = stktell(stkstd);
				regalloc((void*)stkstd, stkresize, REG_NOFREE);
				sfprintf(sfstdout, ", stkstd");
#endif
				continue;
			case 'v':
				verbose = 1;
				sfprintf(sfstdout, ", verbose");
				continue;
			default:
				sfprintf(sfstdout, ", invalid option %c", *p);
				continue;
			}
			break;
		}
	if(p)
		sfprintf(sfstdout, ", argument(s) ignored");
	sfprintf(sfstdout, "\n");
	if(catch) {
		signal(SIGALRM, gotcha);
		signal(SIGBUS, gotcha);
		signal(SIGSEGV, gotcha);
	}
	NOMATCH.rm_so = -2;
	NOMATCH.rm_eo = -2;
	while(readline(spec, re, s, ans)) {
		state.lineno++;
		if(*spec == 0)
			continue;
		sfsync(sfstdout);

	/* interpret: */

		cflags = eflags = are = bre = ere = kre = lre = sre = 0;
		nmatch = 20;
		for(p=spec; *p; p++) {
			if(isdigit(*p)) {
				nmatch = strtol(p, &p, 10);
				p--;
				continue;
			}
			switch(*p) {

			case 'A':
				are = 1;
				continue;
			case 'B':
				bre = 1;
				continue;
			case 'E':
				ere = 1;
				continue;
			case 'K':
				kre = 1;
				continue;
			case 'L':
				lre = 1;
				continue;
			case 'S':
				sre = 1;
				continue;

			case 'I':
				cflags |= REG_ICASE;
				continue;
			case 'M':
				cflags |= REG_MINIMAL;
				continue;
			case 'U':
				cflags |= REG_NULL;
				continue;
			case 'W':
				cflags |= REG_NEWLINE;
				continue;

			case 'a':
				cflags |= REG_LEFT|REG_RIGHT;
				continue;
			case 'b':
				eflags |= REG_NOTBOL;
				continue;
			case 'e':
				eflags |= REG_NOTEOL;
				continue;
			case 'l':
				cflags |= REG_LEFT;
				continue;
			case 'r':
				cflags |= REG_RIGHT;
				continue;

			case '?':
				continue;

			default:
				bad("bad spec\n", re, s);

			}
		}
		if(streq(re, "NULL"))
			re[0] = 0;
		if(streq(s, "NULL"))
			s[0] = 0;
		if((cflags|eflags) == NOTEST)
			continue;

	compile:

		if(bre) {
			state.which = "BRE";
			bre = 0;
			flags = cflags;
		}
		else if(ere) {
			state.which = "ERE";
			ere = 0;
			flags = cflags | REG_EXTENDED;
		}
#ifdef REG_AUGMENTED
		else if(are) {
			state.which = "ARE";
			are = 0;
			flags = cflags | REG_AUGMENTED;
		}
#endif
#ifdef REG_LITERAL
		else if(lre) {
			state.which = "LRE";
			lre = 0;
			flags = cflags | REG_LITERAL;
		}
#endif
#ifdef REG_SHELL
		else if(sre) {
			state.which = "SRE";
			sre = 0;
			flags = cflags | REG_SHELL;
		}
#ifdef REG_AUGMENTED
		else if(kre) {
			state.which = "KRE";
			kre = 0;
			flags = cflags | REG_SHELL | REG_AUGMENTED;
		}
#endif
#endif
		else
			continue;
		if(verbose)
			sfprintf(sfstdout, "test %-3d %s \"%s\" \"%s\"\n", state.lineno, state.which, re, s);

	nosub:

		testno++;
		if(catch) {
			if(setjmp(state.gotcha))
				cret = state.ret;
			else {
				alarm(LOOPED);
				cret = regcomp(&preg, re, flags);
				alarm(0);
			}
		} else
			cret = regcomp(&preg, re, flags);
		if(cret == 0) {
			if(!streq(ans, "NULL") &&
			   !streq(ans, "NOMATCH") &&
			   ans[0]!='(') {
				report("regcomp should fail and didn't\n", re, NiL, flags);
				continue;
			}
		} else {
			if(streq(ans, "NULL") ||
			   ans[0]=='(' ||
			   cret==REG_BADPAT && streq(ans, "NOMATCH")) {
				report("regcomp failed: ", re, NiL, flags);
				doregerror(&preg, cret, state.lineno);
			} else {
				expected = got = 0;
				for(i=1; i<elementsof(codes); i++) {
					if(streq(ans, codes[i].name))
						expected = i;
					if(cret==codes[i].code)
						got = i;
				}
				if(!expected)
				{
					report("invalid error code: ", re, NiL, flags);
					sfprintf(sfstdout, "%s expected, %s returned\n", ans, codes[got].name);
				}
				else if(cret!=codes[expected].code && cret!=REG_BADPAT) {
					report("regcomp should fail and did: ", re, NiL, flags);
					sfprintf(sfstdout, "%s expected, %s returned: ", ans, codes[got].name);
					state.failures--;
					state.goofs++;
					doregerror(&preg, cret, state.lineno);
				}
			}
			goto compile;
		}

	/* execute: */
		
		for(i=0; i<elementsof(match); i++)
			match[i] = NOMATCH;

		if(catch) {
			if(setjmp(state.gotcha))
				eret = state.ret;
			else {
				alarm(LOOPED);
				eret = regexec(&preg, s, nmatch, match, eflags);
				alarm(0);
			}
		} else
			eret = regexec(&preg, s, nmatch, match, eflags);

		if(flags & REG_NOSUB) {
			if(eret) {
				report("regexec REG_NOSUB failed: ", re, s, flags);
				doregerror(&preg, eret, state.lineno);
			}
		} else if(eret) {
			if(!streq(ans, "NOMATCH")) {
				report("regexec failed", re, s, flags);
				if(eret != REG_NOMATCH) {
					sfprintf(sfstdout, ": ");
					doregerror(&preg, eret, state.lineno);
				} else
					sfprintf(sfstdout, "\n");
			}
		} else if(streq(ans, "NOMATCH")) {
			report("regexec should fail and didn't: ", re, s, flags);
			matchprint(match, nmatch);
		} else if(streq(ans, "NULL")) {
			if(match[0].rm_so != NOMATCH.rm_so) {
				report("no match but match array assigned: ", re, s, flags);
				matchprint(match, nmatch);
			}
		} else if (matchcheck(nmatch, match, ans, re, s, flags)) {
			if(stk >= 0)
				stkseek(stkstd, stk);
			else
				regfree(&preg);
			flags |= REG_NOSUB;
			goto nosub;
		}
		if(stk >= 0)
			stkseek(stkstd, stk);
		else
			regfree(&preg);
		goto compile;
	}
	sfprintf(sfstdout, "TEST	<regex>, %d tests", testno);
	if(state.goofs)
		sfprintf(sfstdout, ", %d goofs", state.goofs);
	if(state.signals)
		sfprintf(sfstdout, ", %d signals", state.signals);
	sfprintf(sfstdout, ", %d errors\n", state.failures);
	return 0;
}
#pragma prototyped
/*
 * Editor (snarfed from v10, now posix compliant, no hard limits)
 */

static const char id[] = "\n@(#)ed (AT&T Research) 01/01/96\0\n";

#include <ast.h>
#include <error.h>
#include <ls.h>
#include <sfstr.h>
#include <sig.h>

#include <ctype.h>
#include <regex.h>
#include <setjmp.h>

#define BLOCK_LINE	1024
#define BLOCK_TMP	(8*SF_BUFSIZE)

#define BREAK_PAGE	23
#define BREAK_LINE	72

#define LINE_GLOBAL	((off_t)0x80000000)
#define LINE_MARKED	((off_t)0x40000000)
#define LINE_NONE	((off_t)-1)

#define MARK_MIN	'a'
#define MARK_MAX	'z'

#define MATCH_MIN	'0'
#define MATCH_MAX	'9'

#define PRINT		01
#define PRINT_LIST	02
#define PRINT_NUMBER	04

#define REC_IGNORE	001
#define REC_LINE	002
#define REC_SPLICE	004
#define REC_TERMINATE	010
#define REC_TEXT	020

#define BEG(n)		(ed.line+ed.match[n].rm_so)
#define CUR()		(ed.line)
#define END(n)		(ed.line+ed.match[n].rm_eo)
#define HIT(n)		(ed.match[n].rm_eo!=-1)
#define NXT()		(ed.line++)
#define SET(p)		(ed.line=(p))

#define error		fatal
#define trap()		do{if(ed.caught)handle();}while(0);

#define swap(t,a,b)	(ed.swp=(void*)(a),(a)=(b),(b)=(t)ed.swp)

typedef struct
{
	off_t		offset;
	off_t		undo;
	unsigned long	event;
} Line_t;

static int		signals[] = { SIGQUIT, SIGHUP, SIGINT, SIGTERM };

static struct		/* program state -- no other dynamic globals */
{
	struct
	{
	Sfio_t*		file;
	Sfio_t*		global;
	Sfio_t*		help;
	Sfio_t*		line;
	Sfio_t*		prompt;
	Sfio_t*		query;
	Sfio_t*		shell;
	Sfio_t*		substitute;
	Sfio_t*		work;
	}		buffer;
	struct
	{
	int		print;
	int		size;
	}		page;
	struct
	{
	off_t		marks[MARK_MAX - MARK_MIN + 1];
	unsigned long	dol;
	unsigned long	dot;
	}		undo;
	Line_t*		addr1;
	Line_t*		addr2;
	Line_t*		dol;
	Line_t*		dot;
	Line_t*		zero;
	Sfio_t*		iop;
	Sfio_t*		msg;
	Sfio_t*		tmp;
	char*		global;
	char*		line;
	char*		linebreak;
	char*		tmpfile;
	int		caught;
	int		compiled;
	int		evented;
	int		given;
	int		help;
	int		initialized;
	int		interactive;
	int		lastc;
	int		marked;
	int		modified;
	int		peekc;
	int		pending;
	int		print;
	int		prompt;
	int		verbose;
	int		warn_newline;
	int		warn_null;
	jmp_buf		again;
	off_t		marks[MARK_MAX - MARK_MIN + 1];
	off_t		tmpoff;
	regex_t		re;
	regmatch_t	match[MATCH_MAX - MATCH_MIN + 1];
	unsigned long	all;
	unsigned long	bytes;
	unsigned long	event;
	unsigned long	lines;
	void*		swp;
}			ed;

static void		commands(void);
static void		handle(void);
static void		quit(int);

static void
interrupt(int sig)
{
	signal(sig, interrupt);
	if (ed.initialized) {
		if (!ed.caught)
			ed.caught = sig;
	}
	else if (!ed.pending)
		ed.pending = sig;
}

static int
getchr(void)
{
	if (ed.lastc = ed.peekc) {
		ed.peekc = 0;
		return(ed.lastc);
	}
	if (ed.global) {
		if (ed.lastc = *ed.global++)
			return(ed.lastc);
		ed.global = 0;
		return(EOF);
	}
	if ((ed.lastc = sfgetc(sfstdin)) == EOF)
		trap();
	return(ed.lastc);
}

static ssize_t
helpwrite(int fd, const void* buf, size_t len)
{
	ssize_t	n;

	NoP(fd);
	n = ed.help ? sfwrite(ed.msg, buf, len) : ed.verbose ? sfputr(ed.msg, "?", '\n') : 0;
	sfstrset(ed.buffer.help, 0);
	sfwrite(ed.buffer.help, buf, len - 1);
	sfputc(ed.buffer.help, 0);
	return(n);
}

static void
error(int level, ...)
{
	va_list		ap;
	register int	c;

	trap();
	va_start(ap, level);
	errorv(NiL, level, ap);
	va_end(ap);
	if (level >= 2) {
		if (ed.iop) {
			sfclose(ed.iop);
			ed.iop = 0;
			error_info.file = 0;
		}
		if (ed.interactive <= 0 && (ed.interactive = isatty(0)) <= 0)
			quit(1);
		ed.print = 0;
		ed.bytes = 0;
		ed.lines = 0;
		if (ed.global)
			ed.lastc = '\n';
		ed.global = 0;
		ed.peekc = ed.lastc;
		if (ed.lastc)
			while ((c = getchr()) != '\n' && c != EOF)
				;
		longjmp(ed.again, 1);
	}
}

static void
init(void)
{
	register Sfio_t**	ss;
	register int		c;

	ed.interactive = -1;
	ed.msg = sfstdout;
	ed.all = BLOCK_LINE;
	ed.page.size = BREAK_PAGE;
	ed.verbose = 1;
	for (c = 0; c < elementsof(signals); c++)
		if (signal(signals[c], interrupt) == SIG_IGN)
			signal(signals[c], SIG_IGN);
	for (ss = (Sfio_t**)&ed.buffer; ss < (Sfio_t**)(((char*)&ed.buffer) + sizeof(ed.buffer)); ss++) {
		if (!(*ss = sfstropen()))
			error(ERROR_SYSTEM|3, "cannot initialize internal buffer");
		sfputc(*ss, 0);
		sfstrset(*ss, 0);
	}
	sfputr(ed.buffer.help, "?", 0);
	if (!(ed.zero = newof(NiL, Line_t, ed.all, 0)))
		error(ERROR_SYSTEM|3, "out of space [zero]");
}

static char*
getrec(register Sfio_t* sp, register int delimiter, register int flags)
{
	register int	c;
	register char*	glob;

	sfstrset(sp, 0);
	glob = ed.global;
	while ((c = getchr()) != delimiter) {
		if (c == '\n') {
			ed.peekc = c;
			break;
		}
		if (c == EOF) {
			if (glob)
				ed.peekc = (flags & REC_LINE) ? 0 : c;
			else if (delimiter != '\n' || (flags & (REC_LINE|REC_SPLICE)))
				error(2, "unexpected EOF");
			else if (flags & REC_TEXT)
				return(0);
			break;
		}
		if (c == '\\' && ((c = getchr()) != delimiter || (flags & REC_SPLICE) && c != '\n') && c && !(flags & REC_IGNORE))
			sfputc(sp, '\\');
		if (!c)
			error(1, "null character ignored");
		else if (!(flags & REC_IGNORE))
			sfputc(sp, c);
	}
	if (flags & REC_TERMINATE)
		sfputc(sp, c);
	return(sfstruse(sp));
}

static void
putrec(register char* s)
{
	register int	n;
	register char*	t;

	if ((ed.print & PRINT_LIST) && (t = fmtesc(s))) {
		s = t;
		n = strlen(s);
		while (n > BREAK_LINE) {
			n -= BREAK_LINE;
			sfprintf(ed.msg, "%-*.*s\\\n", BREAK_LINE, BREAK_LINE, s);
			s += BREAK_LINE;
		}
		sfprintf(ed.msg, "%s$\n", s);
	}
	else
		sfputr(ed.msg, s, '\n');
}

static void
modify(void)
{
	if (!ed.evented) {
		ed.evented = ed.modified = 1;
		ed.event++;
		ed.undo.dot = ed.dot - ed.zero;
		ed.undo.dol = ed.dol - ed.zero;
		if (ed.marked) {
			register int	c;

			for (c = 0; c < elementsof(ed.marks); c++)
				ed.undo.marks[c] = ed.marks[c];
		}
	}
}

static void
undo(void)
{
	register Line_t*	a1;
	register Line_t*	a3;
	register unsigned long	event;
	int			c;
	off_t			t;
	unsigned long		n;

	c = 0;
	event = ed.event;
	a1 = ed.zero;
	a3 = ed.zero + ed.all;
	while (++a1 < a3)
		if (a1->event == event) {
			c = 1;
			t = a1->offset;
			a1->offset = a1->undo;
			a1->undo = t;
		}
	if (!c)
		error(2, "nothing to undo");
	if (ed.marked)
		for (c = 0; c < elementsof(ed.marks); c++) {
			t = ed.marks[c];
			ed.marks[c] = ed.undo.marks[c];
			ed.undo.marks[c] = t;
		}
	n = ed.dot - ed.zero;
	ed.dot = ed.zero + ed.undo.dot;
	ed.undo.dot = n;
	n = ed.dol - ed.zero;
	ed.dol = ed.zero + ed.undo.dol;
	ed.undo.dol = n;
}

static char*
lineget(off_t off)
{
	char*	s;

	off &= ~(LINE_GLOBAL|LINE_MARKED);
	if (sfseek(ed.tmp, off, SEEK_SET) != off)
		error(ERROR_SYSTEM|2, "temp file read seek error");
	if (!(s = sfgetr(ed.tmp, 0, 0)))
		error(ERROR_SYSTEM|2, "temp file read error");
	return(s);
}

static off_t
lineput(char* s)
{
	off_t	off;

	modify();
	off = ed.tmpoff;
	if (sfseek(ed.tmp, off, SEEK_SET) != off)
		error(ERROR_SYSTEM|2, "temp file write seek error");
	if (sfputr(ed.tmp, s, 0) < 0)
		error(ERROR_SYSTEM|2, "temp file write error");
	if ((ed.tmpoff = sfseek(ed.tmp, 0L, SEEK_CUR)) == (off_t)-1)
		error(ERROR_SYSTEM|2, "temp file tell error");
	return(off);
}

static void
replace(register Line_t* a1, char* s)
{
	register off_t	off;

	off = lineput(s);
	if (a1->offset & LINE_MARKED) {
		register off_t*	mp;

		a1->offset &= ~LINE_GLOBAL;
		off |= LINE_MARKED;
		for (mp = ed.marks; mp < &ed.marks[elementsof(ed.marks)]; mp++)
			if (*mp == a1->offset)
				*mp = off;
	}
	a1->event = ed.event;
	a1->undo = a1->offset;
	a1->offset = off;
}

static void
squeeze(int i)
{
	if (ed.addr1 < ed.zero + i)
		error(2, "at top of file");
	if (ed.addr2 > ed.dol)
		error(2, "at end of file");
	if (ed.addr1 > ed.addr2)
		error(2, "first address exceeds second");
}

static void
nonzero(void)
{
	squeeze(1);
}

static char*
getfile(void)
{
	register char*	s;
	register int	n;
	register int	m;

	if (!(s = sfgetr(ed.iop, '\n', 1))) {
		if (!(s = sfgetr(ed.iop, '\n', -1)))
			return(0);
		ed.warn_newline = 1;
	}
	n = sfslen();
	if ((m = strlen(s)) < n) {
		register char*	t;
		register char*	u;
		register char*	x;

		t = u = s + m;
		x = s + n;
		while (u < x)
			if (!(*t++ = *u++))
				t--;
		*t++ = 0;
		n = t - s;
		ed.warn_null += x - t;
	}
	ed.bytes += n;
	ed.lines++;
	return(s);
}

static char*
getline(void)
{
	register char*	s;

	if ((s = getrec(ed.buffer.line, '\n', REC_TEXT)) && s[0] == '.' && !s[1])
		s = 0;
	return(s);
}

static char*
getbreak(void)
{
	char*	s;

	if ((s = ed.linebreak) && (ed.linebreak = strchr(s, '\n')))
		*ed.linebreak++ = 0;
	return(s);
}

static char*
getcopy(void)
{
	if (ed.addr1 > ed.addr2)
		return(0);
	return(lineget((ed.addr1++)->offset));
}

static void
print(void)
{
	register Line_t* a1;

	nonzero();
	a1 = ed.addr1;
	do {
		if (ed.print & PRINT_NUMBER)
			sfprintf(ed.msg, "%d\t", a1 - ed.zero);
		putrec(lineget((a1++)->offset));
	} while (a1 <= ed.addr2);
	ed.dot = ed.addr2;
	ed.print = 0;
}

static int
getnum(void)
{
	register int c;
	register int r;

	r = 0;
	while ((c = getchr()) >= '0' && c <= '9')
		r = r * 10 + c - '0';
	ed.peekc = c;
	return(r);
}

static void
regfatal(int code)
{
	char	buf[128];

	if (code) {
		regerror(code, 0, buf, sizeof(buf));
		error(2, "%s", buf);
	}
}

static void
compile(int delimiter)
{
	register char*	s;
	int		c;

	s = getrec(ed.buffer.line, delimiter, 0);
	if (*s) {
		if (ed.compiled) {
			ed.compiled = 0;
			regfree(&ed.re);
		}
		if (c = regcomp(&ed.re, s, 0))
			regfatal(c);
		ed.compiled = 1;
	}
	else if (!ed.compiled)
		error(2, "no previous regular expression");
}

static int
execute(Line_t* addr)
{
	register char*	s;
	register int	c;

	trap();
	if (!addr)
		s = CUR();
	else if (addr == ed.zero)
		return(0);
	else
		s = lineget(addr->offset);
	if (c = regexec(&ed.re, s, elementsof(ed.match), ed.match, 0)) {
		if (c != REG_NOMATCH)
			regfatal(c);
		return(0);
	}
	SET(s);
	return(1);
}

static Line_t*
address(void)
{
	register int		c;
	register int		sign;
	register Line_t*	a;
	register Line_t*	b;
	int			opcnt;
	int			nextopand;

	nextopand = -1;
	sign = 1;
	opcnt = 0;
	a = ed.dot;
	do {
		do c = getchr(); while (isspace(c) && c != '\n');
		if (c >= '0' && c <= '9') {
			ed.peekc = c;
			if (!opcnt)
				a = ed.zero;
			a += sign * getnum();
		}
		else switch (c) {

		case '$':
			a = ed.dol;
			/*FALLTHROUGH*/
		case '.':
			if (opcnt)
				error(2, "invalid address");
			break;

		case '\'':
			if ((c = getchr()) == EOF || (c -= MARK_MIN) < 0 || c >= elementsof(ed.marks) || opcnt)
				error(2, "invalid mark");
			a = ed.marked && ed.marks[c] != LINE_NONE ? ed.zero : ed.dol;
			do {
				if (++a > ed.dol)
					error(2, "undefined mark referenced");
			} while (ed.marks[c] != (a->offset & ~LINE_GLOBAL));
			break;

		case '?':
			sign = -sign;
			/*FALLTHROUGH*/
		case '/':
			compile(c);
			b = a;
			for (;;) {
				a += sign;
				if (a <= ed.zero)
					a = ed.dol;
				if (a > ed.dol)
					a = ed.zero;
				if (execute(a))
					break;
				if (a == b)
					error(2, "pattern not found");
			}
			break;

		default:
			if (nextopand == opcnt) {
				a += sign;
				if (a < ed.zero || ed.dol < a)
					continue;       /* error? */
			}
			if (c != '+' && c != '-' && c != '^') {
				ed.peekc = c;
				if (!opcnt)
					a = 0;
				return(a);
			}
			sign = 1;
			if (c != '+')
				sign = -sign;
			nextopand = ++opcnt;
			continue;

		}
		sign = 1;
		opcnt++;
	} while (a >= ed.zero && a <= ed.dol);
	error(2, "address out of range");
	return(0);
}

static void
setwide(void)
{
	if (!ed.given) {
		ed.addr1 = ed.zero + (ed.dol > ed.zero);
		ed.addr2 = ed.dol;
	}
}

static void
setnoaddr(void)
{
	if (ed.given)
		error(2, "invalid address count");
}

static void
newline(void)
{
	register int	warned = 0;

	for (;;)
		switch (getchr()) {

		case EOF:
		case '\n':
			return;

		case 'l':
			ed.print = PRINT_LIST;
			continue;

		case 'n':
			ed.print = PRINT_NUMBER;
			continue;

		case 'p':
			ed.print = PRINT;
			continue;

		default:
			if (!warned) {
				warned = 1;
				error(2, "extra characters at end of command");
			}
			continue;
		}
}

static char*
plural(unsigned long count)
{
	return(count == 1 ? "" : "s");
}

static void
exfile(void)
{
	if (sfclose(ed.iop))
		error(ERROR_SYSTEM|1, "io error");
	ed.iop = 0;
	if (ed.verbose) {
		if (ed.help) {
			sfprintf(ed.msg, "\"%s\" %lu line%s, %lu character%s", error_info.file, ed.lines, plural(ed.lines), ed.bytes, plural(ed.bytes));
			if (ed.warn_null) {
				sfprintf(ed.msg, ", %lu null%s", ed.warn_null, plural(ed.warn_null));
				ed.warn_null = 0;
			}
			if (ed.warn_newline) {
				sfprintf(ed.msg, ", newline appended");
				ed.warn_newline = 0;
			}
			sfputc(ed.msg, '\n');
		}
		else
			sfprintf(ed.msg, "%d\n", ed.bytes);
	}
	if (ed.warn_null || ed.warn_newline) {
		char*	sep = "";

		sfstrset(ed.buffer.line, 0);
		if (ed.warn_null) {
			sfprintf(ed.buffer.line, "%d null character%s ignored", ed.warn_null, plural(ed.warn_null));
			ed.warn_null = 0;
			sep = ", ";
		}
		if (ed.warn_newline) {
			sfprintf(ed.buffer.line, "%snewline appended to last line", sep);
			ed.warn_newline = 0;
		}
		error(1, "%s", sfstruse(ed.buffer.line));
	}
	error_info.file = 0;
}

static void
putfile(void)
{
	register Line_t*	a1;
	register int		n;

	ed.bytes = 0;
	ed.lines = 0;
	a1 = ed.addr1;
	do {
		if ((n = sfputr(ed.iop, lineget((a1++)->offset), '\n')) < 0)
			error(ERROR_SYSTEM|2, "write error");
		ed.bytes += n;
		ed.lines++;
	} while (a1 <= ed.addr2);
	if (sfsync(ed.iop))
		error(ERROR_SYSTEM|2, "write error");
}

static void
quit(int code)
{
	if (ed.tmpfile) {
		remove(ed.tmpfile);
		ed.tmpfile = 0;
	}
	if (ed.verbose && ed.modified && ed.dol != ed.zero) {
		ed.modified = 0;
		error(2, "file changed but not written");
	}
	if (ed.caught == SIGQUIT) {
		signal(ed.caught, SIG_DFL);
		kill(0, ed.caught);
	}
	exit(code);
}

static void
handle(void)
{
	register int	c;
	char*		s;
	char*		b;
	mode_t		mask;

	if (ed.caught == SIGINT) {
		ed.caught = 0;
		ed.lastc = '\n';
		sfputc(ed.msg, '\n');
		error(2, "interrupt");
	}
	for (c = 0; c < elementsof(signals); c++)
		signal(signals[c], SIG_IGN);
	if (ed.dol > ed.zero) {
		ed.addr1 = ed.zero + 1;
		ed.addr2 = ed.dol;
		mask = umask(S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
		b = "ed.hup";
		if (!(ed.iop = sfopen(NiL, b, "w")) && (s = getenv("HOME"))) {
			sfstrset(ed.buffer.line, 0);
			sfprintf(ed.buffer.line, "%s/%s", s, b);
			b = sfstruse(ed.buffer.line);;
			ed.iop = sfopen(NiL, b, "w");
		}
		umask(mask);
		if (!ed.iop)
			error(ERROR_SYSTEM|1, "%s: cannot save changes", b);
		else {
			error_info.file = b;
			putfile();
		}
	}
	ed.modified = 0;
	quit(0);
}

static int
append(char* (*f)(void), Line_t* a)
{
	register char*		s;
	register Line_t*	a1;
	register Line_t*	a2;
	register Line_t*	a3;
	off_t			t;
	long			m;
	long			slide;

	slide = 0;
	ed.dot = a;
	while (s = (*f)()) {
		if ((ed.dol - ed.zero) + 1 >= ed.all) {
#if __sgi__ && !__GNUC__ /* sgi pointer arithmetic bug -- it's fun */
			long	dot = ed.dot - ed.zero;
			long	dol = ed.dol - ed.zero;
#endif
			a3 = ed.zero;
			ed.all += BLOCK_LINE;
			if (!(ed.zero = newof(ed.zero, Line_t, ed.all, 0))) {
				error(ERROR_SYSTEM|1, "no space [zero]");
				ed.caught = SIGHUP;
				trap();
			}
			m = ed.zero - a3;
			slide += m;
#if __sgi__ && !__GNUC__ /* sgi pointer arithmetic bug -- it's fun */
			ed.dot = ed.zero + dot;
			ed.dol = ed.zero + dol;
#else
			ed.dot += m;
			ed.dol += m;
#endif
		}
		t = lineput(s);
		slide++;
		a1 = ++ed.dol;
		a2 = a1 + 1;
		a3 = ++ed.dot;
		while (a1 > a3) {
			(--a2)->event = ed.event;
			a2->undo = a2->offset;
			a2->offset = (--a1)->offset;
		}
		a3->event = ed.event;
		a3->undo = a3->offset;
		a3->offset = t;
	}
	return(slide);
}

static void
add(int i)
{
	if (i && (ed.given || ed.dol > ed.zero)) {
		ed.addr1--;
		ed.addr2--;
	}
	squeeze(0);
	newline();
	append(getline, ed.addr2);
}

static void
page(void)
{
	register int	direction;
	register int	n;

	switch (direction = getchr()) {

	case '-':
	case '.':
	case '+':
		break;

	default:
		ed.peekc = direction;
		direction = '+';
		break;

	}
	if ((n = getnum()) > 0)
		ed.page.size = n;
	newline();
	if (ed.print)
		ed.page.print = ed.print;
	else
		ed.print = ed.page.print;
	switch (direction) {

	case '-':
		ed.addr1 = ed.addr2 - ed.page.size + 1;
		break;

	case '.':
		ed.addr2 += ed.page.size / 2;
		ed.addr1 = ed.addr2 - ed.page.size + 1;
		break;

	case '+':
		ed.addr1 = ed.addr2;
		ed.addr2 += ed.page.size - 1;
		break;

	}
	if (ed.addr1 <= ed.zero)
		ed.addr1 = ed.zero + 1;
	if (ed.addr2 > ed.dol)
		ed.addr2 = ed.dol;
	print();
}

static void
rdelete(register Line_t* a1, register Line_t* a2)
{
	register Line_t*	a3;

	modify();
	a3 = ed.dol;
	ed.dol -= ++a2 - a1;
	ed.dot = a1 > ed.dol ? ed.dol : a1;
	do {
		a1->undo = a1->offset;
		a1->event = ed.event;
		(a1++)->offset = (a2++)->offset;
	} while (a2 <= a3);
	while (a1 <= a3) {
		a1->undo = a1->offset;
		(a1++)->event = ed.event;
	}
}

static void
gdelete(void)
{
	register Line_t*	a1;
	register Line_t*	a2;
	register Line_t*	a3;

	a3 = ed.dol;
	for (a1 = ed.zero; !(a1->offset & LINE_GLOBAL); a1++)
		if (a1 >= a3)
			return;
	modify();
	for (a2 = a1 + 1; a2 <= a3;) {
		a1->event = ed.event;
		a1->undo = a1->offset;
		if (a2->offset & LINE_GLOBAL) {
			a2++;
			ed.dot = a1;
		}
		else
			(a1++)->offset = (a2++)->offset;
	}
	ed.dol = a1 - 1;
	if (ed.dot > ed.dol)
		ed.dot = ed.dol;
	while (a1 <= a3) {
		a1->undo = a1->offset;
		(a1++)->event = ed.event;
	}
}

static void
shell(void)
{
	register char*	s;
	register char*	f = 0;
	register int	c;

	if (ed.given)
		squeeze(ed.dol > ed.zero);
	s = getrec(ed.buffer.line, '\n', 0);
	if (s[0] == '!' && !s[1]) {
		if (!*sfstrbase(ed.buffer.shell))
			error(2, "no saved shell command");
		f = sfstrbase(ed.buffer.file);
	}
	else if (!s[0])
		error(2, "empty shell command");
	else
		swap(Sfio_t*, ed.buffer.shell, ed.buffer.line);
	s = sfstrbase(ed.buffer.shell);
	sfstrset(ed.buffer.line, 0);
	sfputc(ed.buffer.line, '!');
	while (c = *s++) {
		if (c == '\\') {
			if (*s != '%')
				sfputc(ed.buffer.line, c);
			sfputc(ed.buffer.line, *s++);
		}
		else if (c == '%')
			sfputr(ed.buffer.line, f = sfstrbase(ed.buffer.file), -1);
		else
			sfputc(ed.buffer.line, c);
	}
	if (ed.given) {
		if (!ed.tmpfile && !(ed.tmpfile = pathtemp(NiL, NiL, error_info.id)))
			error(ERROR_SYSTEM|2, "cannot generate temp file name");
		if (!(ed.iop = sfopen(NiL, ed.tmpfile, "w")))
			error(ERROR_SYSTEM|2, "%s: cannot create temp file", ed.tmpfile);
		error_info.file = ed.tmpfile;
		if (ed.dol > ed.zero)
			putfile();
		exfile();
		ed.bytes = 0;
		ed.lines = 0;
		sfprintf(ed.buffer.line, " < %s", ed.tmpfile);
		s = sfstruse(ed.buffer.line);
		if (!(ed.iop = sfpopen(NiL, s + 1, "r")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", s);
		error_info.file = s;
		rdelete(ed.addr1, ed.addr2);
		append(getfile, ed.dot);
		exfile();
		remove(ed.tmpfile);
	}
	else {
		s = sfstruse(ed.buffer.line) + 1;
		if (f)
			putrec(s);
		if (!(ed.iop = sfpopen(NiL, s, "")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", s);
		if (sfclose(ed.iop)) {
			ed.iop = 0;
			error(ERROR_SYSTEM|2, "%s: shell command exit error", s);
		}
		if (ed.verbose)
			putrec("!");
	}
}

static void
edit(void)
{
	register off_t*	mp;

	if (ed.tmp) {
		sfclose(ed.tmp);
		ed.tmp = 0;
	}
	ed.tmpoff = 0;
	if (!(ed.tmp = sftmp(BLOCK_TMP)))
		error(ERROR_SYSTEM|3, "cannot create temp file");
	for (mp = ed.marks; mp < &ed.marks[elementsof(ed.marks)]; )
		*mp++ = LINE_NONE;
	ed.marked = 0;
	ed.event++;
	ed.dot = ed.dol = ed.zero;
	if (!ed.initialized) {
		ed.initialized = 1;
		if (ed.pending)
			ed.caught = ed.pending;
	}
}

static void
filename(int c)
{
	register char*	p;
	register int	sh = 0;

	ed.bytes = 0;
	ed.lines = 0;
	p = getrec(ed.buffer.line, '\n', REC_LINE);
	if (*p) {
		if (!isspace(*p))
			error(2, "no space after command");
		for (p++; isspace(*p); p++)
			;
		if (!*p)
			error(2, "file name expected");
		if (c != 'f') {
			if (*p == '!') {
				p++;
				sh = 1;
			}
			else if (*p == '\\' && *(p + 1) == '!')
				p++;
		}
		if (!sh && (!*sfstrbase(ed.buffer.file) || c == 'e' || c == 'f')) {
			sfstrset(ed.buffer.file, 0);
			sfputr(ed.buffer.file, p, 0);
		}
		if (c == 'f')
			return;
	}
	else if (c == 'f')
		return;
	else if (!*(p = sfstrbase(ed.buffer.file)))
		error(2, "file name expected");
	if (c == 'e') {
		edit();
		ed.addr2 = ed.zero;
	}
	if (sh) {
		if (!(ed.iop = sfpopen(NiL, p, (c == 'e' || c == 'r') ? "r" : "w")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", p);
		p--;
	}
	else if (c == 'e' || c == 'r') {
		if (!(ed.iop = sfopen(NiL, p, "r")))
			error(ERROR_SYSTEM|2, "%s: cannot read", p);
	}
	else if ((c != 'W' || !(ed.iop = sfopen(NiL, p, "a"))) && !(ed.iop = sfopen(NiL, p, "w")))
		error(ERROR_SYSTEM|2, "%s: cannot write", p);
	error_info.file = p;
}

static void
global(int sense, int query)
{
	register char*		s;
	register int		c;
	register Line_t*	a1;

	if (ed.global)
		error(2, "recursive global not allowed");
	setwide();
	squeeze(ed.dol > ed.zero);
	if ((c = getchr()) == '\n')
		error(2, "incomplete global expression");
	compile(c);
	if (query)
		newline();
	else {
		s = getrec(ed.buffer.global, '\n', REC_SPLICE|REC_TERMINATE);
		if (s[0] == '\n' && !s[1])
			sfputr(ed.buffer.global, "p\n", 0);
	}
	for (a1 = ed.zero; a1 <= ed.dol; a1++) {
		a1->offset &= ~LINE_GLOBAL;
		if (a1 >= ed.addr1 && a1 <= ed.addr2 && execute(a1) == sense)
			a1->offset |= LINE_GLOBAL;
	}

	/* special case: g/.../d (avoid n^2 algorithm) */

	if (!query && s[0] == 'd' && s[1] == '\n' && !s[2])
		gdelete();
	else {
		for (a1 = ed.zero; a1 <= ed.dol; a1++) {
			if (a1->offset & LINE_GLOBAL) {
				a1->offset &= ~LINE_GLOBAL;
				ed.dot = a1;
				if (query) {
					putrec(lineget(a1->offset));
					if ((c = getchr()) == EOF)
						break;
					else if (c == '\n')
						continue;
					else if (c == '&') {
						newline();
						if (!*(ed.global = sfstrbase(ed.buffer.query)))
							error(2, "no saved command");
					}
					else {
						ed.peekc = c;
						ed.global = getrec(ed.buffer.query, '\n', REC_TERMINATE);
					}
				}
				else
					ed.global = s;
				commands();
				a1 = ed.zero;
			}
		}
	}
}

static void
join(void)
{
	register Line_t*	a1;

	nonzero();
	sfstrset(ed.buffer.work, 0);
	for (a1 = ed.addr1; a1 <= ed.addr2;)
		sfputr(ed.buffer.work, lineget((a1++)->offset), -1);
	a1 = ed.dot = ed.addr1;
	replace(a1, sfstruse(ed.buffer.work));
	if (a1 < ed.addr2)
		rdelete(a1 + 1, ed.addr2);
}

static int
compsub(void)
{
	register int	seof;
	register int	c;

	seof = getchr();
	if (isspace(seof))
		error(2, "invalid or missing delimiter");
	compile(seof);
	sfstruse(ed.buffer.substitute);
	for (;;) {
		c = getchr();
		if (c == '\\') {
			sfputc(ed.buffer.substitute, c);
			c = getchr();
		}
		else if (c == '\n' || c == EOF) {
			if (!ed.global || !ed.global[0]) {
				ed.peekc = c;
				ed.print |= PRINT;
				break;
			}
		}
		else if (c == seof)
			break;
		else if (c == '%' && !sfstrtell(ed.buffer.substitute) && ((ed.peekc = getchr()) == '\n' || ed.peekc == EOF || ed.peekc == seof)) {
			if (!*sfstrbase(ed.buffer.substitute))
				error(2, "no saved replacement string");
			sfstrset(ed.buffer.substitute, sfstrsize(ed.buffer.substitute) - 1);
			continue;
		}
		sfputc(ed.buffer.substitute, c);
	}
	sfputc(ed.buffer.substitute, 0);
	if ((ed.peekc = getchr()) == 'g') {
		ed.peekc = 0;
		newline();
		return(-1);
	}
	c = getnum();
	newline();
	return(c);
}

static void
dosub(void)
{
	register char*	s;
	register int	c;
	register int	n;

	sfstrset(ed.buffer.work, 0);
	if (n = BEG(0) - CUR())
		sfwrite(ed.buffer.work, CUR(), n);
	s = sfstrbase(ed.buffer.substitute);
	while (c = *s++) {
		if (c == '&') {
			if (n = END(0) - BEG(0))
				sfwrite(ed.buffer.work, BEG(0), n);
			continue;
		}
		if (c == '\\') {
			c = *s++;
			if (c >= MATCH_MIN && c <= MATCH_MAX) {
				c -= MATCH_MIN;
				if (HIT(c) && (n = END(c) - BEG(c)))
					sfwrite(ed.buffer.work, BEG(c), n);
				continue;
			}
		}
		sfputc(ed.buffer.work, c);
	}
	n = sfstrtell(ed.buffer.work);
	sfputr(ed.buffer.work, END(0), 0);
	swap(Sfio_t*, ed.buffer.work, ed.buffer.line);
	SET(sfstrbase(ed.buffer.line) + n);
}

static void
substitute(int inglob)
{
	register Line_t*	a1;
	register int		m;
	int			g;
	int			n;

	n = getnum();
	g = compsub();
	if (g > 0) {
		if (n)
			error(2, "only one substitute count expected");
		n = g;
		g = 0;
	}
	for (a1 = ed.addr1; a1 <= ed.addr2; a1++) {
		if (execute(a1)){
			m = n;
			do {
				int	span = END(0) - BEG(0);

				if (--m <= 0) {
					dosub();
					if (!g)
						break;
					if (!span) {
						if (!*END(0))
							break;
						NXT();
					}
				}
			} while (execute(NiL));
			if (m <= 0) {
				char*	s;
				char*	e;

				inglob = 1;
				s = sfstrbase(ed.buffer.line);
				if (e = strchr(s, '\n'))
					*e++ = 0;
				replace(a1, s);
				if (e) {
					ed.linebreak = e;
					m = append(getbreak, a1);
					a1 += m;
					ed.addr2 += m;
				}
			}
		}
	}
	if (!inglob)
		error(2, "global pattern not found");
}

static void
reverse(register Line_t* a1, register Line_t* a2)
{
	modify();
	while (--a2 > a1) {
		a1->event = a2->event = ed.event;
		a2->undo = a2->offset;
		a2->offset = a1->undo = a1->offset;
		(a1++)->offset = a2->undo;
	}
}

static void
move(int cflag)
{
	register Line_t*	adt;
	register Line_t*	ad1;
	register Line_t*	ad2;

	nonzero();
	if (!(adt = address()))
		error(2, "invalid move destination");
	newline();
	if (cflag) {
		unsigned long	m;

		ad1 = ed.dol;
		m = append(getcopy, ad1++);
		ad2 = ed.dol;
		ad1 += m;
		adt += m;
	}
	else {
		ad2 = ed.addr2;
		for (ad1 = ed.addr1; ad1 <= ad2; ad1++)
			ad1->offset &= ~LINE_GLOBAL;
		ad1 = ed.addr1;
	}
	ad2++;
	if (adt < ad1) {
		ed.dot = adt + (ad2 - ad1);
		if (++adt == ad1)
			return;
		reverse(adt, ad1);
		reverse(ad1, ad2);
		reverse(adt, ad2);
	}
	else if (adt >= ad2) {
		ed.dot = adt++;
		reverse(ad1, ad2);
		reverse(ad2, adt);
		reverse(ad1, adt);
	}
	else
		error(2, "move would do nothing");
}

static void
commands(void)
{
	register Line_t*	a1;
	register int		c;
	register int		n;
	char*			s;
	int			lastsep;

	for (;;) {
		trap();
		if (ed.print) {
			ed.addr1 = ed.addr2 = ed.dot;
			print();
		}
		if (!ed.global) {
			ed.evented = 0;
			if (ed.prompt > 0)
				sfputr(ed.msg, sfstrbase(ed.buffer.prompt), -1);
		}
		if ((c = getchr()) == ',' || c == ';') {
			ed.given = 1;
			ed.addr1 = (lastsep = c) == ',' ? ed.zero + 1 : ed.dot;
			a1 = ed.dol;
			c = getchr();
		}
		else {
			ed.addr1 = 0;
			ed.peekc = c;
			c = '\n';
			for (;;) {
				lastsep = c;
				a1 = address();
				c = getchr();
				if (c != ',' && c != ';')
					break;
				if (lastsep == ',')
					error(2, "invalid address");
				if (!a1) {
					a1 = ed.zero + 1;
					if (a1 > ed.dol)
						a1--;
				}
				ed.addr1 = a1;
				if (c == ';')
					ed.dot = a1;
			}
			if (lastsep != '\n' && !a1)
				a1 = ed.dol;
		}
		if (!(ed.addr2 = a1)) {
			ed.given = 0;
			ed.addr2 = ed.dot;	
		}
		else
			ed.given = 1;
		if (!ed.addr1)
			ed.addr1 = ed.addr2;
		switch (c) {

		case 'a':
			add(0);
			continue;

		case 'c':
			nonzero();
			newline();
			rdelete(ed.addr1, ed.addr2);
			append(getline, ed.addr1 - 1);
			continue;

		case 'd':
			nonzero();
			newline();
			rdelete(ed.addr1, ed.addr2);
			continue;

		case 'E':
			ed.modified = 0;
			c = 'e';
			/*FALLTHROUGH*/
		case 'e':
			setnoaddr();
			if (ed.verbose && ed.modified) {
				ed.modified = 0;
				error(2, "modified data not written");
			}
			/*FALLTHROUGH*/
		case 'r':
			filename(c);
			setwide();
			squeeze(0);
			c = ed.zero != ed.dol;
			append(getfile, ed.addr2);
			ed.modified = c;
			exfile();
			continue;

		case 'f':
			setnoaddr();
			filename(c);
			putrec(sfstrbase(ed.buffer.file));
			continue;

		case 'G':
			global(1, 1);
			continue;

		case 'g':
			global(1, 0);
			continue;

		case 'H':
			ed.help = !ed.help;
			/*FALLTHROUGH*/
		case 'h':
			setnoaddr();
			newline();
			if (ed.help || c == 'h')
				sfputr(ed.msg, sfstrbase(ed.buffer.help), '\n');
			continue;

		case 'i':
			add(-1);
			continue;

		case 'j':
			if (!ed.given)
				ed.addr2++;
			newline();
			join();
			continue;

		case 'k':
			nonzero();
			if ((c = getchr()) == EOF || (c -= MARK_MIN) < 0 || c >= elementsof(ed.marks))
				error(2, "invalid mark");
			newline();
			ed.addr2->offset |= LINE_MARKED;
			ed.marks[c] = ed.addr2->offset & ~LINE_GLOBAL;
			ed.marked = 1;
			continue;

		case 'm':
			move(0);
			continue;

		case 'n':
			ed.print |= PRINT_NUMBER;
			newline();
			print();
			continue;

		case '\n':
			if (!a1) {
				a1 = ed.dot + 1;
				ed.addr2 = a1;
				ed.addr1 = a1;
			}
			if (lastsep == ';')
				ed.addr1 = a1;
			print();
			continue;

		case 'l':
			ed.print |= PRINT_LIST;
			/*FALLTHROUGH*/
		case 'p':
			newline();
			print();
			continue;

		case 'P':
			setnoaddr();
			s = getrec(ed.buffer.line, '\n', 0);
			if (*s || !(ed.prompt = -ed.prompt) && (s = "*")) {
				sfstrset(ed.buffer.prompt, 0);
				sfputr(ed.buffer.prompt, s, 0);
				ed.prompt = 1;
			}
			continue;

		case 'Q':
			ed.modified = 0;
			/*FALLTHROUGH*/
		case 'q':
			setnoaddr();
			newline();
			quit(0);
			continue;

		case 'S':
			setnoaddr();
			newline();
			sfprintf(ed.msg, "file=\"%s\"%s%s%s prompt=\"%s\" tmp=%lu%s event=%lu version=%s\n", sfstrbase(ed.buffer.file), ed.modified ? " modified" : "", ed.help ? " help" : "", ed.verbose ? " verbose" : "", sfstrbase(ed.buffer.prompt), ed.tmpoff, ed.tmpoff > BLOCK_TMP ? "[file]" : "", ed.event, strrchr(id, ' ') + 1);
			continue;

		case 's':
			nonzero();
			substitute(ed.global != 0);
			continue;

		case 't':
			move(1);
			continue;

		case 'u':
			setnoaddr();
			newline();
			undo();
			continue;

		case 'V':
			global(0, 1);
			continue;

		case 'v':
			global(0, 0);
			continue;

		case 'W':
		case 'w':
			setwide();
			squeeze(ed.dol > ed.zero);
			if ((n = getchr()) != 'q' && n != 'Q') {
				ed.peekc = n;
				n = 0;
			}
			filename(c);
			if (ed.dol > ed.zero)
				putfile();
			exfile();
			if (n == 'Q' || ed.addr1 <= ed.zero + 1 && ed.addr2 == ed.dol)
				ed.modified = 0;
			if (n)
				quit(0);
			continue;

		case 'z':
			nonzero();
			page();
			continue;

		case '=':
			setwide();
			squeeze(0);
			newline();
			sfprintf(ed.msg, "%d\n", ed.addr2 - ed.zero);
			continue;

		case '!':
			shell();
			continue;

		case '#':
			setnoaddr();
			getrec(ed.buffer.line, '\n', REC_IGNORE);
			continue;

		case EOF:
			return;

		}
		error(2, "unknown command");
	}
}

int
main(int argc, char** argv)
{
	NoP(argc);
	error_info.id = "ed";
	error_info.write = helpwrite;
	init();
	for (;;)
	{
		for (;;) {
			switch (optget(argv, "hop:[prompt]qs [file]")) {

			case 'h':
				ed.help = 1;
				continue;

			case 'o':
				ed.msg = sfstderr;
				sfstrset(ed.buffer.file, 0);
				sfputr(ed.buffer.file, "/dev/stdout", 0);
				continue;

			case 'p':
				sfstrset(ed.buffer.prompt, 0);
				sfputr(ed.buffer.prompt, opt_info.arg, 0);
				ed.prompt = 1;
				continue;

			case 'q':
				signal(SIGQUIT, SIG_DFL);
				ed.verbose = 1;
				continue;

			case 's':
				ed.verbose = 0;
				continue;

			case 0:
				break;

			case '?':
				error(ERROR_USAGE|4, opt_info.arg);
				break;

			case ':':
				error(2, opt_info.arg);
				break;

			}
			break;
		}
		if (!*(argv += opt_info.index) || **argv != '-' || *(*argv + 1))
			break;
		ed.verbose = 0;
	}
	if (*argv) {
		if (*(argv + 1))
			error(ERROR_USAGE|4, opt_info.arg);
		sfprintf(ed.buffer.global, "e %s", *argv);
		ed.global = sfstruse(ed.buffer.global);
	}
	edit();
	sfslowio(sfstdin);
	setjmp(ed.again);
	commands();
	quit(0);
	exit(0);
}
#pragma prototyped

#include <ast.h>
#include <ctype.h>
#include <error.h>
#include <regex.h>

static const char id[] = "\n@(#)grep (AT&T Research) 01/01/96\0\n";

/*
 * snarfed from Doug McElroy's C++ version
 *
 * this grep is based on the Posix re package.
 * unfortunately it has to have a nonstandard interface.
 * 1. fgrep does not have usual operators. REG_LITERAL
 * caters for this.
 * 2. grep allows null expressions, hence REG_NULL.
 * 3. it may be possible to combine the multiple 
 * patterns of grep into single patterns.  important
 * special cases are handled by regcomb().
 * 4. anchoring by -x has to be done separately from
 * compilation (remember that fgrep has no ^ or $ operator),
 * hence REG_LEFT|REG_RIGHT.  (An honest, but slow alternative:
 * run regexec with REG_NOSUB off and nmatch=1 and check
 * whether the match is full length)
 */

typedef struct Item			/* list item			*/
{
	struct Item*	next;		/* next in list			*/
	union
	{
	regex_t		re;		/* re value - sue me for waste	*/
	char*		string;		/* string value			*/
	}		value;
} Item_t;

typedef struct				/* generic list			*/
{
	Item_t*		head;		/* list head			*/
	Item_t*		tail;		/* list tail			*/
} List_t;

static struct				/* program state		*/
{
	List_t		files;		/* pattern file list		*/
	List_t		patterns;	/* pattern list			*/
	List_t		res;		/* re list			*/

	int		code;		/* no hits exit code		*/
	int		hits;		/* if any patterns hit		*/
	int		options;	/* regex options		*/

	unsigned char	count;		/* count number of hits		*/
	unsigned char	list;		/* list files with hits		*/
	unsigned char	match;		/* match sense			*/
	unsigned char	query;		/* return status but no output	*/
	unsigned char	number;		/* line numbers			*/
	unsigned char	prefix;		/* print file prefix		*/
	unsigned char	suppress;	/* no unopenable file messages	*/
} state;

static void
fatal(int result)
{
	char	buf[128];

	if (result && result != REG_NOMATCH)
	{
		regerror(result, 0, buf, sizeof(buf));
		error(3, "%s", buf);
	}
}

static void
addre(List_t* p, char* s)
{
	int	result;
	Item_t*	x;

	if (!(x = newof(0, Item_t, 1, 0)))
		error(ERROR_SYSTEM|3, "out of space (pattern `%s')", s);
	if (result = regcomp(&x->value.re, s, state.options))
		fatal(result);
	if (!p->head)
		p->head = p->tail = x;
	else if (regcomb(&p->tail->value.re, &x->value.re))
		p->tail = p->tail->next = x;
	else free(x);
}

static void
addstring(List_t* p, char* s)
{
	Item_t*	x;

	if (!(x = newof(0, Item_t, 1, 0)))
		error(ERROR_SYSTEM|3, "out of space (string `%s')", s);
	x->value.string = s;
	if (p->head) p->tail->next = x;
	else p->head = x;
	p->tail = x;
}

/*
 * the update s = t+1 flagged below is formally illegal when
 * t==0, but what run-time system will catch it?
 */

static void
compile(void)
{
	int	i;
	int	line;
	char*	s;
	char*	t;
	char*	file;
	Item_t*	x;
	Sfio_t*	f;

	for (x = state.patterns.head; x; x = x->next)
		for (t = s = x->value.string; t; s = t + 1) /* see above */
		{
			if (t = strchr(s, '\n'))
				*t = 0;
			addre(&state.res, s);
		}	
	for (x = state.files.head; x; x = x->next)
	{
		s = x->value.string;
		if (f = sfopen(NiL, s, "r"))
		{
			file = error_info.file;
			error_info.file = s;
			line = error_info.line;
			error_info.line = 0;
			while (s = sfgetr(f, '\n', 1))
			{
				error_info.line++;
				addre(&state.res, s);
			}
			error_info.file = file;
			error_info.line = line;
			sfclose(f);
		}
		else if (!state.suppress)
			error(ERROR_SYSTEM|4, "%s: cannot open", s);
		else state.code = 2;
	}
	if (!(x = state.res.head))
		error(3, "no pattern#1");
}

static void
execute(Sfio_t* input, char* name)
{
	char*		s;
	char*		file;
	Item_t*		x;
	int		result;
	int		line;
	unsigned long	hits = 0;
	
	file = error_info.file;
	if (!(error_info.file = name))
		name = "(standard input)";
	line = error_info.line;
	error_info.line = 0;
	while (s = sfgetr(input, '\n', 1))
	{
		error_info.line++;
		for (x = state.res.head; x; x = x->next)
		{
			if (!(result = regexec(&x->value.re, s, 0, 0, 0)))
				break;
			if (result != REG_NOMATCH)
				fatal(result);
		}
		if ((x != 0) == state.match)
		{
			hits++;
			if (state.query || state.list)
				break;
			if (state.count)
				continue;
			if (state.prefix)
				sfprintf(sfstdout, "%s:", name);
			if (state.number)
				sfprintf(sfstdout, "%d:", error_info.line);
			sfprintf(sfstdout, "%s\n", s);
		}
	}
	error_info.file = file;
	error_info.line = line;
	if (hits)
	{
		state.hits = 1;
		if (state.query)
			return;
		if (state.list)
			sfprintf(sfstdout, "%s\n", name);
	}
	if (!state.list && state.count)
	{
		if (state.prefix)
			sfprintf(sfstdout, "%s:", name);
		sfprintf(sfstdout, "%d\n", hits);
	}
}

main(int argc, char** argv)
{
	int	c;
	char*	s;
	Sfio_t*	f;

	state.match = 1;
	state.options = REG_NOSUB|REG_NULL;
	state.code = 1;
	if (s = strrchr(argv[0], '/')) s++;
	else s = argv[0];
	switch (*s)
	{
	case 'a':
	case 'A':
		s = "agrep";
		state.options |= REG_AUGMENTED;
		break;
	case 'e':
	case 'E':
		s = "egrep";
		state.options |= REG_EXTENDED;
		break;
	case 'f':
	case 'F':
		s = "fgrep";
		state.options |= REG_LITERAL;
		break;
	default:
		s = "grep";
		break;
	}
	error_info.id = s;
	while (c = optget(argv, "AEFchilqnsvxe:[pattern]f:[file] [file ...]"))
		switch (c)
		{
		case 'A':
			state.options |= REG_AUGMENTED;
			break;
		case 'E':
			state.options |= REG_EXTENDED;
			break;
		case 'F':
			state.options |= REG_LITERAL;
			break;
		case 'c':
			state.count = 1;
			break;
		case 'e':
			addstring(&state.patterns, opt_info.arg);
			break;
		case 'f':
			addstring(&state.files, opt_info.arg);
			break;
		case 'h':
			state.prefix = 0;
			break;
		case 'i':
			state.options |= REG_ICASE;
			break;
		case 'l':
			state.list = 1;
			break;
		case 'n':
			state.number = 1;
			break;
		case 'q':
			state.query = 1;
			break;
		case 's':
			state.suppress = 1;
			break;
		case 'v':
			state.match = 0;
			break;
		case 'x':
			state.options |= REG_LEFT|REG_RIGHT;
			break;
		case '?':
			error(ERROR_USAGE|4, opt_info.arg);
			break;
		case ':':
			error(2, opt_info.arg);
			break;
		}
	argv += opt_info.index;
	if ((state.options & (REG_AUGMENTED|REG_LITERAL)) == (REG_AUGMENTED|REG_LITERAL))
		error(3, "-A and -F are incompatible");
	if ((state.options & (REG_EXTENDED|REG_LITERAL)) == (REG_EXTENDED|REG_LITERAL))
		error(3, "-E and -F are incompatible");
	if (!state.files.head && !state.patterns.head)
	{
		if (!argv[0])
			error(3, "no pattern");
		addstring(&state.patterns, *argv++);
	}
	compile();
	if (!argv[0])
		execute(sfstdin, NiL);
	else
	{
		if (!state.prefix && argv[1])
			state.prefix = 1;
		while (s = *argv++)
		{
			if (f = sfopen(NiL, s, "r"))
			{
				execute(f, s);
				sfclose(f);
			}
			else if (!state.suppress)
				error(ERROR_SYSTEM|4, "%s: cannot open", s);
			else state.code = 2;
			if (state.query && state.hits)
				break;
		}
	}
	exit(state.hits ? 0 : state.code);
}
#pragma prototyped

#include <ast.h>
#include <error.h>

#include "regex.h"

typedef unsigned char uchar;

typedef struct {
	uchar *w;		/* write pointer */
	uchar *e;		/* end */
	uchar *s;		/* start */
} Text;

extern void compile(Text *script, Text *raw);
extern void execute(Text *script, Text *input);
extern int recomp(Text *script, Text *t, int seof);
extern int match(uchar *re, Text *data, int gflag);
extern int substitute(regex_t*, Text* data, uchar *rhs, int gf);
extern regex_t *readdr(int addr);
extern void tcopy(Text *from, Text *to);
void printscript(Text *script);
extern void vacate(Text*);
extern void synwarn(char*);
extern void syntax(char*);
extern int readline(Text*);
extern int ateof(void);
extern void coda(void);

#define exch(a, b, t) ((t)=(a), (a)=(b), (b)=(t))
	
	/* space management; assure room for n more chars in Text */
#define assure(/*Text*/t, /*int*/ n) 		\
	do if((t)->s==0 || (t)->w>=(t)->e-n-1) grow(t, n);while(0)
extern void grow(Text*, int);

	/* round character pointer up to integer pointer.
	   portable to the cray; simpler tricks are not */

#define intp(/*uchar**/p) (int*)(p + sizeof(int) - 1 \
			- (p+sizeof(int)-1 - (uchar*)0)%sizeof(int))

extern int reflags;
extern int recno;
extern int nflag;
extern int qflag;
extern int sflag;
extern int bflag;
extern char *stdouterr;

extern Text files;

/* SCRIPT LAYOUT

   script commands are packed thus:
   0,1,or2 address words signed + for numbers - for regexp
   if 2 addresses, then another word indicates activity
	positive: active, the record number where activated
	negative: inactive, sign or-ed with number where deactivated
   instruction word
	high byte IMASK+flags; flags are NEG and SEL
	next byte command code (a letter)
	next two bytes, length of this command, including addrs
        (length is a multiple of 4; capacity could be expanded
	by counting the length in words instead of bytes)
   after instruction word
	on s command
		offset of regexp in rebuf
		word containing flags p,w plus n (g = >n=0)
		replacement text
		word containing file designator, if flag w
	on y command
		256-byte transliteration table
	on b and t command
		offset of label in script
*/

#define BYTE		CHAR_BIT
#define IMASK		0xC0000000	/* instruction flag */
#define NEG  		0x01000000	/* instruction written with ! */
#define LMASK		0xffff		/* low half word */
#define AMASK		0x7fffffff	/* address mask, clear sign bit */
#define INACT		(~AMASK)	/* inactive bit, the sign bit */
#define DOLLAR		AMASK		/* huge address */
#define REGADR		(~AMASK)	/* context address */
#define PFLAG		0x80000000	/* s/../../p */
#define WFLAG		0x40000000	/* s/../../g */

extern int pack(int neg, int cmd, int length);
extern int *instr(uchar*);
#define code(/*int*/ inst) ((inst)>>2*BYTE & 0xff)
#define nexti(/*uchar**/ p) ((p) + (*instr(p)&LMASK))
#pragma prototyped

#include "sed.h"

static const char id[] = "\n@(#)sed (AT&T Research) 01/01/96\0\n";

void	readscript(Text*, char*);
void	copyscript(Text*, uchar*);
void	initinput(int, char **);
Sfio_t*	aopen(char*);

#define ustrncmp(a,b,c) (uchar*)strncmp((char*)(a), (char*)(b), c)

int reflags;		/* regcomp() flags */
int recno;		/* current record number */
int nflag;		/* nonprint option */
int qflag;		/* command q executed */
int sflag;		/* substitution has occurred */
int bflag;		/* strip leading blanks from c,a,i <text> */

main(int argc, char **argv)
{
	int c;
	static Text script;
	static Text data;
	error_info.id = "sed";
	while (c = optget(argv, "bdne:[expression]f:[script]AE [file ...]"))
		switch (c)
		{
		case 'A':
			reflags |= REG_AUGMENTED;
			break;
		case 'E':
			reflags |= REG_EXTENDED;
			break;
		case 'b':
			bflag++;
			break;
		case 'e':
			copyscript(&data, (uchar*)opt_info.arg);
			break;
		case 'f':
			readscript(&data, opt_info.arg);
			break;
		case 'n':
			nflag++;
			break;
		case '?':
			error(ERROR_USAGE|4, opt_info.arg);
			break;
		case ':':
			error(2, opt_info.arg);
			break;
		}
	if (error_info.errors)
		error(ERROR_USAGE|4, optusage(NiL));
	argv += opt_info.index;
	argc -= opt_info.index;
	if(data.s == 0) {
		if(!*argv)
			error(3, "no script");
		copyscript(&data, (uchar*)*argv++);
		argc--;
	}
	if(ustrncmp(data.s, "#n", 2) == 0)
		nflag = 1;
	copyscript(&data, (uchar*)"\n\n");  /* e.g. s/a/\ */
	compile(&script, &data);
#if DEBUG
	printscript(&script);
#endif

	initinput(argc, argv);
	for(;;) {
		data.w = data.s;
		if(!readline(&data))
			break;
		execute(&script, &data);
	}
	if(sfclose(sfstdout) == EOF)
		error(3, stdouterr);
	return 0;
}

void
grow(Text *t, int n)
{
	int w = t->w - t->s;
	int e = t->e - t->s + (n/SF_BUFSIZE+1)*SF_BUFSIZE;
	t->s = (uchar*)realloc(t->s, e);
	if(t->s == 0)
		error(3, "out of space");
	t->w = t->s + w;
	t->e = t->s + e;
}

/* BUG: a segment that ends with a comment whose
   last character is \ causes a diagnostic */

void
safescript(Text *t)
{
	if(t->w > t->s+1 && t->w[-2] == '\\')
		error(1, "script segment ends with \\");
}

void
readscript(Text *t, char *s)
{
	int n;
	Sfio_t *f = aopen(s);
	for(;;) {
		assure(t, 4);
		n = sfread(f, t->w, t->e - t->w - 3);
		if(n <= 0)
			break;
		t->w += n;
	}
	sfclose(f);
	if(t->w > t->s && t->w[-1] != '\n') {
		*t->w++ = '\n';
		error(1, "newline appended to script segment");
	}
	*t->w = 0;
	safescript(t);
}

void
copyscript(Text *t, uchar *s)
{
	do {
		assure(t, 2);
	} while(*t->w++ = *s++);
	if(--t->w > t->s && t->w[-1] != '\n') {
		*t->w++ = '\n';
		*t->w = 0;
	}
	safescript(t);
}

/* DATA INPUT */

struct {
	int iargc;		/* # of files not fully read */
	char **iargv;		/* current file */
	Sfio_t *ifile;		/* current input file */
} input;

int
readline(Text *t)
{
	char*	s;
	int	c;

	coda();
	if (qflag || ateof())
		return 0;
	while (!(s = sfgetr(input.ifile, '\n', 1)))
	{
		if (s = sfgetr(input.ifile, '\n', -1))
		{
			error(1, "newline appended");
			break;
		}
		error_info.file = 0;
		error_info.line = 0;
		if (--input.iargc <= 0)
			return 0;
		sfclose(input.ifile);
		input.ifile = aopen(*++input.iargv);
		error_info.file = *input.iargv;
	}
	c = sfslen();
	assure(t, c);
	memcpy(t->w, s, c);
	t->w += c - 1;

	/*
	 * peek ahead to identify line $
	 */

	if ((c = sfgetc(input.ifile)) != EOF)
		sfungetc(input.ifile, c);
	else if (input.iargc == 1)
		input.iargc = 0;
	error_info.line++;
	recno++;
	sflag = 0;
	return 1;
}	

int 
ateof(void)
{
	return input.iargc <= 0;
}	

void
initinput(int argc, char **argv)
{
	input.iargc = argc;
	input.iargv = argv;
	if(input.iargc == 0) {
		input.iargc = 1;	/* for ateof() */
		input.ifile = sfstdin;
	} else {
		input.ifile = aopen(*input.iargv);
		error_info.file = *input.iargv;
	}
}

Sfio_t *
aopen(char *s)
{
	Sfio_t *f = sfopen(NiL, s, "r");
	if(f == 0)
		error(ERROR_SYSTEM|3, "%s: cannot open", s);
	return f;
}

#if DEBUG & 1

/* debugging code 1; compile and execute stubs.
   simply prints the already collected script and
   prints numbered input lines */

void
compile(Text *script, Text *t)
{
	uchar *s = t->s;
	assure(script, 1);
	*script->w++ = 0;
	while(*s) sfputc(sfstdout, *s++);
}

void
execute(Text *x, Text *y)
{
	x = x;		
	sfprintf(sfstdout, "%d: %s", recno, y->s);
}

#endif
#pragma prototyped

#include "sed.h"

#include <ctype.h>

#define ustrlen(p) strlen((char*)(p))
#define ustrcmp(p, q) strcmp((char*)(p), (char*)(q))
#define ustrcpy(p, q) (uchar*)strcpy((char*)(p), (char*)(q))
#define ustrchr(p, c) (uchar*)strchr((char*)(p), c)

int blank(Text*);
void fixlabels(Text*);
void fixbrack(Text*);
void ckludge(Text*, int, int, int, Text*);
int addr(Text*, Text*);
int pack(int, int, int);
int* instr(uchar*);
uchar *succi(uchar*);

#if DEBUG
extern void regdump(regex_t*);	/* secret entry into regex pkg */
#endif

int semicolon;
Text rebuf;

uchar adrs[256] = {	/* max no. of addrs, 3 is illegal */
	0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, /* <nl> */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 2, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* !# */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 1, 3, 3, /* := */
	3, 3, 3, 3, 2, 3, 3, 2, 2, 3, 3, 3, 3, 3, 2, 3, /* DGHN */
	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* P */
	3, 1, 2, 2, 2, 3, 3, 2, 2, 1, 3, 3, 2, 3, 2, 3, /* a-n */
	2, 1, 2, 2, 2, 3, 3, 2, 2, 2, 3, 2, 3, 0, 3, 3, /* p-y{} */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
};

#define Ec Tc	/* commands that have same compilation method */
#define Dc Tc
#define Gc Tc
#define Hc Tc
#define Nc Tc
#define Pc Tc
#define dc Tc
#define gc Tc
#define hc Tc
#define lc Tc
#define nc Tc
#define pc Tc
#define qc Tc
#define xc Tc
#define tc bc
#define ic ac
#define cc ac

uchar *synl;	/* current line pointer for syntax errors */

/* COMMAND LAYOUT */

int
blank(Text *t)
{
	if(*t->w==' ' || *t->w=='\t') {
		t->w++;
		return 1;
	} else
		return 0;
}

int *
instr(uchar *p)		/* get address of command word */
{
	int *q = (int*)p;
	while((*q & IMASK) != IMASK)
		q++;
	return q;
}

uchar *
succi(uchar *p)
{
	int *q = instr(p);
	if(code(*q) == '{')
		return (uchar*)(q+1);
	else
		return p + (*q & LMASK);
}

int
pack(int neg, int cmd, int length)
{
	int l = length & LMASK;
	if(length != l)
		syntax("<command-list> or <text> too long");
	return IMASK | neg | cmd << 2*BYTE | l;
}

void
putint(Text *s, int n)
{
	assure(s, sizeof(int));
	*(int*)s->w = n;
	s->w += sizeof(int);
}

int
number(Text *t)
{
	unsigned n = 0;
	while(isdigit(*t->w)) {
		if(n > (INT_MAX-9)/10)
			syntax("number too big");
		n = n*10 + *t->w++ - '0';
	}
	return n;
}	

int
addr(Text *script, Text *t)
{
	int n;
	switch(*t->w) {
	default:
		return 0;
	case '$':
		t->w++;
		n = DOLLAR;
		break;
	case '\\':
		t->w++;
		if(*t->w=='\n' ||*t->w=='\\')
			syntax("bad regexp delimiter");
	case '/':
		n = recomp(&rebuf, t, *t->w++) | REGADR;
		break;
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		n = number(t);
		if(n == 0)
			syntax("address is zero");
	}
	putint(script, n);
	return 1;
}

regex_t *
readdr(int x)
{
	return (regex_t*)(rebuf.s + (x&AMASK));
}

/* LABEL HANDLING */

/* the labels array consists of int values followed by strings.
   value -1 means unassigned; other values are relative to the
   beginning of the script 

   on the first pass, every script ref to a label becomes the
   integer offset of that label in the labels array, or -1 if
   it is a branch to the end of script

   on the second pass (fixlabels), the script ref is replaced
   by the value from the labels array. */

Text labels;

int *
lablook(uchar *l, Text *labels)
{
	uchar *p, *q;
	int n;
	assure(labels, 1);
	for(p = labels->s; p < labels->w; ) {
		q = p + sizeof(int);
		if(ustrcmp(q, l) == 0)
			return (int*)p;
		q += ustrlen(q) + 1;
		p = (uchar*)intp(q);
	}
	n = ustrlen(l);
	assure(labels, sizeof(int)+n+1+sizeof(int));
	*(int*)p = -1;
	q = p + sizeof(int);
	ustrcpy(q, l);
	q += ustrlen(q) + 1;
	labels->w = (uchar*)intp(q);
	return (int*)p;
}

/* find pos in label list; assign value i to label if i>=0 */

int
getlab(Text *t, int i)
{
	int *p;
	uchar *u;
	while(blank(t));	/* not exactly posix */
	for(u=t->w; *t->w!='\n'; t->w++)
		if(!isprint(*t->w) || *t->w==' ')
			synwarn("invisible character in name");
	if(u == t->w)
		return -1;
	*t->w = 0;
	p = lablook(u, &labels);
	if(*p == -1)
		*p = i;
	else if(i != -1)
		syntax("duplicate label");
	*t->w = '\n';
	return (uchar*)p - labels.s;
}

void
Cc(Text *script, Text *t)	/* colon */
{
	if(getlab(t, script->w - sizeof(int) - script->s) == -1)
		syntax("missing label");
}

void
bc(Text *script, Text *t)
{
	int g;
	g = getlab(t, -1);	/* relative pointer to label list */
	putint(script, g);
}
			
void
fixlabels(Text *script)
{
	uchar *p;
	int *q;
	for(p=script->s; p<script->w; p=succi(p)) {
		q = instr(p);
		switch(code(*q)) {
		case 't':
		case 'b':
			if(q[1] == -1)
				q[1] = script->w - script->s;
			else if(*(int*)(labels.s+q[1]) != -1)
				q[1] = *(int*)(labels.s+q[1]);
			else
				error(3, "undefined label: %s",
					labels.s+q[1]+sizeof(int));
		}
	}
	free(labels.s);
}

/* FILES */

Text files;

void
rc(Text *script, Text *t)
{
	uchar *u;
	if(!blank(t))
		synwarn("no space before file name");
	while(blank(t)) ;
	for(u=t->w; *t->w!='\n'; t->w++) ;
	if(u == t->w)
		syntax("missing file name");
	*t->w = 0;
	putint(script, (uchar*)lablook(u, &files) - files.s);
	*t->w = '\n';
}

void
wc(Text *script, Text *t)
{
	int *p;
	rc(script, t);
	p = (int*)(files.s + ((int*)script->w)[-1]);
	if(*p != -1)
		return;
	*(Sfio_t**)p = sfopen(NiL, (char*)(p+1), "w");
	if(*p == 0)
		syntax("can't open file for writing");
}

/* BRACKETS */

Text brack;

/* Lc() stacks (in brack) the location of the { command word.
   Rc() stuffs into that word the offset of the } sequel
   relative to the command word.
   fixbrack() modifies the offset to be relative to the
   beginning of the instruction, including addresses. */

void				/* { */
Lc(Text *script, Text *t)
{
	while(blank(t));
	putint(&brack, script->w - sizeof(int) - script->s);
}

void				/* } */
Rc(Text *script, Text *t)
{
	int l;
	int *p;
	t = t;
	if(brack.w == 0 || (brack.w-=sizeof(int)) < brack.s)
		syntax("unmatched }");
	l = *(int*)brack.w;
	p = (int*)(script->s + l);
	l = script->w - script->s - l;
	if(l >= LMASK - 3*sizeof(int))	/* fixbrack could add 3 */
		syntax("{command-list} too long)");
	*p = (*p&~LMASK) | l;
}

void
fixbrack(Text *script)
{
	uchar *p;
	int *q;
	if(brack.w == 0)
		return;
	if(brack.w > brack.s)
		syntax("unmatched {");
	for(p=script->s; p<script->w; p=succi(p)) {
		q = instr(p);
		if(code(*q) == '{')
			*q += (uchar*)q - p;
	}
	free(brack.s);
}

/* EASY COMMANDS */

void
Xc(Text *script, Text *t)	/* # */
{
	script = script;	/* avoid use/set diagnostics */
	if(t->s[1]=='n')
		nflag = 1;
	while(*t->w != '\n')
		t->w++;
}

void
Ic(Text *script, Text *t)	/* ignore */
{
	script = script;
	t->w--;
}

void
Tc(Text *script, Text *t)	/* trivial to compile */
{
	script = script;
	t = t;
}

void
xx(Text *script, Text *t)
{
	script = script;
	t = t;
	syntax("unknown command");
}

/* MISCELLANY */

void
ac(Text *script, Text *t)
{
	if(*t->w++ != '\\' || *t->w++ != '\n')
		syntax("\\<newline> missing after command");
	for(;;) {
		while(bflag && blank(t)) ;
		assure(script, 2 + sizeof(int));
		switch(*t->w) {
		case 0:
			error(ERROR_PANIC|4, "bug: missed end of <text>");
		case '\n':
			*script->w++ = *t->w;
			*script->w++ = 0;
			script->w = (uchar*)intp(script->w);
			return;
		case '\\':
			t->w++;
		default:
			*script->w++ = *t->w++;
		}
	}
}
void
yc(Text *script, Text *t)
{
	int i;
	int delim = *t->w++;
	uchar *s = script->w;
	uchar *p, *q;
	if(delim == '\n' || delim=='\\')
		syntax("missing delimiter");
	assure(script, 256);
	for(i=0; i<256; i++) 
		s[i] = 0;
	for(q=t->w; *q!=delim; q++)
		if(*q == '\n')
			syntax("missing delimiter");
		else if(*q=='\\' && q[1]==delim)
			q++;
	for(p=t->w, q++; *p != delim; p++, q++) {
		if(*p=='\\' && p[1]==delim)
			p++;
		if(*q == '\n')
			syntax("missing delimiter");
		if(*q == delim)
			syntax("string lengths differ");
		if(*q=='\\' && q[1]==delim)
			q++;
		if(s[*p] && s[*p]!=*q)
			syntax("ambiguous map");
		if(s[*p])
			synwarn("redundant map");
		s[*p] = *q;
	}
	if(*q++ != delim)
		syntax("string lengths differ");
	for(i=0; i<256; i++)
		if(s[i] == 0)
			s[i] = i;
	t->w = q;
	script->w += 256;
}

void
sc(Text *script, Text *t)
{
	int c, flags, re, nsub;
	int *q;
	int n = -1;
	int delim = *t->w++;
	switch(delim) {
	case '\n':
	case '\\':
		syntax("improper delimiter");
	}
	re = recomp(&rebuf, t, delim);
	putint(script, re);
	nsub = readdr(re)->re_nsub;
	flags = script->w - script->s;
	putint(script, 0);		/* space for flags */
	while((c=*t->w++) != delim) {
		assure(script, 3+sizeof(int*));
		if(c == '\n')
			syntax("unterminated command");
		else if(c == '\\') {
			int d = *t->w++;
			if(d==delim)
				;
			else if(d=='&' || d=='\\')
				*script->w++ = c;
			else if(d>='0' && d<='9') {
				if(d > '0'+nsub)
					syntax("improper backreference");
				*script->w++ = c;
			}
			c = d;
		}
		*script->w++ = c;
	}
	*script->w++ = 0;
	script->w = (uchar*)intp(script->w);
	q = (int*)(script->s + flags);
	*q = 0;
	for(;;) {
		switch(*t->w) {
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			if(n != -1)
				syntax("extra flags");
			n = number(t);
			if(n == 0 || (n&(PFLAG|WFLAG)) != 0)
				syntax("count out of range");
			continue;
		case 'p':
			if(*q & PFLAG)
				syntax("extra flags");
			t->w++;
			*q |= PFLAG;
			continue;
		case 'g':
			t->w++;
			if(n != -1)
				syntax("extra flags");
			n = 0;
			continue;
		case 'w':
			t->w++;
			*q |= WFLAG;	 
			wc(script, t);
		}
		break;
	}
	*q |= n==-1? 1: n;
}		

void
synwarn(char *s)
{
	uchar *t = ustrchr(synl, '\n');
	error(1, "%s: %.*s", s, t-synl, synl);
}

void
syntax(char *s)
{
	uchar *t = ustrchr(synl, '\n');
	error(3, "%s: %.*s", s, t-synl, synl);
}

#if DEBUG

void
printscript(Text *script)
{
	uchar *s;
	int *q;
	for(s=script->s; s<script->w; s = succi(s)) {
		q = (int*)s;
		if((*q&IMASK) != IMASK) {
			if((*q&REGADR) == 0)
				printf("%d", *q);
			else
				regdump((regex_t*)(*q & AMASK));
			q++;
		}
		if((*q&IMASK) != IMASK) {
			if((*q&REGADR) == 0)
				printf(",%d", *q);
			else
				regdump((regex_t*)(*q & AMASK));
			q += 2;
		}
		if(code(*q) == '\n')
			continue;
		printf("%s%c\n", *q&NEG?"!":"", code(*q));
	}	
}

#endif

#if DEBUG & 2

/* debugging code 2; execute stub.
   prints the compiled script (without arguments)
   then each input line with line numbers */

void
execute(Text *script, Text *y)
{
	if(recno == 1)
		printscript(script);
	printf("%d:%s",recno,y->s);
}

#endif

typedef void (*cmdf)(Text*, Text*);

static cmdf docom[128] = {
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,Ic,xx,xx,xx,xx,xx, /* <nl> */
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,
	xx,Ic,xx,Xc,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx, /* !# */
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,Cc,Ic,xx,Ec,xx,xx, /* :;= */
	xx,xx,xx,xx,Dc,xx,xx,Gc,Hc,xx,xx,xx,xx,xx,Nc,xx, /* DGHN */
	Pc,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx, /* P */
	xx,ac,bc,cc,dc,xx,xx,gc,hc,ic,xx,xx,lc,xx,nc,xx, /* a-n */
	pc,qc,rc,sc,tc,xx,xx,wc,xc,yc,xx,Lc,xx,Rc,xx,xx  /* p-y{} */
};


void
compile(Text *script, Text *t)
{
	int loc;	/* progam counter */
	int neg;	/* ! in effect */
	int cmd;
	int naddr;
	int *q;		/* address of instruction word */
	t->w = t->s;	/* here w is a read pointer */
	while(*t->w) {
		assure(script, 4*sizeof(int));
		loc = script->w - script->s;
		synl = t->w;
		naddr = 0;
		while(blank(t)) ;
		naddr += addr(script, t);
		if(naddr && *t->w ==',') {
			t->w++;
			naddr += addr(script, t);
			if(naddr < 2)
				syntax("missing address");
		}
		q = (int*)script->w;
		if(naddr == 2)
			*q++ = INACT;
		script->w = (uchar*)(q+1);
		neg = 0;
		for(;;) {
			while(blank(t));
			cmd = *t->w++;
			if(neg && docom[cmd&0xff]==Ic)
				syntax("improper !");
			if(cmd != '!')
				break;
			neg = NEG;
		}
		if(!neg) {
			switch(adrs[cmd]) {
			case 1:
				if(naddr <= 1)
					break;
			case 0:
				if(naddr == 0)
					break;
				syntax("too many addresses");
			}
		}
		(*docom[cmd&0xff])(script, t);
		switch(*t->w) {
		case 0:
			script->w = script->s + loc;
			break;
		default:
			if(cmd == '{')
				break;
			syntax("junk after command");
		case ';':
			if(!semicolon++)
				synwarn("semicolon separators");
		case '\n':
				t->w++;
		}
		*q = pack(neg,cmd,script->w-script->s-loc);
	}
	fixbrack(script);
	fixlabels(script);
}
#pragma prototyped

#include "sed.h"

#include <ctype.h>

#define ustrchr(p, c) (uchar*)strchr((char*)(p), c)

int selected(uchar*, Text*);

#define Re Ie
#define Ce Ie
#define Se Ie
#define re ae

#define IBUG "interpreter bug %d"
char *stdouterr = "writing standard output";

Text hold;

void
cputchar(int c)
{
	if(sfputc(sfstdout, c) == EOF)
		error(3, stdouterr);
}

void
writeline(Text *data)
{
	int n = data->w - data->s;
	if(sfwrite(sfstdout, data->s, n) != n)
		error(ERROR_SYSTEM|3, stdouterr);
	cputchar('\n');
}

/* return 1 if action is to be taken on current line,
         -1 if (numeric) address has been passed,
	  0 otherwise*/
int
sel1(int addr, Text *data)
{
	if(addr & REGADR)
		return regexec(readdr(addr),(char*)data->s,0,0,0) == 0;
	if(addr == recno)
		return 1;
	if(addr == DOLLAR)
		return ateof();
	if(addr < recno)
		return -1;
	return 0;
}

/* return 2 on non-final line of a selected range,
          1 on any other selected line,
	  0 on non-selected lines 
   (the 1-2 distinction matters only for 'c' commands) */

int
selected(uchar *pc, Text *data)
{
	int active;
	int *ipc = (int*)pc;	/* points to address words */
	int *q = instr(pc);	/* points to instruction word */
	int neg = !!(*q & NEG);
	switch(q - ipc)	{
	case 0:			/* 0 address */
		return !neg;
	case 1:			/* 1 address */
		return neg ^ sel1(ipc[0], data)==1;
	case 2:
		error(ERROR_PANIC|4, IBUG,1);
	case 3:			/* 2 address */
		q--;		/* points to activity indicator */
		active = !(*q & INACT);
		if((*q&AMASK) < recno) {
			switch(sel1(ipc[active], data)) {
			case 0:
				if((active&ateof()) == 0)
					break;
			case 1:
				*q = recno;
				if(active)
					*q |= INACT;
				return (neg^1) << (!active&!ateof());
			case -1:
				if(active) {
					*q = recno | INACT;
					return neg;
				}
			}
		}
		return (neg^active) << 1;
	default:
		error(ERROR_PANIC|4, IBUG,2);
		return 0;	/* dummy */
	}
}

void
vacate(Text *t)
{
	assure(t, 1);
	t->w = t->s;
	*t->w = 0;
}

void
tcopy(Text *from, Text *to)
{
	int n = from->w - from->s;
	assure(to, n+1);
	memmove(to->w, from->s, n);
	to->w += n;
	*to->w = 0;
}
	

/* EASY COMMANDS */

uchar *
vv(Text *script, uchar *pc, Text *data)
{
	script = script;
	pc = pc;
	data = data;
	error(ERROR_PANIC|4, IBUG,3);
	return 0;	/* dummy */
}

uchar *
be(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return script->s + instr(pc)[1];
}

uchar *
de(Text *script, uchar *pc, Text *data)
{
	pc = pc;
	vacate(data);
	return 0;
}

uchar *
De(Text *script, uchar *pc, Text *data)
{
	int n;
	uchar *end = (uchar*)ustrchr(data->s, '\n');
	if(end == 0)
		return de(script, pc, data);
	end++;
	n = data->w - end;
	memmove(data->s, end, n+1);
	data->w = data->s + n;
	return script->s;
}

uchar *
Ee(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	if(sfprintf(sfstdout, "%d\n", recno) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return nexti(pc);
}

uchar *
Ge(Text *script, uchar *pc, Text *data)
{
	script = script;
	if(hold.s == 0) 
		vacate(&hold);
	if(data->w > data->s)
		*data->w++ = '\n';
	tcopy(&hold, data);
	return nexti(pc);
}

uchar *
ge(Text *script, uchar *pc, Text *data)
{
	vacate(data);
	return Ge(script, pc, data);
}

uchar *
He(Text *script, uchar *pc, Text *data)
{
	script = script;
	assure(&hold, 1);
	*hold.w++ = '\n';
	tcopy(data, &hold);
	return nexti(pc);
}

uchar *
he(Text *script, uchar *pc, Text *data)
{
	script = script;
	vacate(&hold);
	tcopy(data, &hold);
	return nexti(pc);
}

uchar *
Ie(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return nexti(pc);
}

uchar *
ie(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	if(sfprintf(sfstdout, "%s", (char*)(instr(pc)+1)) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return nexti(pc);
}

uchar *
Le(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return (uchar*)(instr(pc)+1);
}

uchar *
Ne(Text *script, uchar *pc, Text *data)
{
	assure(data, 1);
	*data->w++ = '\n';
	if(readline(data))
		return nexti(pc);
	*--data->w = 0;
	return de(script, pc, data);
}

uchar *
ne(Text *script, uchar *pc, Text *data)
{
	if(!nflag)
		writeline(data);
	vacate(data);
	if(readline(data))
		return nexti(pc);
	return 0;
}

uchar *
Pe(Text *script, uchar *pc, Text *data)
{
	int n;
	uchar *end = ustrchr(data->s, '\n');
	if(end == 0)
		n = data->w - data->s;
	else
		n = end - data->s;
	if(sfwrite(sfstdout, data->s, n) != n)
		error(ERROR_SYSTEM|3, stdouterr);
	cputchar('\n');
	script = script;
	return nexti(pc);
}

uchar *
pe(Text *script, uchar *pc, Text *data)
{
	writeline(data);
	script = script;
	return nexti(pc);
}

uchar *
qe(Text *script, uchar *pc, Text *data)
{
	pc = pc;
	data = data;
	qflag++;
	return script->w;
}

uchar *
te(Text *script, uchar *pc, Text *data)
{
	int tflag = sflag;
	sflag = 0;
	if(tflag)
		return be(script, pc, data);
	else
		return nexti(pc);
}

uchar *
ww(Text *script, uchar *pc, Text *data, int offset)
{
	int *q = (int*)(files.s + offset);
	Sfio_t *f = *(Sfio_t**)q;
	int n = data->w - data->s;
	assure(data, 1);
	*data->w = '\n';
	if(sfwrite(f, data->s, n+1) != n+1 ||
	   sfsync(f) == EOF)	/* in case of subsequent r */
		error(ERROR_SYSTEM|3, "%s: cannot write", (char*)(q+1));
	*data->w = 0;
	script = script;
	return nexti(pc);
}

uchar *
we(Text *script, uchar *pc, Text *data)
{
	return ww(script, pc, data, instr(pc)[1]);
}

uchar *
xe(Text *script, uchar *pc, Text *data)
{
	uchar *t;
	script = script;
	if(hold.s == 0)
		vacate(&hold);
	exch(data->s, hold.s, t);
	exch(data->e, hold.e, t);
	exch(data->w, hold.w, t);
	return nexti(pc);
}

uchar *
ye(Text *script, uchar *pc, Text *data)
{
	uchar *s = (uchar*)data->s;
	uchar *w = (uchar*)data->w;
	uchar *tbl = (uchar*)(instr(pc)+1);
	for( ; s<w; s++)
		*s = tbl[*s];
	script = script;
	return nexti(pc);
}

/* MISCELLANY */

uchar *
se(Text *script, uchar *pc, Text *data)
{
	int *q = instr(pc);
	int flags = q[2];
	uchar *p = (uchar*)(flags&WFLAG? q+4: q+3);
	int n = flags & ~(PFLAG|WFLAG);

	sflag = substitute(readdr(q[1]), data, p, n);
	if(!sflag)
		return nexti(pc);
	if(flags & PFLAG)
		pe(script, pc, data);
	if(flags & WFLAG)
		return ww(script, pc, data, ((int*)nexti(pc))[-1]);
	return nexti(pc);
}

struct { char p, q; } digram[] = {
	'\\',	'\\',
	'\a',	'a',
	'\b',	'b',
	'\f',	'f',
	'\n',	'n',
	'\r',	'r',
	'\t',	't',
	'\v',	'v',
};

uchar *
le(Text *script, uchar *pc, Text *data)
{
	int i = 0;
	int j;
	uchar *s;
	script = script;
	for(s=data->s; s<data->w; s++, i++) {
		if(i >= 60) {
			cputchar('\\');
			cputchar('\n');
			i = 0;
		}
		for(j=0; j<sizeof(digram)/sizeof(*digram); j++)
			if(*s == digram[j].p) {
				cputchar('\\');
				cputchar(digram[j].q);
				goto cont;
			}
		if(!isprint(*s)) {
			if(sfprintf(sfstdout, "\\%3.3o", *s) <= 0)
				error(ERROR_SYSTEM|3, stdouterr);
		} else
			cputchar(*s);
	cont:	;
	}
	cputchar('$');
	cputchar('\n');
	return nexti(pc);
}	

/* END-OF-CYCLE STUFF */

Text todo;

uchar *
ae(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	assure(&todo, sizeof(uchar*));
	*(uchar**)todo.w = pc;
	todo.w += sizeof(uchar*);
	return nexti(pc);
}

uchar *
ce(Text *script, uchar *pc, Text *data)
{	
	if(sfprintf(sfstdout, "%s", (char*)(instr(pc)+1)) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return de(script, pc, data);
}

void
coda(void)
{
	int *q;
	uchar *p;
	Sfio_t *f;
	if(todo.s == 0)
		return;
	for(p=todo.s; p<todo.w; p+=sizeof(int)) {
		q = instr(*(uchar**)p);
		switch(code(*q)) {
		case 'a':
			if(sfprintf(sfstdout, "%s", (char*)(q+1)) <= 0)
				error(ERROR_SYSTEM|3, stdouterr);
			continue;
		case 'r':
			f = sfopen(NiL, (char*)(files.s+q[1]+sizeof(int)), "r");
			if(f == 0)
				continue;
			if (sfmove(f, sfstdout, SF_UNBOUND, -1) < 0 || !sfeof(f) || sferror(sfstdout))
				error(ERROR_SYSTEM|3, stdouterr);
			sfclose(f);
			continue;
		default:
			error(ERROR_PANIC|4, IBUG,5);
		}
	}
	vacate(&todo);
}

/* execution functions return pointer to next instruction */

typedef uchar* (*exef)(Text*, uchar *, Text*);

static exef excom[128] = {
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,Ie,vv,vv,vv,vv,vv,
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,
	vv,vv,vv,Ie,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv, /* # */
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,Ce,Se,vv,Ee,vv,vv, /* :;= */
	vv,vv,vv,vv,De,vv,vv,Ge,He,vv,vv,vv,vv,vv,Ne,vv, /* DGHN */
	Pe,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv, /* P */
	vv,ae,be,ce,de,vv,vv,ge,he,ie,vv,vv,le,vv,ne,vv, /* a-n */
	pe,qe,re,se,te,vv,vv,we,xe,ye,vv,Le,vv,Re,vv,vv  /* p-y{} */
};

void
execute(Text *script, Text *data)
{
	uchar *pc;
	int sel;
	for(pc = script->s; pc < script->w; ) {
		sel = selected(pc, data);
		if(sel) {
			int cmd = code(*instr(pc));
			if(sel==2 && cmd=='c')
				cmd = 'd';
			pc = (*excom[cmd])(script, pc, data);
			if(pc == 0)
				return;
		} else
			pc = nexti(pc);
	}
	if(!nflag)
		writeline(data);
}
#pragma prototyped

#include "sed.h"

void docopy(uchar *where, int n);
int dosub(uchar *where, uchar *rp);

Text retemp;	/* holds a rewritten regex, without delimiter */

int
recomp(Text *rebuf, Text *t, int delim)
{
	static int lastre;
	uchar *w;
	vacate(&retemp);
	for(w=t->w; ; retemp.w++,w++) {
		assure(&retemp, 2);
		*retemp.w = *w;
		if(*w == delim)
			break;
		else if(*w==0 || *w=='\n')
			syntax("unterminated address");
		else if(*w != '\\')
			continue;
		else if(*++w==delim)
			*retemp.w = delim;
		else if(*w == 'n')
			*retemp.w = '\n';
		else if(*w==0 || *w=='\n')
			syntax("unterminated regular expression");
		else {
			assure(&retemp, 2);
			*++retemp.w = *w;
		}
	}
	*retemp.w = 0;

	assure(rebuf, sizeof(regex_t));
	if(*retemp.s) {
		if(regcomp((regex_t*)rebuf->w,(char*)retemp.s,reflags))
			syntax("bad regular expression");
		lastre = rebuf->w - rebuf->s;
		rebuf->w += sizeof(regex_t);
	} else if(rebuf->w == rebuf->s)
		syntax("no previous regular expression");
	t->w = w + 1;
	return lastre;
}

Text gendata;

#define NMATCH 10
regmatch_t matches[NMATCH];
#define so matches[0].rm_so
#define eo matches[0].rm_eo

int
substitute(regex_t *re, Text* data, uchar *rhs, int n)
{
	Text t;
	uchar *where = data->s;
	if(regexec(re, (char*)data->s, NMATCH, matches, 0))
		return 0;
	vacate(&gendata);
	if(n == 0)
		do {
			docopy(where, so);
			if(!dosub(where, rhs))
				return 0;
			where += eo;
			if(eo == so)
				if(where < data->w)
					docopy(where++, 1);
				else
					goto done;
		} while(regexec(re, (char*)where, NMATCH, matches, REG_NOTBOL) == 0);
	else {
		while(--n > 0) {
			where += eo;
			if(eo == so)
				if(where < data->w)
					where++;
				else
					return 0;
			if(regexec(re, (char*)where, NMATCH, matches, REG_NOTBOL))
				return 0;
		}
		docopy(data->s, where-data->s+so);
		if(!dosub(where, rhs))
			return 0;
		where += eo;
	}			
	eo = so = data->w - where;
	docopy(where, so);
done:
	exch(gendata, *data, t);
	return 1;
}

void
docopy(uchar *where, int n)
{
	assure(&gendata, n+1);
	memmove(gendata.w, where, n);
	gendata.w += n;
	*gendata.w = 0;
}

	/* interpretation problem: if there is no match for \1, say,
           does the substitition occur?  dosub uses a null string.
	   a change where indicated will abort the substitution */
	
int
dosub(uchar *where, uchar *rp)
{
	int c, n;
	regmatch_t *m;

	while(c = *rp++) {
		if(c == '\\') {
			c = *rp++;
			if (c >= '1' && c <= '9') {
				m = matches + c - '0';
				if(m->rm_eo == -1)
					continue;   /* or return 0 */
				n = m->rm_eo - m->rm_so;
				assure(&gendata, n);
				memmove(gendata.w,where+m->rm_so,n);
				gendata.w += n;
				continue;
			}
		} else if(c == '&') {
				assure(&gendata, eo-so);
				memmove(gendata.w,where+so,eo-so);
				gendata.w += eo-so;
				continue;
		}
		assure(&gendata, 1);
		*gendata.w++ = c;
	}
	return 1;
}
#pragma prototyped

/*
 * regular-expression tester
 *
 * usage: testre <testre.dat
 * see comments in testre.dat for description of format
 */

static const char id[] = "\n@(#)testre (AT&T Research) 01/01/96\0\n";

#include <ast.h>
#include <ctype.h>
#include <regex.h>
#include <setjmp.h>
#include <sig.h>
#include <stk.h>

#define LOOPED		2

#define NOTEST		(~0)
#ifndef REG_LEFT
#define REG_LEFT	NOTEST
#endif
#ifndef REG_MINIMAL
#define REG_MINIMAL	NOTEST
#endif
#ifndef REG_NULL
#define REG_NULL	NOTEST
#endif
#ifndef REG_RIGHT
#define REG_RIGHT	NOTEST
#endif

#define REG_UNKNOWN	(-1)

#ifndef REG_ENEWLINE
#define REG_ENEWLINE	(REG_UNKNOWN-1)
#endif
#ifndef REG_ENULL
#define REG_ENULL	(REG_UNKNOWN-2)
#endif
#ifndef REG_ECOUNT
#define REG_ECOUNT	(REG_UNKNOWN-3)
#endif
#ifndef REG_BADESC
#define REG_BADESC	(REG_UNKNOWN-4)
#endif
#ifndef REG_EMEM
#define REG_EMEM	(REG_UNKNOWN-5)
#endif
#ifndef REG_ELOOP
#define REG_ELOOP	(REG_UNKNOWN-6)
#endif
#ifndef REG_EBUS
#define REG_EBUS	(REG_UNKNOWN-7)
#endif
#ifndef REG_EFAULT
#define REG_EFAULT	(REG_UNKNOWN-8)
#endif

static const struct { int code; char* name; } codes[] = {
	REG_UNKNOWN,	"UNKNOWN",
	REG_NOMATCH,	"NOMATCH",
	REG_BADPAT,	"BADPAT",
	REG_ECOLLATE,	"ECOLLATE",
	REG_ECTYPE,	"ECTYPE",
	REG_EESCAPE,	"EESCAPE",
	REG_ESUBREG,	"ESUBREG",
	REG_EBRACK,	"EBRACK",
	REG_EPAREN,	"EPAREN",
	REG_EBRACE,	"EBRACE",
	REG_BADBR,	"BADBR",
	REG_ERANGE,	"ERANGE",
	REG_ESPACE,	"ESPACE",
	REG_BADRPT,	"BADRPT",
	REG_ENEWLINE,	"ENEWLINE",
	REG_ENULL,	"ENULL",
	REG_ECOUNT,	"ECOUNT",
	REG_BADESC,	"BADESC",
	REG_EMEM,	"EMEM",
	REG_ELOOP,	"ELOOP",
	REG_EBUS,	"EBUS",
	REG_EFAULT,	"EFAULT",
};

static struct
{
	int	failures;
	int	goofs;
	int	lineno;
	int	ret;
	int	signals;
	char*	which;
	jmp_buf	gotcha;
} state;

static void
report(char* comment, char* re, char* s, int flags)
{
	state.failures++;
	sfprintf(sfstdout, "%d:", state.lineno);
	if(re) {
		sfprintf(sfstdout, "%s", re);
		if(s)
			sfprintf(sfstdout, " versus %s", s);
	}
	sfprintf(sfstdout, " %s%s %s", state.which, (flags & REG_NOSUB) ? " NOSUB" : "", comment);
}

static void
bad(char* comment, char* re, char* s)
{
	sfprintf(sfstdout,  "bad test case ");
	report(comment, re, s, 0);
	exit(1);
}

static void
doregerror(regex_t* preg, int code, int lineno)
{
	char*	msg;
	char	buf[200];

	switch (code)
	{
	case REG_EBUS:
		msg = "bus error";
		break;
	case REG_EFAULT:
		msg = "memory fault";
		break;
	case REG_ELOOP:
		msg = "did not terminate";
		break;
	default:
		regerror(code, preg, msg = buf, sizeof buf);
		break;
	}
	sfprintf(sfstdout, "%s\n", msg);
}

static int
readfield(char* f, char end)
{
	int	c;

	for(;;) {
		*f = 0;
		c = sfgetc(sfstdin);
		if(c == EOF)
			return 1;
		if(c == end)
			break;
		if(c == '\n')
			return 1;
		*f++ = c;
	} 
	if(c == '\t') {
		while(c == end)
			c = sfgetc(sfstdin);
		sfungetc(sfstdin, c);
	}
	return 0;
}

static int
hex(int c)
{
	return	isdigit(c) ? c-'0' :
		isupper(c) ? c-'A' :
		c-'a'+10;
}

static void
escape(char* s)
{
	char*	t;

	for(t=s; *t=*s; s++, t++) {
		if(*s != '\\')
			continue;
		switch(*++s) {
		case 0:
			*++t = 0;
			break;
		case 'n':
			*t = '\n';
			break;
		case 'x':
			if(!isxdigit(s[1]) || !isxdigit(s[2]))
				bad("bad \\x\n", NiL, NiL);
			*t = hex(*++s) << 4;
			*t |= hex(*++s);
			break;
		default:
			s--;
		}
	}
}

static int
readline(char* spec, char* re, char* s, char* ans)
{
	int	c;

	switch(c = sfgetc(sfstdin)) {
	case EOF:
		return 0;
	case '#':
		while(c != '\n')
			c = sfgetc(sfstdin);
	case '\n':
		*spec = 0;
		return 1;
	}
	sfungetc(sfstdin, c);
	if(readfield(spec, '\t')) return 0;
	if(readfield(re, '\t')) return 0;
	if(readfield(s, '\t')) return 0;
	if(readfield(ans, '\n')) return 0;
	escape(re);
	escape(s);
	return 1;
}

static void
matchprint(regmatch_t* match, int nmatch)
{
	int	i;

	for( ; nmatch>0; nmatch --)
		if(match[nmatch-1].rm_so != -1)
			break;
	for(i=0; i<nmatch; i++) {
		sfprintf(sfstdout, "(");
		if(match[i].rm_so == -1)
			sfprintf(sfstdout, "?");
		else
			sfprintf(sfstdout, "%d", match[i].rm_so);
		sfprintf(sfstdout, ",");
		if(match[i].rm_eo == -1)
			sfprintf(sfstdout, "?");
		else
			sfprintf(sfstdout, "%d", match[i].rm_eo);
		sfprintf(sfstdout, ")");
	}
	sfprintf(sfstdout, "\n");
}

static int
matchcheck(int nmatch, regmatch_t* match, char* ans, char* re, char* s, int flags)
{
	char*	p;
	int	i;
	int	m;
	int	n;

	for(i = 0, p = ans; i<nmatch && *p; i++) {
		if(*p++ != '(')
			bad("improper answer\n", re, s);
		if(*p == '?') {
			m = -1;
			p++;
		} else
			m = strtol(p, &p, 10);
		if(*p++ != ',')
			bad("improper answer\n", re, s);
		if(*p == '?') {
			n = -1;
			p++;
		} else
			n = strtol(p, &p, 10);
		if(*p++ != ')')
			bad("improper answer\n", re, s);
		if(m!=match[i].rm_so || n!=match[i].rm_eo) {
			report("match was: ", re, s, flags);
			matchprint(match, nmatch);
			return 0;
		}
	}
	for( ; i<nmatch; i++) {
		if(match[i].rm_so!=-1 || match[i].rm_eo!=-1) {
			report("match was: ", re, s, flags);
			matchprint(match, nmatch);
			return 0;
		}
	}
	return 1;
}

static void
gotcha(int sig)
{
	signal(sig, gotcha);
	alarm(0);
	state.signals++;
	switch (sig)
	{
	case SIGALRM:
		state.ret = REG_ELOOP;
		break;
	case SIGBUS:
		state.ret = REG_EBUS;
		break;
	case SIGSEGV:
		state.ret = REG_EFAULT;
		break;
	}
	sigunblock(sig);
	longjmp(state.gotcha, 1);
}

static void*
stkresize(void* handle, void* p, size_t n)
{
	void*	x;

	if (!n || !(x = stkalloc((Stk_t*)handle, n)))
		return 0;
	if (p)
		memcpy(x, p, n / 2);
	return x;
}

main(int argc, char** argv)
{
	regmatch_t	NOMATCH;
	int		flags;
	int		cflags;
	int		eflags;
	int		are;
	int		bre;
	int		ere;
	int		kre;
	int		lre;
	int		sre;
	char		spec[10];
	char		re[1000];
	char		s[100000];
	char		ans[500];
	char		msg[500];
	regmatch_t	match[100];
	regex_t		preg;
	char*		p;
	int		nmatch;
	int		cret;
	int		eret;
	int		i;
	int		expected;
	int		got;
	int		len;

	int		catch = 0;
	int		testno = 0;
	int		verbose = 0;
	off_t		stk = -1;

	sfprintf(sfstdout, "TEST	<regex>");
	while((p = *++argv) && *p == '-')
		for(;;)
		{
			switch(*++p)
			{
			case 0:
				break;
			case 'c':
				catch = 1;
				sfprintf(sfstdout, ", catch");
				continue;
			case 's':
#ifdef REG_AUGMENTED
				stk = stktell(stkstd);
				regalloc((void*)stkstd, stkresize, REG_NOFREE);
				sfprintf(sfstdout, ", stkstd");
#endif
				continue;
			case 'v':
				verbose = 1;
				sfprintf(sfstdout, ", verbose");
				continue;
			default:
				sfprintf(sfstdout, ", invalid option %c", *p);
				continue;
			}
			break;
		}
	if(p)
		sfprintf(sfstdout, ", argument(s) ignored");
	sfprintf(sfstdout, "\n");
	if(catch) {
		signal(SIGALRM, gotcha);
		signal(SIGBUS, gotcha);
		signal(SIGSEGV, gotcha);
	}
	NOMATCH.rm_so = -2;
	NOMATCH.rm_eo = -2;
	while(readline(spec, re, s, ans)) {
		state.lineno++;
		if(*spec == 0)
			continue;
		sfsync(sfstdout);

	/* interpret: */

		cflags = eflags = are = bre = ere = kre = lre = sre = 0;
		nmatch = 20;
		for(p=spec; *p; p++) {
			if(isdigit(*p)) {
				nmatch = strtol(p, &p, 10);
				p--;
				continue;
			}
			switch(*p) {

			case 'A':
				are = 1;
				continue;
			case 'B':
				bre = 1;
				continue;
			case 'E':
				ere = 1;
				continue;
			case 'K':
				kre = 1;
				continue;
			case 'L':
				lre = 1;
				continue;
			case 'S':
				sre = 1;
				continue;

			case 'I':
				cflags |= REG_ICASE;
				continue;
			case 'M':
				cflags |= REG_MINIMAL;
				continue;
			case 'U':
				cflags |= REG_NULL;
				continue;
			case 'W':
				cflags |= REG_NEWLINE;
				continue;

			case 'a':
				cflags |= REG_LEFT|REG_RIGHT;
				continue;
			case 'b':
				eflags |= REG_NOTBOL;
				continue;
			case 'e':
				eflags |= REG_NOTEOL;
				continue;
			case 'l':
				cflags |= REG_LEFT;
				continue;
			case 'r':
				cflags |= REG_RIGHT;
				continue;

			case '?':
				continue;

			default:
				bad("bad spec\n", re, s);

			}
		}
		if(streq(re, "NULL"))
			re[0] = 0;
		if(streq(s, "NULL"))
			s[0] = 0;
		if((cflags|eflags) == NOTEST)
			continue;

	compile:

		if(bre) {
			state.which = "BRE";
			bre = 0;
			flags = cflags;
		}
		else if(ere) {
			state.which = "ERE";
			ere = 0;
			flags = cflags | REG_EXTENDED;
		}
#ifdef REG_AUGMENTED
		else if(are) {
			state.which = "ARE";
			are = 0;
			flags = cflags | REG_AUGMENTED;
		}
#endif
#ifdef REG_LITERAL
		else if(lre) {
			state.which = "LRE";
			lre = 0;
			flags = cflags | REG_LITERAL;
		}
#endif
#ifdef REG_SHELL
		else if(sre) {
			state.which = "SRE";
			sre = 0;
			flags = cflags | REG_SHELL;
		}
#ifdef REG_AUGMENTED
		else if(kre) {
			state.which = "KRE";
			kre = 0;
			flags = cflags | REG_SHELL | REG_AUGMENTED;
		}
#endif
#endif
		else
			continue;
		if(verbose)
			sfprintf(sfstdout, "test %-3d %s \"%s\" \"%s\"\n", state.lineno, state.which, re, s);

	nosub:

		testno++;
		if(catch) {
			if(setjmp(state.gotcha))
				cret = state.ret;
			else {
				alarm(LOOPED);
				cret = regcomp(&preg, re, flags);
				alarm(0);
			}
		} else
			cret = regcomp(&preg, re, flags);
		if(cret == 0) {
			if(!streq(ans, "NULL") &&
			   !streq(ans, "NOMATCH") &&
			   ans[0]!='(') {
				report("regcomp should fail and didn't\n", re, NiL, flags);
				continue;
			}
		} else {
			if(streq(ans, "NULL") ||
			   ans[0]=='(' ||
			   cret==REG_BADPAT && streq(ans, "NOMATCH")) {
				report("regcomp failed: ", re, NiL, flags);
				doregerror(&preg, cret, state.lineno);
			} else {
				expected = got = 0;
				for(i=1; i<elementsof(codes); i++) {
					if(streq(ans, codes[i].name))
						expected = i;
					if(cret==codes[i].code)
						got = i;
				}
				if(!expected)
				{
					report("invalid error code: ", re, NiL, flags);
					sfprintf(sfstdout, "%s expected, %s returned\n", ans, codes[got].name);
				}
				else if(cret!=codes[expected].code && cret!=REG_BADPAT) {
					report("regcomp should fail and did: ", re, NiL, flags);
					sfprintf(sfstdout, "%s expected, %s returned: ", ans, codes[got].name);
					state.failures--;
					state.goofs++;
					doregerror(&preg, cret, state.lineno);
				}
			}
			goto compile;
		}

	/* execute: */
		
		for(i=0; i<elementsof(match); i++)
			match[i] = NOMATCH;

		if(catch) {
			if(setjmp(state.gotcha))
				eret = state.ret;
			else {
				alarm(LOOPED);
				eret = regexec(&preg, s, nmatch, match, eflags);
				alarm(0);
			}
		} else
			eret = regexec(&preg, s, nmatch, match, eflags);

		if(flags & REG_NOSUB) {
			if(eret) {
				report("regexec REG_NOSUB failed: ", re, s, flags);
				doregerror(&preg, eret, state.lineno);
			}
		} else if(eret) {
			if(!streq(ans, "NOMATCH")) {
				report("regexec failed", re, s, flags);
				if(eret != REG_NOMATCH) {
					sfprintf(sfstdout, ": ");
					doregerror(&preg, eret, state.lineno);
				} else
					sfprintf(sfstdout, "\n");
			}
		} else if(streq(ans, "NOMATCH")) {
			report("regexec should fail and didn't: ", re, s, flags);
			matchprint(match, nmatch);
		} else if(streq(ans, "NULL")) {
			if(match[0].rm_so != NOMATCH.rm_so) {
				report("no match but match array assigned: ", re, s, flags);
				matchprint(match, nmatch);
			}
		} else if (matchcheck(nmatch, match, ans, re, s, flags)) {
			if(stk >= 0)
				stkseek(stkstd, stk);
			else
				regfree(&preg);
			flags |= REG_NOSUB;
			goto nosub;
		}
		if(stk >= 0)
			stkseek(stkstd, stk);
		else
			regfree(&preg);
		goto compile;
	}
	sfprintf(sfstdout, "TEST	<regex>, %d tests", testno);
	if(state.goofs)
		sfprintf(sfstdout, ", %d goofs", state.goofs);
	if(state.signals)
		sfprintf(sfstdout, ", %d signals", state.signals);
	sfprintf(sfstdout, ", %d errors\n", state.failures);
	return 0;
}
#pragma prototyped
/*
 * Editor (snarfed from v10, now posix compliant, no hard limits)
 */

static const char id[] = "\n@(#)ed (AT&T Research) 01/01/96\0\n";

#include <ast.h>
#include <error.h>
#include <ls.h>
#include <sfstr.h>
#include <sig.h>

#include <ctype.h>
#include <regex.h>
#include <setjmp.h>

#define BLOCK_LINE	1024
#define BLOCK_TMP	(8*SF_BUFSIZE)

#define BREAK_PAGE	23
#define BREAK_LINE	72

#define LINE_GLOBAL	((off_t)0x80000000)
#define LINE_MARKED	((off_t)0x40000000)
#define LINE_NONE	((off_t)-1)

#define MARK_MIN	'a'
#define MARK_MAX	'z'

#define MATCH_MIN	'0'
#define MATCH_MAX	'9'

#define PRINT		01
#define PRINT_LIST	02
#define PRINT_NUMBER	04

#define REC_IGNORE	001
#define REC_LINE	002
#define REC_SPLICE	004
#define REC_TERMINATE	010
#define REC_TEXT	020

#define BEG(n)		(ed.line+ed.match[n].rm_so)
#define CUR()		(ed.line)
#define END(n)		(ed.line+ed.match[n].rm_eo)
#define HIT(n)		(ed.match[n].rm_eo!=-1)
#define NXT()		(ed.line++)
#define SET(p)		(ed.line=(p))

#define error		fatal
#define trap()		do{if(ed.caught)handle();}while(0);

#define swap(t,a,b)	(ed.swp=(void*)(a),(a)=(b),(b)=(t)ed.swp)

typedef struct
{
	off_t		offset;
	off_t		undo;
	unsigned long	event;
} Line_t;

static int		signals[] = { SIGQUIT, SIGHUP, SIGINT, SIGTERM };

static struct		/* program state -- no other dynamic globals */
{
	struct
	{
	Sfio_t*		file;
	Sfio_t*		global;
	Sfio_t*		help;
	Sfio_t*		line;
	Sfio_t*		prompt;
	Sfio_t*		query;
	Sfio_t*		shell;
	Sfio_t*		substitute;
	Sfio_t*		work;
	}		buffer;
	struct
	{
	int		print;
	int		size;
	}		page;
	struct
	{
	off_t		marks[MARK_MAX - MARK_MIN + 1];
	unsigned long	dol;
	unsigned long	dot;
	}		undo;
	Line_t*		addr1;
	Line_t*		addr2;
	Line_t*		dol;
	Line_t*		dot;
	Line_t*		zero;
	Sfio_t*		iop;
	Sfio_t*		msg;
	Sfio_t*		tmp;
	char*		global;
	char*		line;
	char*		linebreak;
	char*		tmpfile;
	int		caught;
	int		compiled;
	int		evented;
	int		given;
	int		help;
	int		initialized;
	int		interactive;
	int		lastc;
	int		marked;
	int		modified;
	int		peekc;
	int		pending;
	int		print;
	int		prompt;
	int		verbose;
	int		warn_newline;
	int		warn_null;
	jmp_buf		again;
	off_t		marks[MARK_MAX - MARK_MIN + 1];
	off_t		tmpoff;
	regex_t		re;
	regmatch_t	match[MATCH_MAX - MATCH_MIN + 1];
	unsigned long	all;
	unsigned long	bytes;
	unsigned long	event;
	unsigned long	lines;
	void*		swp;
}			ed;

static void		commands(void);
static void		handle(void);
static void		quit(int);

static void
interrupt(int sig)
{
	signal(sig, interrupt);
	if (ed.initialized) {
		if (!ed.caught)
			ed.caught = sig;
	}
	else if (!ed.pending)
		ed.pending = sig;
}

static int
getchr(void)
{
	if (ed.lastc = ed.peekc) {
		ed.peekc = 0;
		return(ed.lastc);
	}
	if (ed.global) {
		if (ed.lastc = *ed.global++)
			return(ed.lastc);
		ed.global = 0;
		return(EOF);
	}
	if ((ed.lastc = sfgetc(sfstdin)) == EOF)
		trap();
	return(ed.lastc);
}

static ssize_t
helpwrite(int fd, const void* buf, size_t len)
{
	ssize_t	n;

	NoP(fd);
	n = ed.help ? sfwrite(ed.msg, buf, len) : ed.verbose ? sfputr(ed.msg, "?", '\n') : 0;
	sfstrset(ed.buffer.help, 0);
	sfwrite(ed.buffer.help, buf, len - 1);
	sfputc(ed.buffer.help, 0);
	return(n);
}

static void
error(int level, ...)
{
	va_list		ap;
	register int	c;

	trap();
	va_start(ap, level);
	errorv(NiL, level, ap);
	va_end(ap);
	if (level >= 2) {
		if (ed.iop) {
			sfclose(ed.iop);
			ed.iop = 0;
			error_info.file = 0;
		}
		if (ed.interactive <= 0 && (ed.interactive = isatty(0)) <= 0)
			quit(1);
		ed.print = 0;
		ed.bytes = 0;
		ed.lines = 0;
		if (ed.global)
			ed.lastc = '\n';
		ed.global = 0;
		ed.peekc = ed.lastc;
		if (ed.lastc)
			while ((c = getchr()) != '\n' && c != EOF)
				;
		longjmp(ed.again, 1);
	}
}

static void
init(void)
{
	register Sfio_t**	ss;
	register int		c;

	ed.interactive = -1;
	ed.msg = sfstdout;
	ed.all = BLOCK_LINE;
	ed.page.size = BREAK_PAGE;
	ed.verbose = 1;
	for (c = 0; c < elementsof(signals); c++)
		if (signal(signals[c], interrupt) == SIG_IGN)
			signal(signals[c], SIG_IGN);
	for (ss = (Sfio_t**)&ed.buffer; ss < (Sfio_t**)(((char*)&ed.buffer) + sizeof(ed.buffer)); ss++) {
		if (!(*ss = sfstropen()))
			error(ERROR_SYSTEM|3, "cannot initialize internal buffer");
		sfputc(*ss, 0);
		sfstrset(*ss, 0);
	}
	sfputr(ed.buffer.help, "?", 0);
	if (!(ed.zero = newof(NiL, Line_t, ed.all, 0)))
		error(ERROR_SYSTEM|3, "out of space [zero]");
}

static char*
getrec(register Sfio_t* sp, register int delimiter, register int flags)
{
	register int	c;
	register char*	glob;

	sfstrset(sp, 0);
	glob = ed.global;
	while ((c = getchr()) != delimiter) {
		if (c == '\n') {
			ed.peekc = c;
			break;
		}
		if (c == EOF) {
			if (glob)
				ed.peekc = (flags & REC_LINE) ? 0 : c;
			else if (delimiter != '\n' || (flags & (REC_LINE|REC_SPLICE)))
				error(2, "unexpected EOF");
			else if (flags & REC_TEXT)
				return(0);
			break;
		}
		if (c == '\\' && ((c = getchr()) != delimiter || (flags & REC_SPLICE) && c != '\n') && c && !(flags & REC_IGNORE))
			sfputc(sp, '\\');
		if (!c)
			error(1, "null character ignored");
		else if (!(flags & REC_IGNORE))
			sfputc(sp, c);
	}
	if (flags & REC_TERMINATE)
		sfputc(sp, c);
	return(sfstruse(sp));
}

static void
putrec(register char* s)
{
	register int	n;
	register char*	t;

	if ((ed.print & PRINT_LIST) && (t = fmtesc(s))) {
		s = t;
		n = strlen(s);
		while (n > BREAK_LINE) {
			n -= BREAK_LINE;
			sfprintf(ed.msg, "%-*.*s\\\n", BREAK_LINE, BREAK_LINE, s);
			s += BREAK_LINE;
		}
		sfprintf(ed.msg, "%s$\n", s);
	}
	else
		sfputr(ed.msg, s, '\n');
}

static void
modify(void)
{
	if (!ed.evented) {
		ed.evented = ed.modified = 1;
		ed.event++;
		ed.undo.dot = ed.dot - ed.zero;
		ed.undo.dol = ed.dol - ed.zero;
		if (ed.marked) {
			register int	c;

			for (c = 0; c < elementsof(ed.marks); c++)
				ed.undo.marks[c] = ed.marks[c];
		}
	}
}

static void
undo(void)
{
	register Line_t*	a1;
	register Line_t*	a3;
	register unsigned long	event;
	int			c;
	off_t			t;
	unsigned long		n;

	c = 0;
	event = ed.event;
	a1 = ed.zero;
	a3 = ed.zero + ed.all;
	while (++a1 < a3)
		if (a1->event == event) {
			c = 1;
			t = a1->offset;
			a1->offset = a1->undo;
			a1->undo = t;
		}
	if (!c)
		error(2, "nothing to undo");
	if (ed.marked)
		for (c = 0; c < elementsof(ed.marks); c++) {
			t = ed.marks[c];
			ed.marks[c] = ed.undo.marks[c];
			ed.undo.marks[c] = t;
		}
	n = ed.dot - ed.zero;
	ed.dot = ed.zero + ed.undo.dot;
	ed.undo.dot = n;
	n = ed.dol - ed.zero;
	ed.dol = ed.zero + ed.undo.dol;
	ed.undo.dol = n;
}

static char*
lineget(off_t off)
{
	char*	s;

	off &= ~(LINE_GLOBAL|LINE_MARKED);
	if (sfseek(ed.tmp, off, SEEK_SET) != off)
		error(ERROR_SYSTEM|2, "temp file read seek error");
	if (!(s = sfgetr(ed.tmp, 0, 0)))
		error(ERROR_SYSTEM|2, "temp file read error");
	return(s);
}

static off_t
lineput(char* s)
{
	off_t	off;

	modify();
	off = ed.tmpoff;
	if (sfseek(ed.tmp, off, SEEK_SET) != off)
		error(ERROR_SYSTEM|2, "temp file write seek error");
	if (sfputr(ed.tmp, s, 0) < 0)
		error(ERROR_SYSTEM|2, "temp file write error");
	if ((ed.tmpoff = sfseek(ed.tmp, 0L, SEEK_CUR)) == (off_t)-1)
		error(ERROR_SYSTEM|2, "temp file tell error");
	return(off);
}

static void
replace(register Line_t* a1, char* s)
{
	register off_t	off;

	off = lineput(s);
	if (a1->offset & LINE_MARKED) {
		register off_t*	mp;

		a1->offset &= ~LINE_GLOBAL;
		off |= LINE_MARKED;
		for (mp = ed.marks; mp < &ed.marks[elementsof(ed.marks)]; mp++)
			if (*mp == a1->offset)
				*mp = off;
	}
	a1->event = ed.event;
	a1->undo = a1->offset;
	a1->offset = off;
}

static void
squeeze(int i)
{
	if (ed.addr1 < ed.zero + i)
		error(2, "at top of file");
	if (ed.addr2 > ed.dol)
		error(2, "at end of file");
	if (ed.addr1 > ed.addr2)
		error(2, "first address exceeds second");
}

static void
nonzero(void)
{
	squeeze(1);
}

static char*
getfile(void)
{
	register char*	s;
	register int	n;
	register int	m;

	if (!(s = sfgetr(ed.iop, '\n', 1))) {
		if (!(s = sfgetr(ed.iop, '\n', -1)))
			return(0);
		ed.warn_newline = 1;
	}
	n = sfslen();
	if ((m = strlen(s)) < n) {
		register char*	t;
		register char*	u;
		register char*	x;

		t = u = s + m;
		x = s + n;
		while (u < x)
			if (!(*t++ = *u++))
				t--;
		*t++ = 0;
		n = t - s;
		ed.warn_null += x - t;
	}
	ed.bytes += n;
	ed.lines++;
	return(s);
}

static char*
getline(void)
{
	register char*	s;

	if ((s = getrec(ed.buffer.line, '\n', REC_TEXT)) && s[0] == '.' && !s[1])
		s = 0;
	return(s);
}

static char*
getbreak(void)
{
	char*	s;

	if ((s = ed.linebreak) && (ed.linebreak = strchr(s, '\n')))
		*ed.linebreak++ = 0;
	return(s);
}

static char*
getcopy(void)
{
	if (ed.addr1 > ed.addr2)
		return(0);
	return(lineget((ed.addr1++)->offset));
}

static void
print(void)
{
	register Line_t* a1;

	nonzero();
	a1 = ed.addr1;
	do {
		if (ed.print & PRINT_NUMBER)
			sfprintf(ed.msg, "%d\t", a1 - ed.zero);
		putrec(lineget((a1++)->offset));
	} while (a1 <= ed.addr2);
	ed.dot = ed.addr2;
	ed.print = 0;
}

static int
getnum(void)
{
	register int c;
	register int r;

	r = 0;
	while ((c = getchr()) >= '0' && c <= '9')
		r = r * 10 + c - '0';
	ed.peekc = c;
	return(r);
}

static void
regfatal(int code)
{
	char	buf[128];

	if (code) {
		regerror(code, 0, buf, sizeof(buf));
		error(2, "%s", buf);
	}
}

static void
compile(int delimiter)
{
	register char*	s;
	int		c;

	s = getrec(ed.buffer.line, delimiter, 0);
	if (*s) {
		if (ed.compiled) {
			ed.compiled = 0;
			regfree(&ed.re);
		}
		if (c = regcomp(&ed.re, s, 0))
			regfatal(c);
		ed.compiled = 1;
	}
	else if (!ed.compiled)
		error(2, "no previous regular expression");
}

static int
execute(Line_t* addr)
{
	register char*	s;
	register int	c;

	trap();
	if (!addr)
		s = CUR();
	else if (addr == ed.zero)
		return(0);
	else
		s = lineget(addr->offset);
	if (c = regexec(&ed.re, s, elementsof(ed.match), ed.match, 0)) {
		if (c != REG_NOMATCH)
			regfatal(c);
		return(0);
	}
	SET(s);
	return(1);
}

static Line_t*
address(void)
{
	register int		c;
	register int		sign;
	register Line_t*	a;
	register Line_t*	b;
	int			opcnt;
	int			nextopand;

	nextopand = -1;
	sign = 1;
	opcnt = 0;
	a = ed.dot;
	do {
		do c = getchr(); while (isspace(c) && c != '\n');
		if (c >= '0' && c <= '9') {
			ed.peekc = c;
			if (!opcnt)
				a = ed.zero;
			a += sign * getnum();
		}
		else switch (c) {

		case '$':
			a = ed.dol;
			/*FALLTHROUGH*/
		case '.':
			if (opcnt)
				error(2, "invalid address");
			break;

		case '\'':
			if ((c = getchr()) == EOF || (c -= MARK_MIN) < 0 || c >= elementsof(ed.marks) || opcnt)
				error(2, "invalid mark");
			a = ed.marked && ed.marks[c] != LINE_NONE ? ed.zero : ed.dol;
			do {
				if (++a > ed.dol)
					error(2, "undefined mark referenced");
			} while (ed.marks[c] != (a->offset & ~LINE_GLOBAL));
			break;

		case '?':
			sign = -sign;
			/*FALLTHROUGH*/
		case '/':
			compile(c);
			b = a;
			for (;;) {
				a += sign;
				if (a <= ed.zero)
					a = ed.dol;
				if (a > ed.dol)
					a = ed.zero;
				if (execute(a))
					break;
				if (a == b)
					error(2, "pattern not found");
			}
			break;

		default:
			if (nextopand == opcnt) {
				a += sign;
				if (a < ed.zero || ed.dol < a)
					continue;       /* error? */
			}
			if (c != '+' && c != '-' && c != '^') {
				ed.peekc = c;
				if (!opcnt)
					a = 0;
				return(a);
			}
			sign = 1;
			if (c != '+')
				sign = -sign;
			nextopand = ++opcnt;
			continue;

		}
		sign = 1;
		opcnt++;
	} while (a >= ed.zero && a <= ed.dol);
	error(2, "address out of range");
	return(0);
}

static void
setwide(void)
{
	if (!ed.given) {
		ed.addr1 = ed.zero + (ed.dol > ed.zero);
		ed.addr2 = ed.dol;
	}
}

static void
setnoaddr(void)
{
	if (ed.given)
		error(2, "invalid address count");
}

static void
newline(void)
{
	register int	warned = 0;

	for (;;)
		switch (getchr()) {

		case EOF:
		case '\n':
			return;

		case 'l':
			ed.print = PRINT_LIST;
			continue;

		case 'n':
			ed.print = PRINT_NUMBER;
			continue;

		case 'p':
			ed.print = PRINT;
			continue;

		default:
			if (!warned) {
				warned = 1;
				error(2, "extra characters at end of command");
			}
			continue;
		}
}

static char*
plural(unsigned long count)
{
	return(count == 1 ? "" : "s");
}

static void
exfile(void)
{
	if (sfclose(ed.iop))
		error(ERROR_SYSTEM|1, "io error");
	ed.iop = 0;
	if (ed.verbose) {
		if (ed.help) {
			sfprintf(ed.msg, "\"%s\" %lu line%s, %lu character%s", error_info.file, ed.lines, plural(ed.lines), ed.bytes, plural(ed.bytes));
			if (ed.warn_null) {
				sfprintf(ed.msg, ", %lu null%s", ed.warn_null, plural(ed.warn_null));
				ed.warn_null = 0;
			}
			if (ed.warn_newline) {
				sfprintf(ed.msg, ", newline appended");
				ed.warn_newline = 0;
			}
			sfputc(ed.msg, '\n');
		}
		else
			sfprintf(ed.msg, "%d\n", ed.bytes);
	}
	if (ed.warn_null || ed.warn_newline) {
		char*	sep = "";

		sfstrset(ed.buffer.line, 0);
		if (ed.warn_null) {
			sfprintf(ed.buffer.line, "%d null character%s ignored", ed.warn_null, plural(ed.warn_null));
			ed.warn_null = 0;
			sep = ", ";
		}
		if (ed.warn_newline) {
			sfprintf(ed.buffer.line, "%snewline appended to last line", sep);
			ed.warn_newline = 0;
		}
		error(1, "%s", sfstruse(ed.buffer.line));
	}
	error_info.file = 0;
}

static void
putfile(void)
{
	register Line_t*	a1;
	register int		n;

	ed.bytes = 0;
	ed.lines = 0;
	a1 = ed.addr1;
	do {
		if ((n = sfputr(ed.iop, lineget((a1++)->offset), '\n')) < 0)
			error(ERROR_SYSTEM|2, "write error");
		ed.bytes += n;
		ed.lines++;
	} while (a1 <= ed.addr2);
	if (sfsync(ed.iop))
		error(ERROR_SYSTEM|2, "write error");
}

static void
quit(int code)
{
	if (ed.tmpfile) {
		remove(ed.tmpfile);
		ed.tmpfile = 0;
	}
	if (ed.verbose && ed.modified && ed.dol != ed.zero) {
		ed.modified = 0;
		error(2, "file changed but not written");
	}
	if (ed.caught == SIGQUIT) {
		signal(ed.caught, SIG_DFL);
		kill(0, ed.caught);
	}
	exit(code);
}

static void
handle(void)
{
	register int	c;
	char*		s;
	char*		b;
	mode_t		mask;

	if (ed.caught == SIGINT) {
		ed.caught = 0;
		ed.lastc = '\n';
		sfputc(ed.msg, '\n');
		error(2, "interrupt");
	}
	for (c = 0; c < elementsof(signals); c++)
		signal(signals[c], SIG_IGN);
	if (ed.dol > ed.zero) {
		ed.addr1 = ed.zero + 1;
		ed.addr2 = ed.dol;
		mask = umask(S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
		b = "ed.hup";
		if (!(ed.iop = sfopen(NiL, b, "w")) && (s = getenv("HOME"))) {
			sfstrset(ed.buffer.line, 0);
			sfprintf(ed.buffer.line, "%s/%s", s, b);
			b = sfstruse(ed.buffer.line);;
			ed.iop = sfopen(NiL, b, "w");
		}
		umask(mask);
		if (!ed.iop)
			error(ERROR_SYSTEM|1, "%s: cannot save changes", b);
		else {
			error_info.file = b;
			putfile();
		}
	}
	ed.modified = 0;
	quit(0);
}

static int
append(char* (*f)(void), Line_t* a)
{
	register char*		s;
	register Line_t*	a1;
	register Line_t*	a2;
	register Line_t*	a3;
	off_t			t;
	long			m;
	long			slide;

	slide = 0;
	ed.dot = a;
	while (s = (*f)()) {
		if ((ed.dol - ed.zero) + 1 >= ed.all) {
#if __sgi__ && !__GNUC__ /* sgi pointer arithmetic bug -- it's fun */
			long	dot = ed.dot - ed.zero;
			long	dol = ed.dol - ed.zero;
#endif
			a3 = ed.zero;
			ed.all += BLOCK_LINE;
			if (!(ed.zero = newof(ed.zero, Line_t, ed.all, 0))) {
				error(ERROR_SYSTEM|1, "no space [zero]");
				ed.caught = SIGHUP;
				trap();
			}
			m = ed.zero - a3;
			slide += m;
#if __sgi__ && !__GNUC__ /* sgi pointer arithmetic bug -- it's fun */
			ed.dot = ed.zero + dot;
			ed.dol = ed.zero + dol;
#else
			ed.dot += m;
			ed.dol += m;
#endif
		}
		t = lineput(s);
		slide++;
		a1 = ++ed.dol;
		a2 = a1 + 1;
		a3 = ++ed.dot;
		while (a1 > a3) {
			(--a2)->event = ed.event;
			a2->undo = a2->offset;
			a2->offset = (--a1)->offset;
		}
		a3->event = ed.event;
		a3->undo = a3->offset;
		a3->offset = t;
	}
	return(slide);
}

static void
add(int i)
{
	if (i && (ed.given || ed.dol > ed.zero)) {
		ed.addr1--;
		ed.addr2--;
	}
	squeeze(0);
	newline();
	append(getline, ed.addr2);
}

static void
page(void)
{
	register int	direction;
	register int	n;

	switch (direction = getchr()) {

	case '-':
	case '.':
	case '+':
		break;

	default:
		ed.peekc = direction;
		direction = '+';
		break;

	}
	if ((n = getnum()) > 0)
		ed.page.size = n;
	newline();
	if (ed.print)
		ed.page.print = ed.print;
	else
		ed.print = ed.page.print;
	switch (direction) {

	case '-':
		ed.addr1 = ed.addr2 - ed.page.size + 1;
		break;

	case '.':
		ed.addr2 += ed.page.size / 2;
		ed.addr1 = ed.addr2 - ed.page.size + 1;
		break;

	case '+':
		ed.addr1 = ed.addr2;
		ed.addr2 += ed.page.size - 1;
		break;

	}
	if (ed.addr1 <= ed.zero)
		ed.addr1 = ed.zero + 1;
	if (ed.addr2 > ed.dol)
		ed.addr2 = ed.dol;
	print();
}

static void
rdelete(register Line_t* a1, register Line_t* a2)
{
	register Line_t*	a3;

	modify();
	a3 = ed.dol;
	ed.dol -= ++a2 - a1;
	ed.dot = a1 > ed.dol ? ed.dol : a1;
	do {
		a1->undo = a1->offset;
		a1->event = ed.event;
		(a1++)->offset = (a2++)->offset;
	} while (a2 <= a3);
	while (a1 <= a3) {
		a1->undo = a1->offset;
		(a1++)->event = ed.event;
	}
}

static void
gdelete(void)
{
	register Line_t*	a1;
	register Line_t*	a2;
	register Line_t*	a3;

	a3 = ed.dol;
	for (a1 = ed.zero; !(a1->offset & LINE_GLOBAL); a1++)
		if (a1 >= a3)
			return;
	modify();
	for (a2 = a1 + 1; a2 <= a3;) {
		a1->event = ed.event;
		a1->undo = a1->offset;
		if (a2->offset & LINE_GLOBAL) {
			a2++;
			ed.dot = a1;
		}
		else
			(a1++)->offset = (a2++)->offset;
	}
	ed.dol = a1 - 1;
	if (ed.dot > ed.dol)
		ed.dot = ed.dol;
	while (a1 <= a3) {
		a1->undo = a1->offset;
		(a1++)->event = ed.event;
	}
}

static void
shell(void)
{
	register char*	s;
	register char*	f = 0;
	register int	c;

	if (ed.given)
		squeeze(ed.dol > ed.zero);
	s = getrec(ed.buffer.line, '\n', 0);
	if (s[0] == '!' && !s[1]) {
		if (!*sfstrbase(ed.buffer.shell))
			error(2, "no saved shell command");
		f = sfstrbase(ed.buffer.file);
	}
	else if (!s[0])
		error(2, "empty shell command");
	else
		swap(Sfio_t*, ed.buffer.shell, ed.buffer.line);
	s = sfstrbase(ed.buffer.shell);
	sfstrset(ed.buffer.line, 0);
	sfputc(ed.buffer.line, '!');
	while (c = *s++) {
		if (c == '\\') {
			if (*s != '%')
				sfputc(ed.buffer.line, c);
			sfputc(ed.buffer.line, *s++);
		}
		else if (c == '%')
			sfputr(ed.buffer.line, f = sfstrbase(ed.buffer.file), -1);
		else
			sfputc(ed.buffer.line, c);
	}
	if (ed.given) {
		if (!ed.tmpfile && !(ed.tmpfile = pathtemp(NiL, NiL, error_info.id)))
			error(ERROR_SYSTEM|2, "cannot generate temp file name");
		if (!(ed.iop = sfopen(NiL, ed.tmpfile, "w")))
			error(ERROR_SYSTEM|2, "%s: cannot create temp file", ed.tmpfile);
		error_info.file = ed.tmpfile;
		if (ed.dol > ed.zero)
			putfile();
		exfile();
		ed.bytes = 0;
		ed.lines = 0;
		sfprintf(ed.buffer.line, " < %s", ed.tmpfile);
		s = sfstruse(ed.buffer.line);
		if (!(ed.iop = sfpopen(NiL, s + 1, "r")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", s);
		error_info.file = s;
		rdelete(ed.addr1, ed.addr2);
		append(getfile, ed.dot);
		exfile();
		remove(ed.tmpfile);
	}
	else {
		s = sfstruse(ed.buffer.line) + 1;
		if (f)
			putrec(s);
		if (!(ed.iop = sfpopen(NiL, s, "")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", s);
		if (sfclose(ed.iop)) {
			ed.iop = 0;
			error(ERROR_SYSTEM|2, "%s: shell command exit error", s);
		}
		if (ed.verbose)
			putrec("!");
	}
}

static void
edit(void)
{
	register off_t*	mp;

	if (ed.tmp) {
		sfclose(ed.tmp);
		ed.tmp = 0;
	}
	ed.tmpoff = 0;
	if (!(ed.tmp = sftmp(BLOCK_TMP)))
		error(ERROR_SYSTEM|3, "cannot create temp file");
	for (mp = ed.marks; mp < &ed.marks[elementsof(ed.marks)]; )
		*mp++ = LINE_NONE;
	ed.marked = 0;
	ed.event++;
	ed.dot = ed.dol = ed.zero;
	if (!ed.initialized) {
		ed.initialized = 1;
		if (ed.pending)
			ed.caught = ed.pending;
	}
}

static void
filename(int c)
{
	register char*	p;
	register int	sh = 0;

	ed.bytes = 0;
	ed.lines = 0;
	p = getrec(ed.buffer.line, '\n', REC_LINE);
	if (*p) {
		if (!isspace(*p))
			error(2, "no space after command");
		for (p++; isspace(*p); p++)
			;
		if (!*p)
			error(2, "file name expected");
		if (c != 'f') {
			if (*p == '!') {
				p++;
				sh = 1;
			}
			else if (*p == '\\' && *(p + 1) == '!')
				p++;
		}
		if (!sh && (!*sfstrbase(ed.buffer.file) || c == 'e' || c == 'f')) {
			sfstrset(ed.buffer.file, 0);
			sfputr(ed.buffer.file, p, 0);
		}
		if (c == 'f')
			return;
	}
	else if (c == 'f')
		return;
	else if (!*(p = sfstrbase(ed.buffer.file)))
		error(2, "file name expected");
	if (c == 'e') {
		edit();
		ed.addr2 = ed.zero;
	}
	if (sh) {
		if (!(ed.iop = sfpopen(NiL, p, (c == 'e' || c == 'r') ? "r" : "w")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", p);
		p--;
	}
	else if (c == 'e' || c == 'r') {
		if (!(ed.iop = sfopen(NiL, p, "r")))
			error(ERROR_SYSTEM|2, "%s: cannot read", p);
	}
	else if ((c != 'W' || !(ed.iop = sfopen(NiL, p, "a"))) && !(ed.iop = sfopen(NiL, p, "w")))
		error(ERROR_SYSTEM|2, "%s: cannot write", p);
	error_info.file = p;
}

static void
global(int sense, int query)
{
	register char*		s;
	register int		c;
	register Line_t*	a1;

	if (ed.global)
		error(2, "recursive global not allowed");
	setwide();
	squeeze(ed.dol > ed.zero);
	if ((c = getchr()) == '\n')
		error(2, "incomplete global expression");
	compile(c);
	if (query)
		newline();
	else {
		s = getrec(ed.buffer.global, '\n', REC_SPLICE|REC_TERMINATE);
		if (s[0] == '\n' && !s[1])
			sfputr(ed.buffer.global, "p\n", 0);
	}
	for (a1 = ed.zero; a1 <= ed.dol; a1++) {
		a1->offset &= ~LINE_GLOBAL;
		if (a1 >= ed.addr1 && a1 <= ed.addr2 && execute(a1) == sense)
			a1->offset |= LINE_GLOBAL;
	}

	/* special case: g/.../d (avoid n^2 algorithm) */

	if (!query && s[0] == 'd' && s[1] == '\n' && !s[2])
		gdelete();
	else {
		for (a1 = ed.zero; a1 <= ed.dol; a1++) {
			if (a1->offset & LINE_GLOBAL) {
				a1->offset &= ~LINE_GLOBAL;
				ed.dot = a1;
				if (query) {
					putrec(lineget(a1->offset));
					if ((c = getchr()) == EOF)
						break;
					else if (c == '\n')
						continue;
					else if (c == '&') {
						newline();
						if (!*(ed.global = sfstrbase(ed.buffer.query)))
							error(2, "no saved command");
					}
					else {
						ed.peekc = c;
						ed.global = getrec(ed.buffer.query, '\n', REC_TERMINATE);
					}
				}
				else
					ed.global = s;
				commands();
				a1 = ed.zero;
			}
		}
	}
}

static void
join(void)
{
	register Line_t*	a1;

	nonzero();
	sfstrset(ed.buffer.work, 0);
	for (a1 = ed.addr1; a1 <= ed.addr2;)
		sfputr(ed.buffer.work, lineget((a1++)->offset), -1);
	a1 = ed.dot = ed.addr1;
	replace(a1, sfstruse(ed.buffer.work));
	if (a1 < ed.addr2)
		rdelete(a1 + 1, ed.addr2);
}

static int
compsub(void)
{
	register int	seof;
	register int	c;

	seof = getchr();
	if (isspace(seof))
		error(2, "invalid or missing delimiter");
	compile(seof);
	sfstruse(ed.buffer.substitute);
	for (;;) {
		c = getchr();
		if (c == '\\') {
			sfputc(ed.buffer.substitute, c);
			c = getchr();
		}
		else if (c == '\n' || c == EOF) {
			if (!ed.global || !ed.global[0]) {
				ed.peekc = c;
				ed.print |= PRINT;
				break;
			}
		}
		else if (c == seof)
			break;
		else if (c == '%' && !sfstrtell(ed.buffer.substitute) && ((ed.peekc = getchr()) == '\n' || ed.peekc == EOF || ed.peekc == seof)) {
			if (!*sfstrbase(ed.buffer.substitute))
				error(2, "no saved replacement string");
			sfstrset(ed.buffer.substitute, sfstrsize(ed.buffer.substitute) - 1);
			continue;
		}
		sfputc(ed.buffer.substitute, c);
	}
	sfputc(ed.buffer.substitute, 0);
	if ((ed.peekc = getchr()) == 'g') {
		ed.peekc = 0;
		newline();
		return(-1);
	}
	c = getnum();
	newline();
	return(c);
}

static void
dosub(void)
{
	register char*	s;
	register int	c;
	register int	n;

	sfstrset(ed.buffer.work, 0);
	if (n = BEG(0) - CUR())
		sfwrite(ed.buffer.work, CUR(), n);
	s = sfstrbase(ed.buffer.substitute);
	while (c = *s++) {
		if (c == '&') {
			if (n = END(0) - BEG(0))
				sfwrite(ed.buffer.work, BEG(0), n);
			continue;
		}
		if (c == '\\') {
			c = *s++;
			if (c >= MATCH_MIN && c <= MATCH_MAX) {
				c -= MATCH_MIN;
				if (HIT(c) && (n = END(c) - BEG(c)))
					sfwrite(ed.buffer.work, BEG(c), n);
				continue;
			}
		}
		sfputc(ed.buffer.work, c);
	}
	n = sfstrtell(ed.buffer.work);
	sfputr(ed.buffer.work, END(0), 0);
	swap(Sfio_t*, ed.buffer.work, ed.buffer.line);
	SET(sfstrbase(ed.buffer.line) + n);
}

static void
substitute(int inglob)
{
	register Line_t*	a1;
	register int		m;
	int			g;
	int			n;

	n = getnum();
	g = compsub();
	if (g > 0) {
		if (n)
			error(2, "only one substitute count expected");
		n = g;
		g = 0;
	}
	for (a1 = ed.addr1; a1 <= ed.addr2; a1++) {
		if (execute(a1)){
			m = n;
			do {
				int	span = END(0) - BEG(0);

				if (--m <= 0) {
					dosub();
					if (!g)
						break;
					if (!span) {
						if (!*END(0))
							break;
						NXT();
					}
				}
			} while (execute(NiL));
			if (m <= 0) {
				char*	s;
				char*	e;

				inglob = 1;
				s = sfstrbase(ed.buffer.line);
				if (e = strchr(s, '\n'))
					*e++ = 0;
				replace(a1, s);
				if (e) {
					ed.linebreak = e;
					m = append(getbreak, a1);
					a1 += m;
					ed.addr2 += m;
				}
			}
		}
	}
	if (!inglob)
		error(2, "global pattern not found");
}

static void
reverse(register Line_t* a1, register Line_t* a2)
{
	modify();
	while (--a2 > a1) {
		a1->event = a2->event = ed.event;
		a2->undo = a2->offset;
		a2->offset = a1->undo = a1->offset;
		(a1++)->offset = a2->undo;
	}
}

static void
move(int cflag)
{
	register Line_t*	adt;
	register Line_t*	ad1;
	register Line_t*	ad2;

	nonzero();
	if (!(adt = address()))
		error(2, "invalid move destination");
	newline();
	if (cflag) {
		unsigned long	m;

		ad1 = ed.dol;
		m = append(getcopy, ad1++);
		ad2 = ed.dol;
		ad1 += m;
		adt += m;
	}
	else {
		ad2 = ed.addr2;
		for (ad1 = ed.addr1; ad1 <= ad2; ad1++)
			ad1->offset &= ~LINE_GLOBAL;
		ad1 = ed.addr1;
	}
	ad2++;
	if (adt < ad1) {
		ed.dot = adt + (ad2 - ad1);
		if (++adt == ad1)
			return;
		reverse(adt, ad1);
		reverse(ad1, ad2);
		reverse(adt, ad2);
	}
	else if (adt >= ad2) {
		ed.dot = adt++;
		reverse(ad1, ad2);
		reverse(ad2, adt);
		reverse(ad1, adt);
	}
	else
		error(2, "move would do nothing");
}

static void
commands(void)
{
	register Line_t*	a1;
	register int		c;
	register int		n;
	char*			s;
	int			lastsep;

	for (;;) {
		trap();
		if (ed.print) {
			ed.addr1 = ed.addr2 = ed.dot;
			print();
		}
		if (!ed.global) {
			ed.evented = 0;
			if (ed.prompt > 0)
				sfputr(ed.msg, sfstrbase(ed.buffer.prompt), -1);
		}
		if ((c = getchr()) == ',' || c == ';') {
			ed.given = 1;
			ed.addr1 = (lastsep = c) == ',' ? ed.zero + 1 : ed.dot;
			a1 = ed.dol;
			c = getchr();
		}
		else {
			ed.addr1 = 0;
			ed.peekc = c;
			c = '\n';
			for (;;) {
				lastsep = c;
				a1 = address();
				c = getchr();
				if (c != ',' && c != ';')
					break;
				if (lastsep == ',')
					error(2, "invalid address");
				if (!a1) {
					a1 = ed.zero + 1;
					if (a1 > ed.dol)
						a1--;
				}
				ed.addr1 = a1;
				if (c == ';')
					ed.dot = a1;
			}
			if (lastsep != '\n' && !a1)
				a1 = ed.dol;
		}
		if (!(ed.addr2 = a1)) {
			ed.given = 0;
			ed.addr2 = ed.dot;	
		}
		else
			ed.given = 1;
		if (!ed.addr1)
			ed.addr1 = ed.addr2;
		switch (c) {

		case 'a':
			add(0);
			continue;

		case 'c':
			nonzero();
			newline();
			rdelete(ed.addr1, ed.addr2);
			append(getline, ed.addr1 - 1);
			continue;

		case 'd':
			nonzero();
			newline();
			rdelete(ed.addr1, ed.addr2);
			continue;

		case 'E':
			ed.modified = 0;
			c = 'e';
			/*FALLTHROUGH*/
		case 'e':
			setnoaddr();
			if (ed.verbose && ed.modified) {
				ed.modified = 0;
				error(2, "modified data not written");
			}
			/*FALLTHROUGH*/
		case 'r':
			filename(c);
			setwide();
			squeeze(0);
			c = ed.zero != ed.dol;
			append(getfile, ed.addr2);
			ed.modified = c;
			exfile();
			continue;

		case 'f':
			setnoaddr();
			filename(c);
			putrec(sfstrbase(ed.buffer.file));
			continue;

		case 'G':
			global(1, 1);
			continue;

		case 'g':
			global(1, 0);
			continue;

		case 'H':
			ed.help = !ed.help;
			/*FALLTHROUGH*/
		case 'h':
			setnoaddr();
			newline();
			if (ed.help || c == 'h')
				sfputr(ed.msg, sfstrbase(ed.buffer.help), '\n');
			continue;

		case 'i':
			add(-1);
			continue;

		case 'j':
			if (!ed.given)
				ed.addr2++;
			newline();
			join();
			continue;

		case 'k':
			nonzero();
			if ((c = getchr()) == EOF || (c -= MARK_MIN) < 0 || c >= elementsof(ed.marks))
				error(2, "invalid mark");
			newline();
			ed.addr2->offset |= LINE_MARKED;
			ed.marks[c] = ed.addr2->offset & ~LINE_GLOBAL;
			ed.marked = 1;
			continue;

		case 'm':
			move(0);
			continue;

		case 'n':
			ed.print |= PRINT_NUMBER;
			newline();
			print();
			continue;

		case '\n':
			if (!a1) {
				a1 = ed.dot + 1;
				ed.addr2 = a1;
				ed.addr1 = a1;
			}
			if (lastsep == ';')
				ed.addr1 = a1;
			print();
			continue;

		case 'l':
			ed.print |= PRINT_LIST;
			/*FALLTHROUGH*/
		case 'p':
			newline();
			print();
			continue;

		case 'P':
			setnoaddr();
			s = getrec(ed.buffer.line, '\n', 0);
			if (*s || !(ed.prompt = -ed.prompt) && (s = "*")) {
				sfstrset(ed.buffer.prompt, 0);
				sfputr(ed.buffer.prompt, s, 0);
				ed.prompt = 1;
			}
			continue;

		case 'Q':
			ed.modified = 0;
			/*FALLTHROUGH*/
		case 'q':
			setnoaddr();
			newline();
			quit(0);
			continue;

		case 'S':
			setnoaddr();
			newline();
			sfprintf(ed.msg, "file=\"%s\"%s%s%s prompt=\"%s\" tmp=%lu%s event=%lu version=%s\n", sfstrbase(ed.buffer.file), ed.modified ? " modified" : "", ed.help ? " help" : "", ed.verbose ? " verbose" : "", sfstrbase(ed.buffer.prompt), ed.tmpoff, ed.tmpoff > BLOCK_TMP ? "[file]" : "", ed.event, strrchr(id, ' ') + 1);
			continue;

		case 's':
			nonzero();
			substitute(ed.global != 0);
			continue;

		case 't':
			move(1);
			continue;

		case 'u':
			setnoaddr();
			newline();
			undo();
			continue;

		case 'V':
			global(0, 1);
			continue;

		case 'v':
			global(0, 0);
			continue;

		case 'W':
		case 'w':
			setwide();
			squeeze(ed.dol > ed.zero);
			if ((n = getchr()) != 'q' && n != 'Q') {
				ed.peekc = n;
				n = 0;
			}
			filename(c);
			if (ed.dol > ed.zero)
				putfile();
			exfile();
			if (n == 'Q' || ed.addr1 <= ed.zero + 1 && ed.addr2 == ed.dol)
				ed.modified = 0;
			if (n)
				quit(0);
			continue;

		case 'z':
			nonzero();
			page();
			continue;

		case '=':
			setwide();
			squeeze(0);
			newline();
			sfprintf(ed.msg, "%d\n", ed.addr2 - ed.zero);
			continue;

		case '!':
			shell();
			continue;

		case '#':
			setnoaddr();
			getrec(ed.buffer.line, '\n', REC_IGNORE);
			continue;

		case EOF:
			return;

		}
		error(2, "unknown command");
	}
}

int
main(int argc, char** argv)
{
	NoP(argc);
	error_info.id = "ed";
	error_info.write = helpwrite;
	init();
	for (;;)
	{
		for (;;) {
			switch (optget(argv, "hop:[prompt]qs [file]")) {

			case 'h':
				ed.help = 1;
				continue;

			case 'o':
				ed.msg = sfstderr;
				sfstrset(ed.buffer.file, 0);
				sfputr(ed.buffer.file, "/dev/stdout", 0);
				continue;

			case 'p':
				sfstrset(ed.buffer.prompt, 0);
				sfputr(ed.buffer.prompt, opt_info.arg, 0);
				ed.prompt = 1;
				continue;

			case 'q':
				signal(SIGQUIT, SIG_DFL);
				ed.verbose = 1;
				continue;

			case 's':
				ed.verbose = 0;
				continue;

			case 0:
				break;

			case '?':
				error(ERROR_USAGE|4, opt_info.arg);
				break;

			case ':':
				error(2, opt_info.arg);
				break;

			}
			break;
		}
		if (!*(argv += opt_info.index) || **argv != '-' || *(*argv + 1))
			break;
		ed.verbose = 0;
	}
	if (*argv) {
		if (*(argv + 1))
			error(ERROR_USAGE|4, opt_info.arg);
		sfprintf(ed.buffer.global, "e %s", *argv);
		ed.global = sfstruse(ed.buffer.global);
	}
	edit();
	sfslowio(sfstdin);
	setjmp(ed.again);
	commands();
	quit(0);
	exit(0);
}
#pragma prototyped

#include <ast.h>
#include <ctype.h>
#include <error.h>
#include <regex.h>

static const char id[] = "\n@(#)grep (AT&T Research) 01/01/96\0\n";

/*
 * snarfed from Doug McElroy's C++ version
 *
 * this grep is based on the Posix re package.
 * unfortunately it has to have a nonstandard interface.
 * 1. fgrep does not have usual operators. REG_LITERAL
 * caters for this.
 * 2. grep allows null expressions, hence REG_NULL.
 * 3. it may be possible to combine the multiple 
 * patterns of grep into single patterns.  important
 * special cases are handled by regcomb().
 * 4. anchoring by -x has to be done separately from
 * compilation (remember that fgrep has no ^ or $ operator),
 * hence REG_LEFT|REG_RIGHT.  (An honest, but slow alternative:
 * run regexec with REG_NOSUB off and nmatch=1 and check
 * whether the match is full length)
 */

typedef struct Item			/* list item			*/
{
	struct Item*	next;		/* next in list			*/
	union
	{
	regex_t		re;		/* re value - sue me for waste	*/
	char*		string;		/* string value			*/
	}		value;
} Item_t;

typedef struct				/* generic list			*/
{
	Item_t*		head;		/* list head			*/
	Item_t*		tail;		/* list tail			*/
} List_t;

static struct				/* program state		*/
{
	List_t		files;		/* pattern file list		*/
	List_t		patterns;	/* pattern list			*/
	List_t		res;		/* re list			*/

	int		code;		/* no hits exit code		*/
	int		hits;		/* if any patterns hit		*/
	int		options;	/* regex options		*/

	unsigned char	count;		/* count number of hits		*/
	unsigned char	list;		/* list files with hits		*/
	unsigned char	match;		/* match sense			*/
	unsigned char	query;		/* return status but no output	*/
	unsigned char	number;		/* line numbers			*/
	unsigned char	prefix;		/* print file prefix		*/
	unsigned char	suppress;	/* no unopenable file messages	*/
} state;

static void
fatal(int result)
{
	char	buf[128];

	if (result && result != REG_NOMATCH)
	{
		regerror(result, 0, buf, sizeof(buf));
		error(3, "%s", buf);
	}
}

static void
addre(List_t* p, char* s)
{
	int	result;
	Item_t*	x;

	if (!(x = newof(0, Item_t, 1, 0)))
		error(ERROR_SYSTEM|3, "out of space (pattern `%s')", s);
	if (result = regcomp(&x->value.re, s, state.options))
		fatal(result);
	if (!p->head)
		p->head = p->tail = x;
	else if (regcomb(&p->tail->value.re, &x->value.re))
		p->tail = p->tail->next = x;
	else free(x);
}

static void
addstring(List_t* p, char* s)
{
	Item_t*	x;

	if (!(x = newof(0, Item_t, 1, 0)))
		error(ERROR_SYSTEM|3, "out of space (string `%s')", s);
	x->value.string = s;
	if (p->head) p->tail->next = x;
	else p->head = x;
	p->tail = x;
}

/*
 * the update s = t+1 flagged below is formally illegal when
 * t==0, but what run-time system will catch it?
 */

static void
compile(void)
{
	int	i;
	int	line;
	char*	s;
	char*	t;
	char*	file;
	Item_t*	x;
	Sfio_t*	f;

	for (x = state.patterns.head; x; x = x->next)
		for (t = s = x->value.string; t; s = t + 1) /* see above */
		{
			if (t = strchr(s, '\n'))
				*t = 0;
			addre(&state.res, s);
		}	
	for (x = state.files.head; x; x = x->next)
	{
		s = x->value.string;
		if (f = sfopen(NiL, s, "r"))
		{
			file = error_info.file;
			error_info.file = s;
			line = error_info.line;
			error_info.line = 0;
			while (s = sfgetr(f, '\n', 1))
			{
				error_info.line++;
				addre(&state.res, s);
			}
			error_info.file = file;
			error_info.line = line;
			sfclose(f);
		}
		else if (!state.suppress)
			error(ERROR_SYSTEM|4, "%s: cannot open", s);
		else state.code = 2;
	}
	if (!(x = state.res.head))
		error(3, "no pattern#1");
}

static void
execute(Sfio_t* input, char* name)
{
	char*		s;
	char*		file;
	Item_t*		x;
	int		result;
	int		line;
	unsigned long	hits = 0;
	
	file = error_info.file;
	if (!(error_info.file = name))
		name = "(standard input)";
	line = error_info.line;
	error_info.line = 0;
	while (s = sfgetr(input, '\n', 1))
	{
		error_info.line++;
		for (x = state.res.head; x; x = x->next)
		{
			if (!(result = regexec(&x->value.re, s, 0, 0, 0)))
				break;
			if (result != REG_NOMATCH)
				fatal(result);
		}
		if ((x != 0) == state.match)
		{
			hits++;
			if (state.query || state.list)
				break;
			if (state.count)
				continue;
			if (state.prefix)
				sfprintf(sfstdout, "%s:", name);
			if (state.number)
				sfprintf(sfstdout, "%d:", error_info.line);
			sfprintf(sfstdout, "%s\n", s);
		}
	}
	error_info.file = file;
	error_info.line = line;
	if (hits)
	{
		state.hits = 1;
		if (state.query)
			return;
		if (state.list)
			sfprintf(sfstdout, "%s\n", name);
	}
	if (!state.list && state.count)
	{
		if (state.prefix)
			sfprintf(sfstdout, "%s:", name);
		sfprintf(sfstdout, "%d\n", hits);
	}
}

main(int argc, char** argv)
{
	int	c;
	char*	s;
	Sfio_t*	f;

	state.match = 1;
	state.options = REG_NOSUB|REG_NULL;
	state.code = 1;
	if (s = strrchr(argv[0], '/')) s++;
	else s = argv[0];
	switch (*s)
	{
	case 'a':
	case 'A':
		s = "agrep";
		state.options |= REG_AUGMENTED;
		break;
	case 'e':
	case 'E':
		s = "egrep";
		state.options |= REG_EXTENDED;
		break;
	case 'f':
	case 'F':
		s = "fgrep";
		state.options |= REG_LITERAL;
		break;
	default:
		s = "grep";
		break;
	}
	error_info.id = s;
	while (c = optget(argv, "AEFchilqnsvxe:[pattern]f:[file] [file ...]"))
		switch (c)
		{
		case 'A':
			state.options |= REG_AUGMENTED;
			break;
		case 'E':
			state.options |= REG_EXTENDED;
			break;
		case 'F':
			state.options |= REG_LITERAL;
			break;
		case 'c':
			state.count = 1;
			break;
		case 'e':
			addstring(&state.patterns, opt_info.arg);
			break;
		case 'f':
			addstring(&state.files, opt_info.arg);
			break;
		case 'h':
			state.prefix = 0;
			break;
		case 'i':
			state.options |= REG_ICASE;
			break;
		case 'l':
			state.list = 1;
			break;
		case 'n':
			state.number = 1;
			break;
		case 'q':
			state.query = 1;
			break;
		case 's':
			state.suppress = 1;
			break;
		case 'v':
			state.match = 0;
			break;
		case 'x':
			state.options |= REG_LEFT|REG_RIGHT;
			break;
		case '?':
			error(ERROR_USAGE|4, opt_info.arg);
			break;
		case ':':
			error(2, opt_info.arg);
			break;
		}
	argv += opt_info.index;
	if ((state.options & (REG_AUGMENTED|REG_LITERAL)) == (REG_AUGMENTED|REG_LITERAL))
		error(3, "-A and -F are incompatible");
	if ((state.options & (REG_EXTENDED|REG_LITERAL)) == (REG_EXTENDED|REG_LITERAL))
		error(3, "-E and -F are incompatible");
	if (!state.files.head && !state.patterns.head)
	{
		if (!argv[0])
			error(3, "no pattern");
		addstring(&state.patterns, *argv++);
	}
	compile();
	if (!argv[0])
		execute(sfstdin, NiL);
	else
	{
		if (!state.prefix && argv[1])
			state.prefix = 1;
		while (s = *argv++)
		{
			if (f = sfopen(NiL, s, "r"))
			{
				execute(f, s);
				sfclose(f);
			}
			else if (!state.suppress)
				error(ERROR_SYSTEM|4, "%s: cannot open", s);
			else state.code = 2;
			if (state.query && state.hits)
				break;
		}
	}
	exit(state.hits ? 0 : state.code);
}
#pragma prototyped

#include <ast.h>
#include <error.h>

#include "regex.h"

typedef unsigned char uchar;

typedef struct {
	uchar *w;		/* write pointer */
	uchar *e;		/* end */
	uchar *s;		/* start */
} Text;

extern void compile(Text *script, Text *raw);
extern void execute(Text *script, Text *input);
extern int recomp(Text *script, Text *t, int seof);
extern int match(uchar *re, Text *data, int gflag);
extern int substitute(regex_t*, Text* data, uchar *rhs, int gf);
extern regex_t *readdr(int addr);
extern void tcopy(Text *from, Text *to);
void printscript(Text *script);
extern void vacate(Text*);
extern void synwarn(char*);
extern void syntax(char*);
extern int readline(Text*);
extern int ateof(void);
extern void coda(void);

#define exch(a, b, t) ((t)=(a), (a)=(b), (b)=(t))
	
	/* space management; assure room for n more chars in Text */
#define assure(/*Text*/t, /*int*/ n) 		\
	do if((t)->s==0 || (t)->w>=(t)->e-n-1) grow(t, n);while(0)
extern void grow(Text*, int);

	/* round character pointer up to integer pointer.
	   portable to the cray; simpler tricks are not */

#define intp(/*uchar**/p) (int*)(p + sizeof(int) - 1 \
			- (p+sizeof(int)-1 - (uchar*)0)%sizeof(int))

extern int reflags;
extern int recno;
extern int nflag;
extern int qflag;
extern int sflag;
extern int bflag;
extern char *stdouterr;

extern Text files;

/* SCRIPT LAYOUT

   script commands are packed thus:
   0,1,or2 address words signed + for numbers - for regexp
   if 2 addresses, then another word indicates activity
	positive: active, the record number where activated
	negative: inactive, sign or-ed with number where deactivated
   instruction word
	high byte IMASK+flags; flags are NEG and SEL
	next byte command code (a letter)
	next two bytes, length of this command, including addrs
        (length is a multiple of 4; capacity could be expanded
	by counting the length in words instead of bytes)
   after instruction word
	on s command
		offset of regexp in rebuf
		word containing flags p,w plus n (g = >n=0)
		replacement text
		word containing file designator, if flag w
	on y command
		256-byte transliteration table
	on b and t command
		offset of label in script
*/

#define BYTE		CHAR_BIT
#define IMASK		0xC0000000	/* instruction flag */
#define NEG  		0x01000000	/* instruction written with ! */
#define LMASK		0xffff		/* low half word */
#define AMASK		0x7fffffff	/* address mask, clear sign bit */
#define INACT		(~AMASK)	/* inactive bit, the sign bit */
#define DOLLAR		AMASK		/* huge address */
#define REGADR		(~AMASK)	/* context address */
#define PFLAG		0x80000000	/* s/../../p */
#define WFLAG		0x40000000	/* s/../../g */

extern int pack(int neg, int cmd, int length);
extern int *instr(uchar*);
#define code(/*int*/ inst) ((inst)>>2*BYTE & 0xff)
#define nexti(/*uchar**/ p) ((p) + (*instr(p)&LMASK))
#pragma prototyped

#include "sed.h"

static const char id[] = "\n@(#)sed (AT&T Research) 01/01/96\0\n";

void	readscript(Text*, char*);
void	copyscript(Text*, uchar*);
void	initinput(int, char **);
Sfio_t*	aopen(char*);

#define ustrncmp(a,b,c) (uchar*)strncmp((char*)(a), (char*)(b), c)

int reflags;		/* regcomp() flags */
int recno;		/* current record number */
int nflag;		/* nonprint option */
int qflag;		/* command q executed */
int sflag;		/* substitution has occurred */
int bflag;		/* strip leading blanks from c,a,i <text> */

main(int argc, char **argv)
{
	int c;
	static Text script;
	static Text data;
	error_info.id = "sed";
	while (c = optget(argv, "bdne:[expression]f:[script]AE [file ...]"))
		switch (c)
		{
		case 'A':
			reflags |= REG_AUGMENTED;
			break;
		case 'E':
			reflags |= REG_EXTENDED;
			break;
		case 'b':
			bflag++;
			break;
		case 'e':
			copyscript(&data, (uchar*)opt_info.arg);
			break;
		case 'f':
			readscript(&data, opt_info.arg);
			break;
		case 'n':
			nflag++;
			break;
		case '?':
			error(ERROR_USAGE|4, opt_info.arg);
			break;
		case ':':
			error(2, opt_info.arg);
			break;
		}
	if (error_info.errors)
		error(ERROR_USAGE|4, optusage(NiL));
	argv += opt_info.index;
	argc -= opt_info.index;
	if(data.s == 0) {
		if(!*argv)
			error(3, "no script");
		copyscript(&data, (uchar*)*argv++);
		argc--;
	}
	if(ustrncmp(data.s, "#n", 2) == 0)
		nflag = 1;
	copyscript(&data, (uchar*)"\n\n");  /* e.g. s/a/\ */
	compile(&script, &data);
#if DEBUG
	printscript(&script);
#endif

	initinput(argc, argv);
	for(;;) {
		data.w = data.s;
		if(!readline(&data))
			break;
		execute(&script, &data);
	}
	if(sfclose(sfstdout) == EOF)
		error(3, stdouterr);
	return 0;
}

void
grow(Text *t, int n)
{
	int w = t->w - t->s;
	int e = t->e - t->s + (n/SF_BUFSIZE+1)*SF_BUFSIZE;
	t->s = (uchar*)realloc(t->s, e);
	if(t->s == 0)
		error(3, "out of space");
	t->w = t->s + w;
	t->e = t->s + e;
}

/* BUG: a segment that ends with a comment whose
   last character is \ causes a diagnostic */

void
safescript(Text *t)
{
	if(t->w > t->s+1 && t->w[-2] == '\\')
		error(1, "script segment ends with \\");
}

void
readscript(Text *t, char *s)
{
	int n;
	Sfio_t *f = aopen(s);
	for(;;) {
		assure(t, 4);
		n = sfread(f, t->w, t->e - t->w - 3);
		if(n <= 0)
			break;
		t->w += n;
	}
	sfclose(f);
	if(t->w > t->s && t->w[-1] != '\n') {
		*t->w++ = '\n';
		error(1, "newline appended to script segment");
	}
	*t->w = 0;
	safescript(t);
}

void
copyscript(Text *t, uchar *s)
{
	do {
		assure(t, 2);
	} while(*t->w++ = *s++);
	if(--t->w > t->s && t->w[-1] != '\n') {
		*t->w++ = '\n';
		*t->w = 0;
	}
	safescript(t);
}

/* DATA INPUT */

struct {
	int iargc;		/* # of files not fully read */
	char **iargv;		/* current file */
	Sfio_t *ifile;		/* current input file */
} input;

int
readline(Text *t)
{
	char*	s;
	int	c;

	coda();
	if (qflag || ateof())
		return 0;
	while (!(s = sfgetr(input.ifile, '\n', 1)))
	{
		if (s = sfgetr(input.ifile, '\n', -1))
		{
			error(1, "newline appended");
			break;
		}
		error_info.file = 0;
		error_info.line = 0;
		if (--input.iargc <= 0)
			return 0;
		sfclose(input.ifile);
		input.ifile = aopen(*++input.iargv);
		error_info.file = *input.iargv;
	}
	c = sfslen();
	assure(t, c);
	memcpy(t->w, s, c);
	t->w += c - 1;

	/*
	 * peek ahead to identify line $
	 */

	if ((c = sfgetc(input.ifile)) != EOF)
		sfungetc(input.ifile, c);
	else if (input.iargc == 1)
		input.iargc = 0;
	error_info.line++;
	recno++;
	sflag = 0;
	return 1;
}	

int 
ateof(void)
{
	return input.iargc <= 0;
}	

void
initinput(int argc, char **argv)
{
	input.iargc = argc;
	input.iargv = argv;
	if(input.iargc == 0) {
		input.iargc = 1;	/* for ateof() */
		input.ifile = sfstdin;
	} else {
		input.ifile = aopen(*input.iargv);
		error_info.file = *input.iargv;
	}
}

Sfio_t *
aopen(char *s)
{
	Sfio_t *f = sfopen(NiL, s, "r");
	if(f == 0)
		error(ERROR_SYSTEM|3, "%s: cannot open", s);
	return f;
}

#if DEBUG & 1

/* debugging code 1; compile and execute stubs.
   simply prints the already collected script and
   prints numbered input lines */

void
compile(Text *script, Text *t)
{
	uchar *s = t->s;
	assure(script, 1);
	*script->w++ = 0;
	while(*s) sfputc(sfstdout, *s++);
}

void
execute(Text *x, Text *y)
{
	x = x;		
	sfprintf(sfstdout, "%d: %s", recno, y->s);
}

#endif
#pragma prototyped

#include "sed.h"

#include <ctype.h>

#define ustrlen(p) strlen((char*)(p))
#define ustrcmp(p, q) strcmp((char*)(p), (char*)(q))
#define ustrcpy(p, q) (uchar*)strcpy((char*)(p), (char*)(q))
#define ustrchr(p, c) (uchar*)strchr((char*)(p), c)

int blank(Text*);
void fixlabels(Text*);
void fixbrack(Text*);
void ckludge(Text*, int, int, int, Text*);
int addr(Text*, Text*);
int pack(int, int, int);
int* instr(uchar*);
uchar *succi(uchar*);

#if DEBUG
extern void regdump(regex_t*);	/* secret entry into regex pkg */
#endif

int semicolon;
Text rebuf;

uchar adrs[256] = {	/* max no. of addrs, 3 is illegal */
	0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, /* <nl> */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 2, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* !# */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 1, 3, 3, /* := */
	3, 3, 3, 3, 2, 3, 3, 2, 2, 3, 3, 3, 3, 3, 2, 3, /* DGHN */
	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* P */
	3, 1, 2, 2, 2, 3, 3, 2, 2, 1, 3, 3, 2, 3, 2, 3, /* a-n */
	2, 1, 2, 2, 2, 3, 3, 2, 2, 2, 3, 2, 3, 0, 3, 3, /* p-y{} */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
};

#define Ec Tc	/* commands that have same compilation method */
#define Dc Tc
#define Gc Tc
#define Hc Tc
#define Nc Tc
#define Pc Tc
#define dc Tc
#define gc Tc
#define hc Tc
#define lc Tc
#define nc Tc
#define pc Tc
#define qc Tc
#define xc Tc
#define tc bc
#define ic ac
#define cc ac

uchar *synl;	/* current line pointer for syntax errors */

/* COMMAND LAYOUT */

int
blank(Text *t)
{
	if(*t->w==' ' || *t->w=='\t') {
		t->w++;
		return 1;
	} else
		return 0;
}

int *
instr(uchar *p)		/* get address of command word */
{
	int *q = (int*)p;
	while((*q & IMASK) != IMASK)
		q++;
	return q;
}

uchar *
succi(uchar *p)
{
	int *q = instr(p);
	if(code(*q) == '{')
		return (uchar*)(q+1);
	else
		return p + (*q & LMASK);
}

int
pack(int neg, int cmd, int length)
{
	int l = length & LMASK;
	if(length != l)
		syntax("<command-list> or <text> too long");
	return IMASK | neg | cmd << 2*BYTE | l;
}

void
putint(Text *s, int n)
{
	assure(s, sizeof(int));
	*(int*)s->w = n;
	s->w += sizeof(int);
}

int
number(Text *t)
{
	unsigned n = 0;
	while(isdigit(*t->w)) {
		if(n > (INT_MAX-9)/10)
			syntax("number too big");
		n = n*10 + *t->w++ - '0';
	}
	return n;
}	

int
addr(Text *script, Text *t)
{
	int n;
	switch(*t->w) {
	default:
		return 0;
	case '$':
		t->w++;
		n = DOLLAR;
		break;
	case '\\':
		t->w++;
		if(*t->w=='\n' ||*t->w=='\\')
			syntax("bad regexp delimiter");
	case '/':
		n = recomp(&rebuf, t, *t->w++) | REGADR;
		break;
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		n = number(t);
		if(n == 0)
			syntax("address is zero");
	}
	putint(script, n);
	return 1;
}

regex_t *
readdr(int x)
{
	return (regex_t*)(rebuf.s + (x&AMASK));
}

/* LABEL HANDLING */

/* the labels array consists of int values followed by strings.
   value -1 means unassigned; other values are relative to the
   beginning of the script 

   on the first pass, every script ref to a label becomes the
   integer offset of that label in the labels array, or -1 if
   it is a branch to the end of script

   on the second pass (fixlabels), the script ref is replaced
   by the value from the labels array. */

Text labels;

int *
lablook(uchar *l, Text *labels)
{
	uchar *p, *q;
	int n;
	assure(labels, 1);
	for(p = labels->s; p < labels->w; ) {
		q = p + sizeof(int);
		if(ustrcmp(q, l) == 0)
			return (int*)p;
		q += ustrlen(q) + 1;
		p = (uchar*)intp(q);
	}
	n = ustrlen(l);
	assure(labels, sizeof(int)+n+1+sizeof(int));
	*(int*)p = -1;
	q = p + sizeof(int);
	ustrcpy(q, l);
	q += ustrlen(q) + 1;
	labels->w = (uchar*)intp(q);
	return (int*)p;
}

/* find pos in label list; assign value i to label if i>=0 */

int
getlab(Text *t, int i)
{
	int *p;
	uchar *u;
	while(blank(t));	/* not exactly posix */
	for(u=t->w; *t->w!='\n'; t->w++)
		if(!isprint(*t->w) || *t->w==' ')
			synwarn("invisible character in name");
	if(u == t->w)
		return -1;
	*t->w = 0;
	p = lablook(u, &labels);
	if(*p == -1)
		*p = i;
	else if(i != -1)
		syntax("duplicate label");
	*t->w = '\n';
	return (uchar*)p - labels.s;
}

void
Cc(Text *script, Text *t)	/* colon */
{
	if(getlab(t, script->w - sizeof(int) - script->s) == -1)
		syntax("missing label");
}

void
bc(Text *script, Text *t)
{
	int g;
	g = getlab(t, -1);	/* relative pointer to label list */
	putint(script, g);
}
			
void
fixlabels(Text *script)
{
	uchar *p;
	int *q;
	for(p=script->s; p<script->w; p=succi(p)) {
		q = instr(p);
		switch(code(*q)) {
		case 't':
		case 'b':
			if(q[1] == -1)
				q[1] = script->w - script->s;
			else if(*(int*)(labels.s+q[1]) != -1)
				q[1] = *(int*)(labels.s+q[1]);
			else
				error(3, "undefined label: %s",
					labels.s+q[1]+sizeof(int));
		}
	}
	free(labels.s);
}

/* FILES */

Text files;

void
rc(Text *script, Text *t)
{
	uchar *u;
	if(!blank(t))
		synwarn("no space before file name");
	while(blank(t)) ;
	for(u=t->w; *t->w!='\n'; t->w++) ;
	if(u == t->w)
		syntax("missing file name");
	*t->w = 0;
	putint(script, (uchar*)lablook(u, &files) - files.s);
	*t->w = '\n';
}

void
wc(Text *script, Text *t)
{
	int *p;
	rc(script, t);
	p = (int*)(files.s + ((int*)script->w)[-1]);
	if(*p != -1)
		return;
	*(Sfio_t**)p = sfopen(NiL, (char*)(p+1), "w");
	if(*p == 0)
		syntax("can't open file for writing");
}

/* BRACKETS */

Text brack;

/* Lc() stacks (in brack) the location of the { command word.
   Rc() stuffs into that word the offset of the } sequel
   relative to the command word.
   fixbrack() modifies the offset to be relative to the
   beginning of the instruction, including addresses. */

void				/* { */
Lc(Text *script, Text *t)
{
	while(blank(t));
	putint(&brack, script->w - sizeof(int) - script->s);
}

void				/* } */
Rc(Text *script, Text *t)
{
	int l;
	int *p;
	t = t;
	if(brack.w == 0 || (brack.w-=sizeof(int)) < brack.s)
		syntax("unmatched }");
	l = *(int*)brack.w;
	p = (int*)(script->s + l);
	l = script->w - script->s - l;
	if(l >= LMASK - 3*sizeof(int))	/* fixbrack could add 3 */
		syntax("{command-list} too long)");
	*p = (*p&~LMASK) | l;
}

void
fixbrack(Text *script)
{
	uchar *p;
	int *q;
	if(brack.w == 0)
		return;
	if(brack.w > brack.s)
		syntax("unmatched {");
	for(p=script->s; p<script->w; p=succi(p)) {
		q = instr(p);
		if(code(*q) == '{')
			*q += (uchar*)q - p;
	}
	free(brack.s);
}

/* EASY COMMANDS */

void
Xc(Text *script, Text *t)	/* # */
{
	script = script;	/* avoid use/set diagnostics */
	if(t->s[1]=='n')
		nflag = 1;
	while(*t->w != '\n')
		t->w++;
}

void
Ic(Text *script, Text *t)	/* ignore */
{
	script = script;
	t->w--;
}

void
Tc(Text *script, Text *t)	/* trivial to compile */
{
	script = script;
	t = t;
}

void
xx(Text *script, Text *t)
{
	script = script;
	t = t;
	syntax("unknown command");
}

/* MISCELLANY */

void
ac(Text *script, Text *t)
{
	if(*t->w++ != '\\' || *t->w++ != '\n')
		syntax("\\<newline> missing after command");
	for(;;) {
		while(bflag && blank(t)) ;
		assure(script, 2 + sizeof(int));
		switch(*t->w) {
		case 0:
			error(ERROR_PANIC|4, "bug: missed end of <text>");
		case '\n':
			*script->w++ = *t->w;
			*script->w++ = 0;
			script->w = (uchar*)intp(script->w);
			return;
		case '\\':
			t->w++;
		default:
			*script->w++ = *t->w++;
		}
	}
}
void
yc(Text *script, Text *t)
{
	int i;
	int delim = *t->w++;
	uchar *s = script->w;
	uchar *p, *q;
	if(delim == '\n' || delim=='\\')
		syntax("missing delimiter");
	assure(script, 256);
	for(i=0; i<256; i++) 
		s[i] = 0;
	for(q=t->w; *q!=delim; q++)
		if(*q == '\n')
			syntax("missing delimiter");
		else if(*q=='\\' && q[1]==delim)
			q++;
	for(p=t->w, q++; *p != delim; p++, q++) {
		if(*p=='\\' && p[1]==delim)
			p++;
		if(*q == '\n')
			syntax("missing delimiter");
		if(*q == delim)
			syntax("string lengths differ");
		if(*q=='\\' && q[1]==delim)
			q++;
		if(s[*p] && s[*p]!=*q)
			syntax("ambiguous map");
		if(s[*p])
			synwarn("redundant map");
		s[*p] = *q;
	}
	if(*q++ != delim)
		syntax("string lengths differ");
	for(i=0; i<256; i++)
		if(s[i] == 0)
			s[i] = i;
	t->w = q;
	script->w += 256;
}

void
sc(Text *script, Text *t)
{
	int c, flags, re, nsub;
	int *q;
	int n = -1;
	int delim = *t->w++;
	switch(delim) {
	case '\n':
	case '\\':
		syntax("improper delimiter");
	}
	re = recomp(&rebuf, t, delim);
	putint(script, re);
	nsub = readdr(re)->re_nsub;
	flags = script->w - script->s;
	putint(script, 0);		/* space for flags */
	while((c=*t->w++) != delim) {
		assure(script, 3+sizeof(int*));
		if(c == '\n')
			syntax("unterminated command");
		else if(c == '\\') {
			int d = *t->w++;
			if(d==delim)
				;
			else if(d=='&' || d=='\\')
				*script->w++ = c;
			else if(d>='0' && d<='9') {
				if(d > '0'+nsub)
					syntax("improper backreference");
				*script->w++ = c;
			}
			c = d;
		}
		*script->w++ = c;
	}
	*script->w++ = 0;
	script->w = (uchar*)intp(script->w);
	q = (int*)(script->s + flags);
	*q = 0;
	for(;;) {
		switch(*t->w) {
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			if(n != -1)
				syntax("extra flags");
			n = number(t);
			if(n == 0 || (n&(PFLAG|WFLAG)) != 0)
				syntax("count out of range");
			continue;
		case 'p':
			if(*q & PFLAG)
				syntax("extra flags");
			t->w++;
			*q |= PFLAG;
			continue;
		case 'g':
			t->w++;
			if(n != -1)
				syntax("extra flags");
			n = 0;
			continue;
		case 'w':
			t->w++;
			*q |= WFLAG;	 
			wc(script, t);
		}
		break;
	}
	*q |= n==-1? 1: n;
}		

void
synwarn(char *s)
{
	uchar *t = ustrchr(synl, '\n');
	error(1, "%s: %.*s", s, t-synl, synl);
}

void
syntax(char *s)
{
	uchar *t = ustrchr(synl, '\n');
	error(3, "%s: %.*s", s, t-synl, synl);
}

#if DEBUG

void
printscript(Text *script)
{
	uchar *s;
	int *q;
	for(s=script->s; s<script->w; s = succi(s)) {
		q = (int*)s;
		if((*q&IMASK) != IMASK) {
			if((*q&REGADR) == 0)
				printf("%d", *q);
			else
				regdump((regex_t*)(*q & AMASK));
			q++;
		}
		if((*q&IMASK) != IMASK) {
			if((*q&REGADR) == 0)
				printf(",%d", *q);
			else
				regdump((regex_t*)(*q & AMASK));
			q += 2;
		}
		if(code(*q) == '\n')
			continue;
		printf("%s%c\n", *q&NEG?"!":"", code(*q));
	}	
}

#endif

#if DEBUG & 2

/* debugging code 2; execute stub.
   prints the compiled script (without arguments)
   then each input line with line numbers */

void
execute(Text *script, Text *y)
{
	if(recno == 1)
		printscript(script);
	printf("%d:%s",recno,y->s);
}

#endif

typedef void (*cmdf)(Text*, Text*);

static cmdf docom[128] = {
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,Ic,xx,xx,xx,xx,xx, /* <nl> */
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,
	xx,Ic,xx,Xc,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx, /* !# */
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,Cc,Ic,xx,Ec,xx,xx, /* :;= */
	xx,xx,xx,xx,Dc,xx,xx,Gc,Hc,xx,xx,xx,xx,xx,Nc,xx, /* DGHN */
	Pc,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx, /* P */
	xx,ac,bc,cc,dc,xx,xx,gc,hc,ic,xx,xx,lc,xx,nc,xx, /* a-n */
	pc,qc,rc,sc,tc,xx,xx,wc,xc,yc,xx,Lc,xx,Rc,xx,xx  /* p-y{} */
};


void
compile(Text *script, Text *t)
{
	int loc;	/* progam counter */
	int neg;	/* ! in effect */
	int cmd;
	int naddr;
	int *q;		/* address of instruction word */
	t->w = t->s;	/* here w is a read pointer */
	while(*t->w) {
		assure(script, 4*sizeof(int));
		loc = script->w - script->s;
		synl = t->w;
		naddr = 0;
		while(blank(t)) ;
		naddr += addr(script, t);
		if(naddr && *t->w ==',') {
			t->w++;
			naddr += addr(script, t);
			if(naddr < 2)
				syntax("missing address");
		}
		q = (int*)script->w;
		if(naddr == 2)
			*q++ = INACT;
		script->w = (uchar*)(q+1);
		neg = 0;
		for(;;) {
			while(blank(t));
			cmd = *t->w++;
			if(neg && docom[cmd&0xff]==Ic)
				syntax("improper !");
			if(cmd != '!')
				break;
			neg = NEG;
		}
		if(!neg) {
			switch(adrs[cmd]) {
			case 1:
				if(naddr <= 1)
					break;
			case 0:
				if(naddr == 0)
					break;
				syntax("too many addresses");
			}
		}
		(*docom[cmd&0xff])(script, t);
		switch(*t->w) {
		case 0:
			script->w = script->s + loc;
			break;
		default:
			if(cmd == '{')
				break;
			syntax("junk after command");
		case ';':
			if(!semicolon++)
				synwarn("semicolon separators");
		case '\n':
				t->w++;
		}
		*q = pack(neg,cmd,script->w-script->s-loc);
	}
	fixbrack(script);
	fixlabels(script);
}
#pragma prototyped

#include "sed.h"

#include <ctype.h>

#define ustrchr(p, c) (uchar*)strchr((char*)(p), c)

int selected(uchar*, Text*);

#define Re Ie
#define Ce Ie
#define Se Ie
#define re ae

#define IBUG "interpreter bug %d"
char *stdouterr = "writing standard output";

Text hold;

void
cputchar(int c)
{
	if(sfputc(sfstdout, c) == EOF)
		error(3, stdouterr);
}

void
writeline(Text *data)
{
	int n = data->w - data->s;
	if(sfwrite(sfstdout, data->s, n) != n)
		error(ERROR_SYSTEM|3, stdouterr);
	cputchar('\n');
}

/* return 1 if action is to be taken on current line,
         -1 if (numeric) address has been passed,
	  0 otherwise*/
int
sel1(int addr, Text *data)
{
	if(addr & REGADR)
		return regexec(readdr(addr),(char*)data->s,0,0,0) == 0;
	if(addr == recno)
		return 1;
	if(addr == DOLLAR)
		return ateof();
	if(addr < recno)
		return -1;
	return 0;
}

/* return 2 on non-final line of a selected range,
          1 on any other selected line,
	  0 on non-selected lines 
   (the 1-2 distinction matters only for 'c' commands) */

int
selected(uchar *pc, Text *data)
{
	int active;
	int *ipc = (int*)pc;	/* points to address words */
	int *q = instr(pc);	/* points to instruction word */
	int neg = !!(*q & NEG);
	switch(q - ipc)	{
	case 0:			/* 0 address */
		return !neg;
	case 1:			/* 1 address */
		return neg ^ sel1(ipc[0], data)==1;
	case 2:
		error(ERROR_PANIC|4, IBUG,1);
	case 3:			/* 2 address */
		q--;		/* points to activity indicator */
		active = !(*q & INACT);
		if((*q&AMASK) < recno) {
			switch(sel1(ipc[active], data)) {
			case 0:
				if((active&ateof()) == 0)
					break;
			case 1:
				*q = recno;
				if(active)
					*q |= INACT;
				return (neg^1) << (!active&!ateof());
			case -1:
				if(active) {
					*q = recno | INACT;
					return neg;
				}
			}
		}
		return (neg^active) << 1;
	default:
		error(ERROR_PANIC|4, IBUG,2);
		return 0;	/* dummy */
	}
}

void
vacate(Text *t)
{
	assure(t, 1);
	t->w = t->s;
	*t->w = 0;
}

void
tcopy(Text *from, Text *to)
{
	int n = from->w - from->s;
	assure(to, n+1);
	memmove(to->w, from->s, n);
	to->w += n;
	*to->w = 0;
}
	

/* EASY COMMANDS */

uchar *
vv(Text *script, uchar *pc, Text *data)
{
	script = script;
	pc = pc;
	data = data;
	error(ERROR_PANIC|4, IBUG,3);
	return 0;	/* dummy */
}

uchar *
be(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return script->s + instr(pc)[1];
}

uchar *
de(Text *script, uchar *pc, Text *data)
{
	pc = pc;
	vacate(data);
	return 0;
}

uchar *
De(Text *script, uchar *pc, Text *data)
{
	int n;
	uchar *end = (uchar*)ustrchr(data->s, '\n');
	if(end == 0)
		return de(script, pc, data);
	end++;
	n = data->w - end;
	memmove(data->s, end, n+1);
	data->w = data->s + n;
	return script->s;
}

uchar *
Ee(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	if(sfprintf(sfstdout, "%d\n", recno) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return nexti(pc);
}

uchar *
Ge(Text *script, uchar *pc, Text *data)
{
	script = script;
	if(hold.s == 0) 
		vacate(&hold);
	if(data->w > data->s)
		*data->w++ = '\n';
	tcopy(&hold, data);
	return nexti(pc);
}

uchar *
ge(Text *script, uchar *pc, Text *data)
{
	vacate(data);
	return Ge(script, pc, data);
}

uchar *
He(Text *script, uchar *pc, Text *data)
{
	script = script;
	assure(&hold, 1);
	*hold.w++ = '\n';
	tcopy(data, &hold);
	return nexti(pc);
}

uchar *
he(Text *script, uchar *pc, Text *data)
{
	script = script;
	vacate(&hold);
	tcopy(data, &hold);
	return nexti(pc);
}

uchar *
Ie(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return nexti(pc);
}

uchar *
ie(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	if(sfprintf(sfstdout, "%s", (char*)(instr(pc)+1)) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return nexti(pc);
}

uchar *
Le(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return (uchar*)(instr(pc)+1);
}

uchar *
Ne(Text *script, uchar *pc, Text *data)
{
	assure(data, 1);
	*data->w++ = '\n';
	if(readline(data))
		return nexti(pc);
	*--data->w = 0;
	return de(script, pc, data);
}

uchar *
ne(Text *script, uchar *pc, Text *data)
{
	if(!nflag)
		writeline(data);
	vacate(data);
	if(readline(data))
		return nexti(pc);
	return 0;
}

uchar *
Pe(Text *script, uchar *pc, Text *data)
{
	int n;
	uchar *end = ustrchr(data->s, '\n');
	if(end == 0)
		n = data->w - data->s;
	else
		n = end - data->s;
	if(sfwrite(sfstdout, data->s, n) != n)
		error(ERROR_SYSTEM|3, stdouterr);
	cputchar('\n');
	script = script;
	return nexti(pc);
}

uchar *
pe(Text *script, uchar *pc, Text *data)
{
	writeline(data);
	script = script;
	return nexti(pc);
}

uchar *
qe(Text *script, uchar *pc, Text *data)
{
	pc = pc;
	data = data;
	qflag++;
	return script->w;
}

uchar *
te(Text *script, uchar *pc, Text *data)
{
	int tflag = sflag;
	sflag = 0;
	if(tflag)
		return be(script, pc, data);
	else
		return nexti(pc);
}

uchar *
ww(Text *script, uchar *pc, Text *data, int offset)
{
	int *q = (int*)(files.s + offset);
	Sfio_t *f = *(Sfio_t**)q;
	int n = data->w - data->s;
	assure(data, 1);
	*data->w = '\n';
	if(sfwrite(f, data->s, n+1) != n+1 ||
	   sfsync(f) == EOF)	/* in case of subsequent r */
		error(ERROR_SYSTEM|3, "%s: cannot write", (char*)(q+1));
	*data->w = 0;
	script = script;
	return nexti(pc);
}

uchar *
we(Text *script, uchar *pc, Text *data)
{
	return ww(script, pc, data, instr(pc)[1]);
}

uchar *
xe(Text *script, uchar *pc, Text *data)
{
	uchar *t;
	script = script;
	if(hold.s == 0)
		vacate(&hold);
	exch(data->s, hold.s, t);
	exch(data->e, hold.e, t);
	exch(data->w, hold.w, t);
	return nexti(pc);
}

uchar *
ye(Text *script, uchar *pc, Text *data)
{
	uchar *s = (uchar*)data->s;
	uchar *w = (uchar*)data->w;
	uchar *tbl = (uchar*)(instr(pc)+1);
	for( ; s<w; s++)
		*s = tbl[*s];
	script = script;
	return nexti(pc);
}

/* MISCELLANY */

uchar *
se(Text *script, uchar *pc, Text *data)
{
	int *q = instr(pc);
	int flags = q[2];
	uchar *p = (uchar*)(flags&WFLAG? q+4: q+3);
	int n = flags & ~(PFLAG|WFLAG);

	sflag = substitute(readdr(q[1]), data, p, n);
	if(!sflag)
		return nexti(pc);
	if(flags & PFLAG)
		pe(script, pc, data);
	if(flags & WFLAG)
		return ww(script, pc, data, ((int*)nexti(pc))[-1]);
	return nexti(pc);
}

struct { char p, q; } digram[] = {
	'\\',	'\\',
	'\a',	'a',
	'\b',	'b',
	'\f',	'f',
	'\n',	'n',
	'\r',	'r',
	'\t',	't',
	'\v',	'v',
};

uchar *
le(Text *script, uchar *pc, Text *data)
{
	int i = 0;
	int j;
	uchar *s;
	script = script;
	for(s=data->s; s<data->w; s++, i++) {
		if(i >= 60) {
			cputchar('\\');
			cputchar('\n');
			i = 0;
		}
		for(j=0; j<sizeof(digram)/sizeof(*digram); j++)
			if(*s == digram[j].p) {
				cputchar('\\');
				cputchar(digram[j].q);
				goto cont;
			}
		if(!isprint(*s)) {
			if(sfprintf(sfstdout, "\\%3.3o", *s) <= 0)
				error(ERROR_SYSTEM|3, stdouterr);
		} else
			cputchar(*s);
	cont:	;
	}
	cputchar('$');
	cputchar('\n');
	return nexti(pc);
}	

/* END-OF-CYCLE STUFF */

Text todo;

uchar *
ae(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	assure(&todo, sizeof(uchar*));
	*(uchar**)todo.w = pc;
	todo.w += sizeof(uchar*);
	return nexti(pc);
}

uchar *
ce(Text *script, uchar *pc, Text *data)
{	
	if(sfprintf(sfstdout, "%s", (char*)(instr(pc)+1)) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return de(script, pc, data);
}

void
coda(void)
{
	int *q;
	uchar *p;
	Sfio_t *f;
	if(todo.s == 0)
		return;
	for(p=todo.s; p<todo.w; p+=sizeof(int)) {
		q = instr(*(uchar**)p);
		switch(code(*q)) {
		case 'a':
			if(sfprintf(sfstdout, "%s", (char*)(q+1)) <= 0)
				error(ERROR_SYSTEM|3, stdouterr);
			continue;
		case 'r':
			f = sfopen(NiL, (char*)(files.s+q[1]+sizeof(int)), "r");
			if(f == 0)
				continue;
			if (sfmove(f, sfstdout, SF_UNBOUND, -1) < 0 || !sfeof(f) || sferror(sfstdout))
				error(ERROR_SYSTEM|3, stdouterr);
			sfclose(f);
			continue;
		default:
			error(ERROR_PANIC|4, IBUG,5);
		}
	}
	vacate(&todo);
}

/* execution functions return pointer to next instruction */

typedef uchar* (*exef)(Text*, uchar *, Text*);

static exef excom[128] = {
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,Ie,vv,vv,vv,vv,vv,
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,
	vv,vv,vv,Ie,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv, /* # */
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,Ce,Se,vv,Ee,vv,vv, /* :;= */
	vv,vv,vv,vv,De,vv,vv,Ge,He,vv,vv,vv,vv,vv,Ne,vv, /* DGHN */
	Pe,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv, /* P */
	vv,ae,be,ce,de,vv,vv,ge,he,ie,vv,vv,le,vv,ne,vv, /* a-n */
	pe,qe,re,se,te,vv,vv,we,xe,ye,vv,Le,vv,Re,vv,vv  /* p-y{} */
};

void
execute(Text *script, Text *data)
{
	uchar *pc;
	int sel;
	for(pc = script->s; pc < script->w; ) {
		sel = selected(pc, data);
		if(sel) {
			int cmd = code(*instr(pc));
			if(sel==2 && cmd=='c')
				cmd = 'd';
			pc = (*excom[cmd])(script, pc, data);
			if(pc == 0)
				return;
		} else
			pc = nexti(pc);
	}
	if(!nflag)
		writeline(data);
}
#pragma prototyped

#include "sed.h"

void docopy(uchar *where, int n);
int dosub(uchar *where, uchar *rp);

Text retemp;	/* holds a rewritten regex, without delimiter */

int
recomp(Text *rebuf, Text *t, int delim)
{
	static int lastre;
	uchar *w;
	vacate(&retemp);
	for(w=t->w; ; retemp.w++,w++) {
		assure(&retemp, 2);
		*retemp.w = *w;
		if(*w == delim)
			break;
		else if(*w==0 || *w=='\n')
			syntax("unterminated address");
		else if(*w != '\\')
			continue;
		else if(*++w==delim)
			*retemp.w = delim;
		else if(*w == 'n')
			*retemp.w = '\n';
		else if(*w==0 || *w=='\n')
			syntax("unterminated regular expression");
		else {
			assure(&retemp, 2);
			*++retemp.w = *w;
		}
	}
	*retemp.w = 0;

	assure(rebuf, sizeof(regex_t));
	if(*retemp.s) {
		if(regcomp((regex_t*)rebuf->w,(char*)retemp.s,reflags))
			syntax("bad regular expression");
		lastre = rebuf->w - rebuf->s;
		rebuf->w += sizeof(regex_t);
	} else if(rebuf->w == rebuf->s)
		syntax("no previous regular expression");
	t->w = w + 1;
	return lastre;
}

Text gendata;

#define NMATCH 10
regmatch_t matches[NMATCH];
#define so matches[0].rm_so
#define eo matches[0].rm_eo

int
substitute(regex_t *re, Text* data, uchar *rhs, int n)
{
	Text t;
	uchar *where = data->s;
	if(regexec(re, (char*)data->s, NMATCH, matches, 0))
		return 0;
	vacate(&gendata);
	if(n == 0)
		do {
			docopy(where, so);
			if(!dosub(where, rhs))
				return 0;
			where += eo;
			if(eo == so)
				if(where < data->w)
					docopy(where++, 1);
				else
					goto done;
		} while(regexec(re, (char*)where, NMATCH, matches, REG_NOTBOL) == 0);
	else {
		while(--n > 0) {
			where += eo;
			if(eo == so)
				if(where < data->w)
					where++;
				else
					return 0;
			if(regexec(re, (char*)where, NMATCH, matches, REG_NOTBOL))
				return 0;
		}
		docopy(data->s, where-data->s+so);
		if(!dosub(where, rhs))
			return 0;
		where += eo;
	}			
	eo = so = data->w - where;
	docopy(where, so);
done:
	exch(gendata, *data, t);
	return 1;
}

void
docopy(uchar *where, int n)
{
	assure(&gendata, n+1);
	memmove(gendata.w, where, n);
	gendata.w += n;
	*gendata.w = 0;
}

	/* interpretation problem: if there is no match for \1, say,
           does the substitition occur?  dosub uses a null string.
	   a change where indicated will abort the substitution */
	
int
dosub(uchar *where, uchar *rp)
{
	int c, n;
	regmatch_t *m;

	while(c = *rp++) {
		if(c == '\\') {
			c = *rp++;
			if (c >= '1' && c <= '9') {
				m = matches + c - '0';
				if(m->rm_eo == -1)
					continue;   /* or return 0 */
				n = m->rm_eo - m->rm_so;
				assure(&gendata, n);
				memmove(gendata.w,where+m->rm_so,n);
				gendata.w += n;
				continue;
			}
		} else if(c == '&') {
				assure(&gendata, eo-so);
				memmove(gendata.w,where+so,eo-so);
				gendata.w += eo-so;
				continue;
		}
		assure(&gendata, 1);
		*gendata.w++ = c;
	}
	return 1;
}
#pragma prototyped

/*
 * regular-expression tester
 *
 * usage: testre <testre.dat
 * see comments in testre.dat for description of format
 */

static const char id[] = "\n@(#)testre (AT&T Research) 01/01/96\0\n";

#include <ast.h>
#include <ctype.h>
#include <regex.h>
#include <setjmp.h>
#include <sig.h>
#include <stk.h>

#define LOOPED		2

#define NOTEST		(~0)
#ifndef REG_LEFT
#define REG_LEFT	NOTEST
#endif
#ifndef REG_MINIMAL
#define REG_MINIMAL	NOTEST
#endif
#ifndef REG_NULL
#define REG_NULL	NOTEST
#endif
#ifndef REG_RIGHT
#define REG_RIGHT	NOTEST
#endif

#define REG_UNKNOWN	(-1)

#ifndef REG_ENEWLINE
#define REG_ENEWLINE	(REG_UNKNOWN-1)
#endif
#ifndef REG_ENULL
#define REG_ENULL	(REG_UNKNOWN-2)
#endif
#ifndef REG_ECOUNT
#define REG_ECOUNT	(REG_UNKNOWN-3)
#endif
#ifndef REG_BADESC
#define REG_BADESC	(REG_UNKNOWN-4)
#endif
#ifndef REG_EMEM
#define REG_EMEM	(REG_UNKNOWN-5)
#endif
#ifndef REG_ELOOP
#define REG_ELOOP	(REG_UNKNOWN-6)
#endif
#ifndef REG_EBUS
#define REG_EBUS	(REG_UNKNOWN-7)
#endif
#ifndef REG_EFAULT
#define REG_EFAULT	(REG_UNKNOWN-8)
#endif

static const struct { int code; char* name; } codes[] = {
	REG_UNKNOWN,	"UNKNOWN",
	REG_NOMATCH,	"NOMATCH",
	REG_BADPAT,	"BADPAT",
	REG_ECOLLATE,	"ECOLLATE",
	REG_ECTYPE,	"ECTYPE",
	REG_EESCAPE,	"EESCAPE",
	REG_ESUBREG,	"ESUBREG",
	REG_EBRACK,	"EBRACK",
	REG_EPAREN,	"EPAREN",
	REG_EBRACE,	"EBRACE",
	REG_BADBR,	"BADBR",
	REG_ERANGE,	"ERANGE",
	REG_ESPACE,	"ESPACE",
	REG_BADRPT,	"BADRPT",
	REG_ENEWLINE,	"ENEWLINE",
	REG_ENULL,	"ENULL",
	REG_ECOUNT,	"ECOUNT",
	REG_BADESC,	"BADESC",
	REG_EMEM,	"EMEM",
	REG_ELOOP,	"ELOOP",
	REG_EBUS,	"EBUS",
	REG_EFAULT,	"EFAULT",
};

static struct
{
	int	failures;
	int	goofs;
	int	lineno;
	int	ret;
	int	signals;
	char*	which;
	jmp_buf	gotcha;
} state;

static void
report(char* comment, char* re, char* s, int flags)
{
	state.failures++;
	sfprintf(sfstdout, "%d:", state.lineno);
	if(re) {
		sfprintf(sfstdout, "%s", re);
		if(s)
			sfprintf(sfstdout, " versus %s", s);
	}
	sfprintf(sfstdout, " %s%s %s", state.which, (flags & REG_NOSUB) ? " NOSUB" : "", comment);
}

static void
bad(char* comment, char* re, char* s)
{
	sfprintf(sfstdout,  "bad test case ");
	report(comment, re, s, 0);
	exit(1);
}

static void
doregerror(regex_t* preg, int code, int lineno)
{
	char*	msg;
	char	buf[200];

	switch (code)
	{
	case REG_EBUS:
		msg = "bus error";
		break;
	case REG_EFAULT:
		msg = "memory fault";
		break;
	case REG_ELOOP:
		msg = "did not terminate";
		break;
	default:
		regerror(code, preg, msg = buf, sizeof buf);
		break;
	}
	sfprintf(sfstdout, "%s\n", msg);
}

static int
readfield(char* f, char end)
{
	int	c;

	for(;;) {
		*f = 0;
		c = sfgetc(sfstdin);
		if(c == EOF)
			return 1;
		if(c == end)
			break;
		if(c == '\n')
			return 1;
		*f++ = c;
	} 
	if(c == '\t') {
		while(c == end)
			c = sfgetc(sfstdin);
		sfungetc(sfstdin, c);
	}
	return 0;
}

static int
hex(int c)
{
	return	isdigit(c) ? c-'0' :
		isupper(c) ? c-'A' :
		c-'a'+10;
}

static void
escape(char* s)
{
	char*	t;

	for(t=s; *t=*s; s++, t++) {
		if(*s != '\\')
			continue;
		switch(*++s) {
		case 0:
			*++t = 0;
			break;
		case 'n':
			*t = '\n';
			break;
		case 'x':
			if(!isxdigit(s[1]) || !isxdigit(s[2]))
				bad("bad \\x\n", NiL, NiL);
			*t = hex(*++s) << 4;
			*t |= hex(*++s);
			break;
		default:
			s--;
		}
	}
}

static int
readline(char* spec, char* re, char* s, char* ans)
{
	int	c;

	switch(c = sfgetc(sfstdin)) {
	case EOF:
		return 0;
	case '#':
		while(c != '\n')
			c = sfgetc(sfstdin);
	case '\n':
		*spec = 0;
		return 1;
	}
	sfungetc(sfstdin, c);
	if(readfield(spec, '\t')) return 0;
	if(readfield(re, '\t')) return 0;
	if(readfield(s, '\t')) return 0;
	if(readfield(ans, '\n')) return 0;
	escape(re);
	escape(s);
	return 1;
}

static void
matchprint(regmatch_t* match, int nmatch)
{
	int	i;

	for( ; nmatch>0; nmatch --)
		if(match[nmatch-1].rm_so != -1)
			break;
	for(i=0; i<nmatch; i++) {
		sfprintf(sfstdout, "(");
		if(match[i].rm_so == -1)
			sfprintf(sfstdout, "?");
		else
			sfprintf(sfstdout, "%d", match[i].rm_so);
		sfprintf(sfstdout, ",");
		if(match[i].rm_eo == -1)
			sfprintf(sfstdout, "?");
		else
			sfprintf(sfstdout, "%d", match[i].rm_eo);
		sfprintf(sfstdout, ")");
	}
	sfprintf(sfstdout, "\n");
}

static int
matchcheck(int nmatch, regmatch_t* match, char* ans, char* re, char* s, int flags)
{
	char*	p;
	int	i;
	int	m;
	int	n;

	for(i = 0, p = ans; i<nmatch && *p; i++) {
		if(*p++ != '(')
			bad("improper answer\n", re, s);
		if(*p == '?') {
			m = -1;
			p++;
		} else
			m = strtol(p, &p, 10);
		if(*p++ != ',')
			bad("improper answer\n", re, s);
		if(*p == '?') {
			n = -1;
			p++;
		} else
			n = strtol(p, &p, 10);
		if(*p++ != ')')
			bad("improper answer\n", re, s);
		if(m!=match[i].rm_so || n!=match[i].rm_eo) {
			report("match was: ", re, s, flags);
			matchprint(match, nmatch);
			return 0;
		}
	}
	for( ; i<nmatch; i++) {
		if(match[i].rm_so!=-1 || match[i].rm_eo!=-1) {
			report("match was: ", re, s, flags);
			matchprint(match, nmatch);
			return 0;
		}
	}
	return 1;
}

static void
gotcha(int sig)
{
	signal(sig, gotcha);
	alarm(0);
	state.signals++;
	switch (sig)
	{
	case SIGALRM:
		state.ret = REG_ELOOP;
		break;
	case SIGBUS:
		state.ret = REG_EBUS;
		break;
	case SIGSEGV:
		state.ret = REG_EFAULT;
		break;
	}
	sigunblock(sig);
	longjmp(state.gotcha, 1);
}

static void*
stkresize(void* handle, void* p, size_t n)
{
	void*	x;

	if (!n || !(x = stkalloc((Stk_t*)handle, n)))
		return 0;
	if (p)
		memcpy(x, p, n / 2);
	return x;
}

main(int argc, char** argv)
{
	regmatch_t	NOMATCH;
	int		flags;
	int		cflags;
	int		eflags;
	int		are;
	int		bre;
	int		ere;
	int		kre;
	int		lre;
	int		sre;
	char		spec[10];
	char		re[1000];
	char		s[100000];
	char		ans[500];
	char		msg[500];
	regmatch_t	match[100];
	regex_t		preg;
	char*		p;
	int		nmatch;
	int		cret;
	int		eret;
	int		i;
	int		expected;
	int		got;
	int		len;

	int		catch = 0;
	int		testno = 0;
	int		verbose = 0;
	off_t		stk = -1;

	sfprintf(sfstdout, "TEST	<regex>");
	while((p = *++argv) && *p == '-')
		for(;;)
		{
			switch(*++p)
			{
			case 0:
				break;
			case 'c':
				catch = 1;
				sfprintf(sfstdout, ", catch");
				continue;
			case 's':
#ifdef REG_AUGMENTED
				stk = stktell(stkstd);
				regalloc((void*)stkstd, stkresize, REG_NOFREE);
				sfprintf(sfstdout, ", stkstd");
#endif
				continue;
			case 'v':
				verbose = 1;
				sfprintf(sfstdout, ", verbose");
				continue;
			default:
				sfprintf(sfstdout, ", invalid option %c", *p);
				continue;
			}
			break;
		}
	if(p)
		sfprintf(sfstdout, ", argument(s) ignored");
	sfprintf(sfstdout, "\n");
	if(catch) {
		signal(SIGALRM, gotcha);
		signal(SIGBUS, gotcha);
		signal(SIGSEGV, gotcha);
	}
	NOMATCH.rm_so = -2;
	NOMATCH.rm_eo = -2;
	while(readline(spec, re, s, ans)) {
		state.lineno++;
		if(*spec == 0)
			continue;
		sfsync(sfstdout);

	/* interpret: */

		cflags = eflags = are = bre = ere = kre = lre = sre = 0;
		nmatch = 20;
		for(p=spec; *p; p++) {
			if(isdigit(*p)) {
				nmatch = strtol(p, &p, 10);
				p--;
				continue;
			}
			switch(*p) {

			case 'A':
				are = 1;
				continue;
			case 'B':
				bre = 1;
				continue;
			case 'E':
				ere = 1;
				continue;
			case 'K':
				kre = 1;
				continue;
			case 'L':
				lre = 1;
				continue;
			case 'S':
				sre = 1;
				continue;

			case 'I':
				cflags |= REG_ICASE;
				continue;
			case 'M':
				cflags |= REG_MINIMAL;
				continue;
			case 'U':
				cflags |= REG_NULL;
				continue;
			case 'W':
				cflags |= REG_NEWLINE;
				continue;

			case 'a':
				cflags |= REG_LEFT|REG_RIGHT;
				continue;
			case 'b':
				eflags |= REG_NOTBOL;
				continue;
			case 'e':
				eflags |= REG_NOTEOL;
				continue;
			case 'l':
				cflags |= REG_LEFT;
				continue;
			case 'r':
				cflags |= REG_RIGHT;
				continue;

			case '?':
				continue;

			default:
				bad("bad spec\n", re, s);

			}
		}
		if(streq(re, "NULL"))
			re[0] = 0;
		if(streq(s, "NULL"))
			s[0] = 0;
		if((cflags|eflags) == NOTEST)
			continue;

	compile:

		if(bre) {
			state.which = "BRE";
			bre = 0;
			flags = cflags;
		}
		else if(ere) {
			state.which = "ERE";
			ere = 0;
			flags = cflags | REG_EXTENDED;
		}
#ifdef REG_AUGMENTED
		else if(are) {
			state.which = "ARE";
			are = 0;
			flags = cflags | REG_AUGMENTED;
		}
#endif
#ifdef REG_LITERAL
		else if(lre) {
			state.which = "LRE";
			lre = 0;
			flags = cflags | REG_LITERAL;
		}
#endif
#ifdef REG_SHELL
		else if(sre) {
			state.which = "SRE";
			sre = 0;
			flags = cflags | REG_SHELL;
		}
#ifdef REG_AUGMENTED
		else if(kre) {
			state.which = "KRE";
			kre = 0;
			flags = cflags | REG_SHELL | REG_AUGMENTED;
		}
#endif
#endif
		else
			continue;
		if(verbose)
			sfprintf(sfstdout, "test %-3d %s \"%s\" \"%s\"\n", state.lineno, state.which, re, s);

	nosub:

		testno++;
		if(catch) {
			if(setjmp(state.gotcha))
				cret = state.ret;
			else {
				alarm(LOOPED);
				cret = regcomp(&preg, re, flags);
				alarm(0);
			}
		} else
			cret = regcomp(&preg, re, flags);
		if(cret == 0) {
			if(!streq(ans, "NULL") &&
			   !streq(ans, "NOMATCH") &&
			   ans[0]!='(') {
				report("regcomp should fail and didn't\n", re, NiL, flags);
				continue;
			}
		} else {
			if(streq(ans, "NULL") ||
			   ans[0]=='(' ||
			   cret==REG_BADPAT && streq(ans, "NOMATCH")) {
				report("regcomp failed: ", re, NiL, flags);
				doregerror(&preg, cret, state.lineno);
			} else {
				expected = got = 0;
				for(i=1; i<elementsof(codes); i++) {
					if(streq(ans, codes[i].name))
						expected = i;
					if(cret==codes[i].code)
						got = i;
				}
				if(!expected)
				{
					report("invalid error code: ", re, NiL, flags);
					sfprintf(sfstdout, "%s expected, %s returned\n", ans, codes[got].name);
				}
				else if(cret!=codes[expected].code && cret!=REG_BADPAT) {
					report("regcomp should fail and did: ", re, NiL, flags);
					sfprintf(sfstdout, "%s expected, %s returned: ", ans, codes[got].name);
					state.failures--;
					state.goofs++;
					doregerror(&preg, cret, state.lineno);
				}
			}
			goto compile;
		}

	/* execute: */
		
		for(i=0; i<elementsof(match); i++)
			match[i] = NOMATCH;

		if(catch) {
			if(setjmp(state.gotcha))
				eret = state.ret;
			else {
				alarm(LOOPED);
				eret = regexec(&preg, s, nmatch, match, eflags);
				alarm(0);
			}
		} else
			eret = regexec(&preg, s, nmatch, match, eflags);

		if(flags & REG_NOSUB) {
			if(eret) {
				report("regexec REG_NOSUB failed: ", re, s, flags);
				doregerror(&preg, eret, state.lineno);
			}
		} else if(eret) {
			if(!streq(ans, "NOMATCH")) {
				report("regexec failed", re, s, flags);
				if(eret != REG_NOMATCH) {
					sfprintf(sfstdout, ": ");
					doregerror(&preg, eret, state.lineno);
				} else
					sfprintf(sfstdout, "\n");
			}
		} else if(streq(ans, "NOMATCH")) {
			report("regexec should fail and didn't: ", re, s, flags);
			matchprint(match, nmatch);
		} else if(streq(ans, "NULL")) {
			if(match[0].rm_so != NOMATCH.rm_so) {
				report("no match but match array assigned: ", re, s, flags);
				matchprint(match, nmatch);
			}
		} else if (matchcheck(nmatch, match, ans, re, s, flags)) {
			if(stk >= 0)
				stkseek(stkstd, stk);
			else
				regfree(&preg);
			flags |= REG_NOSUB;
			goto nosub;
		}
		if(stk >= 0)
			stkseek(stkstd, stk);
		else
			regfree(&preg);
		goto compile;
	}
	sfprintf(sfstdout, "TEST	<regex>, %d tests", testno);
	if(state.goofs)
		sfprintf(sfstdout, ", %d goofs", state.goofs);
	if(state.signals)
		sfprintf(sfstdout, ", %d signals", state.signals);
	sfprintf(sfstdout, ", %d errors\n", state.failures);
	return 0;
}
#pragma prototyped
/*
 * Editor (snarfed from v10, now posix compliant, no hard limits)
 */

static const char id[] = "\n@(#)ed (AT&T Research) 01/01/96\0\n";

#include <ast.h>
#include <error.h>
#include <ls.h>
#include <sfstr.h>
#include <sig.h>

#include <ctype.h>
#include <regex.h>
#include <setjmp.h>

#define BLOCK_LINE	1024
#define BLOCK_TMP	(8*SF_BUFSIZE)

#define BREAK_PAGE	23
#define BREAK_LINE	72

#define LINE_GLOBAL	((off_t)0x80000000)
#define LINE_MARKED	((off_t)0x40000000)
#define LINE_NONE	((off_t)-1)

#define MARK_MIN	'a'
#define MARK_MAX	'z'

#define MATCH_MIN	'0'
#define MATCH_MAX	'9'

#define PRINT		01
#define PRINT_LIST	02
#define PRINT_NUMBER	04

#define REC_IGNORE	001
#define REC_LINE	002
#define REC_SPLICE	004
#define REC_TERMINATE	010
#define REC_TEXT	020

#define BEG(n)		(ed.line+ed.match[n].rm_so)
#define CUR()		(ed.line)
#define END(n)		(ed.line+ed.match[n].rm_eo)
#define HIT(n)		(ed.match[n].rm_eo!=-1)
#define NXT()		(ed.line++)
#define SET(p)		(ed.line=(p))

#define error		fatal
#define trap()		do{if(ed.caught)handle();}while(0);

#define swap(t,a,b)	(ed.swp=(void*)(a),(a)=(b),(b)=(t)ed.swp)

typedef struct
{
	off_t		offset;
	off_t		undo;
	unsigned long	event;
} Line_t;

static int		signals[] = { SIGQUIT, SIGHUP, SIGINT, SIGTERM };

static struct		/* program state -- no other dynamic globals */
{
	struct
	{
	Sfio_t*		file;
	Sfio_t*		global;
	Sfio_t*		help;
	Sfio_t*		line;
	Sfio_t*		prompt;
	Sfio_t*		query;
	Sfio_t*		shell;
	Sfio_t*		substitute;
	Sfio_t*		work;
	}		buffer;
	struct
	{
	int		print;
	int		size;
	}		page;
	struct
	{
	off_t		marks[MARK_MAX - MARK_MIN + 1];
	unsigned long	dol;
	unsigned long	dot;
	}		undo;
	Line_t*		addr1;
	Line_t*		addr2;
	Line_t*		dol;
	Line_t*		dot;
	Line_t*		zero;
	Sfio_t*		iop;
	Sfio_t*		msg;
	Sfio_t*		tmp;
	char*		global;
	char*		line;
	char*		linebreak;
	char*		tmpfile;
	int		caught;
	int		compiled;
	int		evented;
	int		given;
	int		help;
	int		initialized;
	int		interactive;
	int		lastc;
	int		marked;
	int		modified;
	int		peekc;
	int		pending;
	int		print;
	int		prompt;
	int		verbose;
	int		warn_newline;
	int		warn_null;
	jmp_buf		again;
	off_t		marks[MARK_MAX - MARK_MIN + 1];
	off_t		tmpoff;
	regex_t		re;
	regmatch_t	match[MATCH_MAX - MATCH_MIN + 1];
	unsigned long	all;
	unsigned long	bytes;
	unsigned long	event;
	unsigned long	lines;
	void*		swp;
}			ed;

static void		commands(void);
static void		handle(void);
static void		quit(int);

static void
interrupt(int sig)
{
	signal(sig, interrupt);
	if (ed.initialized) {
		if (!ed.caught)
			ed.caught = sig;
	}
	else if (!ed.pending)
		ed.pending = sig;
}

static int
getchr(void)
{
	if (ed.lastc = ed.peekc) {
		ed.peekc = 0;
		return(ed.lastc);
	}
	if (ed.global) {
		if (ed.lastc = *ed.global++)
			return(ed.lastc);
		ed.global = 0;
		return(EOF);
	}
	if ((ed.lastc = sfgetc(sfstdin)) == EOF)
		trap();
	return(ed.lastc);
}

static ssize_t
helpwrite(int fd, const void* buf, size_t len)
{
	ssize_t	n;

	NoP(fd);
	n = ed.help ? sfwrite(ed.msg, buf, len) : ed.verbose ? sfputr(ed.msg, "?", '\n') : 0;
	sfstrset(ed.buffer.help, 0);
	sfwrite(ed.buffer.help, buf, len - 1);
	sfputc(ed.buffer.help, 0);
	return(n);
}

static void
error(int level, ...)
{
	va_list		ap;
	register int	c;

	trap();
	va_start(ap, level);
	errorv(NiL, level, ap);
	va_end(ap);
	if (level >= 2) {
		if (ed.iop) {
			sfclose(ed.iop);
			ed.iop = 0;
			error_info.file = 0;
		}
		if (ed.interactive <= 0 && (ed.interactive = isatty(0)) <= 0)
			quit(1);
		ed.print = 0;
		ed.bytes = 0;
		ed.lines = 0;
		if (ed.global)
			ed.lastc = '\n';
		ed.global = 0;
		ed.peekc = ed.lastc;
		if (ed.lastc)
			while ((c = getchr()) != '\n' && c != EOF)
				;
		longjmp(ed.again, 1);
	}
}

static void
init(void)
{
	register Sfio_t**	ss;
	register int		c;

	ed.interactive = -1;
	ed.msg = sfstdout;
	ed.all = BLOCK_LINE;
	ed.page.size = BREAK_PAGE;
	ed.verbose = 1;
	for (c = 0; c < elementsof(signals); c++)
		if (signal(signals[c], interrupt) == SIG_IGN)
			signal(signals[c], SIG_IGN);
	for (ss = (Sfio_t**)&ed.buffer; ss < (Sfio_t**)(((char*)&ed.buffer) + sizeof(ed.buffer)); ss++) {
		if (!(*ss = sfstropen()))
			error(ERROR_SYSTEM|3, "cannot initialize internal buffer");
		sfputc(*ss, 0);
		sfstrset(*ss, 0);
	}
	sfputr(ed.buffer.help, "?", 0);
	if (!(ed.zero = newof(NiL, Line_t, ed.all, 0)))
		error(ERROR_SYSTEM|3, "out of space [zero]");
}

static char*
getrec(register Sfio_t* sp, register int delimiter, register int flags)
{
	register int	c;
	register char*	glob;

	sfstrset(sp, 0);
	glob = ed.global;
	while ((c = getchr()) != delimiter) {
		if (c == '\n') {
			ed.peekc = c;
			break;
		}
		if (c == EOF) {
			if (glob)
				ed.peekc = (flags & REC_LINE) ? 0 : c;
			else if (delimiter != '\n' || (flags & (REC_LINE|REC_SPLICE)))
				error(2, "unexpected EOF");
			else if (flags & REC_TEXT)
				return(0);
			break;
		}
		if (c == '\\' && ((c = getchr()) != delimiter || (flags & REC_SPLICE) && c != '\n') && c && !(flags & REC_IGNORE))
			sfputc(sp, '\\');
		if (!c)
			error(1, "null character ignored");
		else if (!(flags & REC_IGNORE))
			sfputc(sp, c);
	}
	if (flags & REC_TERMINATE)
		sfputc(sp, c);
	return(sfstruse(sp));
}

static void
putrec(register char* s)
{
	register int	n;
	register char*	t;

	if ((ed.print & PRINT_LIST) && (t = fmtesc(s))) {
		s = t;
		n = strlen(s);
		while (n > BREAK_LINE) {
			n -= BREAK_LINE;
			sfprintf(ed.msg, "%-*.*s\\\n", BREAK_LINE, BREAK_LINE, s);
			s += BREAK_LINE;
		}
		sfprintf(ed.msg, "%s$\n", s);
	}
	else
		sfputr(ed.msg, s, '\n');
}

static void
modify(void)
{
	if (!ed.evented) {
		ed.evented = ed.modified = 1;
		ed.event++;
		ed.undo.dot = ed.dot - ed.zero;
		ed.undo.dol = ed.dol - ed.zero;
		if (ed.marked) {
			register int	c;

			for (c = 0; c < elementsof(ed.marks); c++)
				ed.undo.marks[c] = ed.marks[c];
		}
	}
}

static void
undo(void)
{
	register Line_t*	a1;
	register Line_t*	a3;
	register unsigned long	event;
	int			c;
	off_t			t;
	unsigned long		n;

	c = 0;
	event = ed.event;
	a1 = ed.zero;
	a3 = ed.zero + ed.all;
	while (++a1 < a3)
		if (a1->event == event) {
			c = 1;
			t = a1->offset;
			a1->offset = a1->undo;
			a1->undo = t;
		}
	if (!c)
		error(2, "nothing to undo");
	if (ed.marked)
		for (c = 0; c < elementsof(ed.marks); c++) {
			t = ed.marks[c];
			ed.marks[c] = ed.undo.marks[c];
			ed.undo.marks[c] = t;
		}
	n = ed.dot - ed.zero;
	ed.dot = ed.zero + ed.undo.dot;
	ed.undo.dot = n;
	n = ed.dol - ed.zero;
	ed.dol = ed.zero + ed.undo.dol;
	ed.undo.dol = n;
}

static char*
lineget(off_t off)
{
	char*	s;

	off &= ~(LINE_GLOBAL|LINE_MARKED);
	if (sfseek(ed.tmp, off, SEEK_SET) != off)
		error(ERROR_SYSTEM|2, "temp file read seek error");
	if (!(s = sfgetr(ed.tmp, 0, 0)))
		error(ERROR_SYSTEM|2, "temp file read error");
	return(s);
}

static off_t
lineput(char* s)
{
	off_t	off;

	modify();
	off = ed.tmpoff;
	if (sfseek(ed.tmp, off, SEEK_SET) != off)
		error(ERROR_SYSTEM|2, "temp file write seek error");
	if (sfputr(ed.tmp, s, 0) < 0)
		error(ERROR_SYSTEM|2, "temp file write error");
	if ((ed.tmpoff = sfseek(ed.tmp, 0L, SEEK_CUR)) == (off_t)-1)
		error(ERROR_SYSTEM|2, "temp file tell error");
	return(off);
}

static void
replace(register Line_t* a1, char* s)
{
	register off_t	off;

	off = lineput(s);
	if (a1->offset & LINE_MARKED) {
		register off_t*	mp;

		a1->offset &= ~LINE_GLOBAL;
		off |= LINE_MARKED;
		for (mp = ed.marks; mp < &ed.marks[elementsof(ed.marks)]; mp++)
			if (*mp == a1->offset)
				*mp = off;
	}
	a1->event = ed.event;
	a1->undo = a1->offset;
	a1->offset = off;
}

static void
squeeze(int i)
{
	if (ed.addr1 < ed.zero + i)
		error(2, "at top of file");
	if (ed.addr2 > ed.dol)
		error(2, "at end of file");
	if (ed.addr1 > ed.addr2)
		error(2, "first address exceeds second");
}

static void
nonzero(void)
{
	squeeze(1);
}

static char*
getfile(void)
{
	register char*	s;
	register int	n;
	register int	m;

	if (!(s = sfgetr(ed.iop, '\n', 1))) {
		if (!(s = sfgetr(ed.iop, '\n', -1)))
			return(0);
		ed.warn_newline = 1;
	}
	n = sfslen();
	if ((m = strlen(s)) < n) {
		register char*	t;
		register char*	u;
		register char*	x;

		t = u = s + m;
		x = s + n;
		while (u < x)
			if (!(*t++ = *u++))
				t--;
		*t++ = 0;
		n = t - s;
		ed.warn_null += x - t;
	}
	ed.bytes += n;
	ed.lines++;
	return(s);
}

static char*
getline(void)
{
	register char*	s;

	if ((s = getrec(ed.buffer.line, '\n', REC_TEXT)) && s[0] == '.' && !s[1])
		s = 0;
	return(s);
}

static char*
getbreak(void)
{
	char*	s;

	if ((s = ed.linebreak) && (ed.linebreak = strchr(s, '\n')))
		*ed.linebreak++ = 0;
	return(s);
}

static char*
getcopy(void)
{
	if (ed.addr1 > ed.addr2)
		return(0);
	return(lineget((ed.addr1++)->offset));
}

static void
print(void)
{
	register Line_t* a1;

	nonzero();
	a1 = ed.addr1;
	do {
		if (ed.print & PRINT_NUMBER)
			sfprintf(ed.msg, "%d\t", a1 - ed.zero);
		putrec(lineget((a1++)->offset));
	} while (a1 <= ed.addr2);
	ed.dot = ed.addr2;
	ed.print = 0;
}

static int
getnum(void)
{
	register int c;
	register int r;

	r = 0;
	while ((c = getchr()) >= '0' && c <= '9')
		r = r * 10 + c - '0';
	ed.peekc = c;
	return(r);
}

static void
regfatal(int code)
{
	char	buf[128];

	if (code) {
		regerror(code, 0, buf, sizeof(buf));
		error(2, "%s", buf);
	}
}

static void
compile(int delimiter)
{
	register char*	s;
	int		c;

	s = getrec(ed.buffer.line, delimiter, 0);
	if (*s) {
		if (ed.compiled) {
			ed.compiled = 0;
			regfree(&ed.re);
		}
		if (c = regcomp(&ed.re, s, 0))
			regfatal(c);
		ed.compiled = 1;
	}
	else if (!ed.compiled)
		error(2, "no previous regular expression");
}

static int
execute(Line_t* addr)
{
	register char*	s;
	register int	c;

	trap();
	if (!addr)
		s = CUR();
	else if (addr == ed.zero)
		return(0);
	else
		s = lineget(addr->offset);
	if (c = regexec(&ed.re, s, elementsof(ed.match), ed.match, 0)) {
		if (c != REG_NOMATCH)
			regfatal(c);
		return(0);
	}
	SET(s);
	return(1);
}

static Line_t*
address(void)
{
	register int		c;
	register int		sign;
	register Line_t*	a;
	register Line_t*	b;
	int			opcnt;
	int			nextopand;

	nextopand = -1;
	sign = 1;
	opcnt = 0;
	a = ed.dot;
	do {
		do c = getchr(); while (isspace(c) && c != '\n');
		if (c >= '0' && c <= '9') {
			ed.peekc = c;
			if (!opcnt)
				a = ed.zero;
			a += sign * getnum();
		}
		else switch (c) {

		case '$':
			a = ed.dol;
			/*FALLTHROUGH*/
		case '.':
			if (opcnt)
				error(2, "invalid address");
			break;

		case '\'':
			if ((c = getchr()) == EOF || (c -= MARK_MIN) < 0 || c >= elementsof(ed.marks) || opcnt)
				error(2, "invalid mark");
			a = ed.marked && ed.marks[c] != LINE_NONE ? ed.zero : ed.dol;
			do {
				if (++a > ed.dol)
					error(2, "undefined mark referenced");
			} while (ed.marks[c] != (a->offset & ~LINE_GLOBAL));
			break;

		case '?':
			sign = -sign;
			/*FALLTHROUGH*/
		case '/':
			compile(c);
			b = a;
			for (;;) {
				a += sign;
				if (a <= ed.zero)
					a = ed.dol;
				if (a > ed.dol)
					a = ed.zero;
				if (execute(a))
					break;
				if (a == b)
					error(2, "pattern not found");
			}
			break;

		default:
			if (nextopand == opcnt) {
				a += sign;
				if (a < ed.zero || ed.dol < a)
					continue;       /* error? */
			}
			if (c != '+' && c != '-' && c != '^') {
				ed.peekc = c;
				if (!opcnt)
					a = 0;
				return(a);
			}
			sign = 1;
			if (c != '+')
				sign = -sign;
			nextopand = ++opcnt;
			continue;

		}
		sign = 1;
		opcnt++;
	} while (a >= ed.zero && a <= ed.dol);
	error(2, "address out of range");
	return(0);
}

static void
setwide(void)
{
	if (!ed.given) {
		ed.addr1 = ed.zero + (ed.dol > ed.zero);
		ed.addr2 = ed.dol;
	}
}

static void
setnoaddr(void)
{
	if (ed.given)
		error(2, "invalid address count");
}

static void
newline(void)
{
	register int	warned = 0;

	for (;;)
		switch (getchr()) {

		case EOF:
		case '\n':
			return;

		case 'l':
			ed.print = PRINT_LIST;
			continue;

		case 'n':
			ed.print = PRINT_NUMBER;
			continue;

		case 'p':
			ed.print = PRINT;
			continue;

		default:
			if (!warned) {
				warned = 1;
				error(2, "extra characters at end of command");
			}
			continue;
		}
}

static char*
plural(unsigned long count)
{
	return(count == 1 ? "" : "s");
}

static void
exfile(void)
{
	if (sfclose(ed.iop))
		error(ERROR_SYSTEM|1, "io error");
	ed.iop = 0;
	if (ed.verbose) {
		if (ed.help) {
			sfprintf(ed.msg, "\"%s\" %lu line%s, %lu character%s", error_info.file, ed.lines, plural(ed.lines), ed.bytes, plural(ed.bytes));
			if (ed.warn_null) {
				sfprintf(ed.msg, ", %lu null%s", ed.warn_null, plural(ed.warn_null));
				ed.warn_null = 0;
			}
			if (ed.warn_newline) {
				sfprintf(ed.msg, ", newline appended");
				ed.warn_newline = 0;
			}
			sfputc(ed.msg, '\n');
		}
		else
			sfprintf(ed.msg, "%d\n", ed.bytes);
	}
	if (ed.warn_null || ed.warn_newline) {
		char*	sep = "";

		sfstrset(ed.buffer.line, 0);
		if (ed.warn_null) {
			sfprintf(ed.buffer.line, "%d null character%s ignored", ed.warn_null, plural(ed.warn_null));
			ed.warn_null = 0;
			sep = ", ";
		}
		if (ed.warn_newline) {
			sfprintf(ed.buffer.line, "%snewline appended to last line", sep);
			ed.warn_newline = 0;
		}
		error(1, "%s", sfstruse(ed.buffer.line));
	}
	error_info.file = 0;
}

static void
putfile(void)
{
	register Line_t*	a1;
	register int		n;

	ed.bytes = 0;
	ed.lines = 0;
	a1 = ed.addr1;
	do {
		if ((n = sfputr(ed.iop, lineget((a1++)->offset), '\n')) < 0)
			error(ERROR_SYSTEM|2, "write error");
		ed.bytes += n;
		ed.lines++;
	} while (a1 <= ed.addr2);
	if (sfsync(ed.iop))
		error(ERROR_SYSTEM|2, "write error");
}

static void
quit(int code)
{
	if (ed.tmpfile) {
		remove(ed.tmpfile);
		ed.tmpfile = 0;
	}
	if (ed.verbose && ed.modified && ed.dol != ed.zero) {
		ed.modified = 0;
		error(2, "file changed but not written");
	}
	if (ed.caught == SIGQUIT) {
		signal(ed.caught, SIG_DFL);
		kill(0, ed.caught);
	}
	exit(code);
}

static void
handle(void)
{
	register int	c;
	char*		s;
	char*		b;
	mode_t		mask;

	if (ed.caught == SIGINT) {
		ed.caught = 0;
		ed.lastc = '\n';
		sfputc(ed.msg, '\n');
		error(2, "interrupt");
	}
	for (c = 0; c < elementsof(signals); c++)
		signal(signals[c], SIG_IGN);
	if (ed.dol > ed.zero) {
		ed.addr1 = ed.zero + 1;
		ed.addr2 = ed.dol;
		mask = umask(S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
		b = "ed.hup";
		if (!(ed.iop = sfopen(NiL, b, "w")) && (s = getenv("HOME"))) {
			sfstrset(ed.buffer.line, 0);
			sfprintf(ed.buffer.line, "%s/%s", s, b);
			b = sfstruse(ed.buffer.line);;
			ed.iop = sfopen(NiL, b, "w");
		}
		umask(mask);
		if (!ed.iop)
			error(ERROR_SYSTEM|1, "%s: cannot save changes", b);
		else {
			error_info.file = b;
			putfile();
		}
	}
	ed.modified = 0;
	quit(0);
}

static int
append(char* (*f)(void), Line_t* a)
{
	register char*		s;
	register Line_t*	a1;
	register Line_t*	a2;
	register Line_t*	a3;
	off_t			t;
	long			m;
	long			slide;

	slide = 0;
	ed.dot = a;
	while (s = (*f)()) {
		if ((ed.dol - ed.zero) + 1 >= ed.all) {
#if __sgi__ && !__GNUC__ /* sgi pointer arithmetic bug -- it's fun */
			long	dot = ed.dot - ed.zero;
			long	dol = ed.dol - ed.zero;
#endif
			a3 = ed.zero;
			ed.all += BLOCK_LINE;
			if (!(ed.zero = newof(ed.zero, Line_t, ed.all, 0))) {
				error(ERROR_SYSTEM|1, "no space [zero]");
				ed.caught = SIGHUP;
				trap();
			}
			m = ed.zero - a3;
			slide += m;
#if __sgi__ && !__GNUC__ /* sgi pointer arithmetic bug -- it's fun */
			ed.dot = ed.zero + dot;
			ed.dol = ed.zero + dol;
#else
			ed.dot += m;
			ed.dol += m;
#endif
		}
		t = lineput(s);
		slide++;
		a1 = ++ed.dol;
		a2 = a1 + 1;
		a3 = ++ed.dot;
		while (a1 > a3) {
			(--a2)->event = ed.event;
			a2->undo = a2->offset;
			a2->offset = (--a1)->offset;
		}
		a3->event = ed.event;
		a3->undo = a3->offset;
		a3->offset = t;
	}
	return(slide);
}

static void
add(int i)
{
	if (i && (ed.given || ed.dol > ed.zero)) {
		ed.addr1--;
		ed.addr2--;
	}
	squeeze(0);
	newline();
	append(getline, ed.addr2);
}

static void
page(void)
{
	register int	direction;
	register int	n;

	switch (direction = getchr()) {

	case '-':
	case '.':
	case '+':
		break;

	default:
		ed.peekc = direction;
		direction = '+';
		break;

	}
	if ((n = getnum()) > 0)
		ed.page.size = n;
	newline();
	if (ed.print)
		ed.page.print = ed.print;
	else
		ed.print = ed.page.print;
	switch (direction) {

	case '-':
		ed.addr1 = ed.addr2 - ed.page.size + 1;
		break;

	case '.':
		ed.addr2 += ed.page.size / 2;
		ed.addr1 = ed.addr2 - ed.page.size + 1;
		break;

	case '+':
		ed.addr1 = ed.addr2;
		ed.addr2 += ed.page.size - 1;
		break;

	}
	if (ed.addr1 <= ed.zero)
		ed.addr1 = ed.zero + 1;
	if (ed.addr2 > ed.dol)
		ed.addr2 = ed.dol;
	print();
}

static void
rdelete(register Line_t* a1, register Line_t* a2)
{
	register Line_t*	a3;

	modify();
	a3 = ed.dol;
	ed.dol -= ++a2 - a1;
	ed.dot = a1 > ed.dol ? ed.dol : a1;
	do {
		a1->undo = a1->offset;
		a1->event = ed.event;
		(a1++)->offset = (a2++)->offset;
	} while (a2 <= a3);
	while (a1 <= a3) {
		a1->undo = a1->offset;
		(a1++)->event = ed.event;
	}
}

static void
gdelete(void)
{
	register Line_t*	a1;
	register Line_t*	a2;
	register Line_t*	a3;

	a3 = ed.dol;
	for (a1 = ed.zero; !(a1->offset & LINE_GLOBAL); a1++)
		if (a1 >= a3)
			return;
	modify();
	for (a2 = a1 + 1; a2 <= a3;) {
		a1->event = ed.event;
		a1->undo = a1->offset;
		if (a2->offset & LINE_GLOBAL) {
			a2++;
			ed.dot = a1;
		}
		else
			(a1++)->offset = (a2++)->offset;
	}
	ed.dol = a1 - 1;
	if (ed.dot > ed.dol)
		ed.dot = ed.dol;
	while (a1 <= a3) {
		a1->undo = a1->offset;
		(a1++)->event = ed.event;
	}
}

static void
shell(void)
{
	register char*	s;
	register char*	f = 0;
	register int	c;

	if (ed.given)
		squeeze(ed.dol > ed.zero);
	s = getrec(ed.buffer.line, '\n', 0);
	if (s[0] == '!' && !s[1]) {
		if (!*sfstrbase(ed.buffer.shell))
			error(2, "no saved shell command");
		f = sfstrbase(ed.buffer.file);
	}
	else if (!s[0])
		error(2, "empty shell command");
	else
		swap(Sfio_t*, ed.buffer.shell, ed.buffer.line);
	s = sfstrbase(ed.buffer.shell);
	sfstrset(ed.buffer.line, 0);
	sfputc(ed.buffer.line, '!');
	while (c = *s++) {
		if (c == '\\') {
			if (*s != '%')
				sfputc(ed.buffer.line, c);
			sfputc(ed.buffer.line, *s++);
		}
		else if (c == '%')
			sfputr(ed.buffer.line, f = sfstrbase(ed.buffer.file), -1);
		else
			sfputc(ed.buffer.line, c);
	}
	if (ed.given) {
		if (!ed.tmpfile && !(ed.tmpfile = pathtemp(NiL, NiL, error_info.id)))
			error(ERROR_SYSTEM|2, "cannot generate temp file name");
		if (!(ed.iop = sfopen(NiL, ed.tmpfile, "w")))
			error(ERROR_SYSTEM|2, "%s: cannot create temp file", ed.tmpfile);
		error_info.file = ed.tmpfile;
		if (ed.dol > ed.zero)
			putfile();
		exfile();
		ed.bytes = 0;
		ed.lines = 0;
		sfprintf(ed.buffer.line, " < %s", ed.tmpfile);
		s = sfstruse(ed.buffer.line);
		if (!(ed.iop = sfpopen(NiL, s + 1, "r")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", s);
		error_info.file = s;
		rdelete(ed.addr1, ed.addr2);
		append(getfile, ed.dot);
		exfile();
		remove(ed.tmpfile);
	}
	else {
		s = sfstruse(ed.buffer.line) + 1;
		if (f)
			putrec(s);
		if (!(ed.iop = sfpopen(NiL, s, "")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", s);
		if (sfclose(ed.iop)) {
			ed.iop = 0;
			error(ERROR_SYSTEM|2, "%s: shell command exit error", s);
		}
		if (ed.verbose)
			putrec("!");
	}
}

static void
edit(void)
{
	register off_t*	mp;

	if (ed.tmp) {
		sfclose(ed.tmp);
		ed.tmp = 0;
	}
	ed.tmpoff = 0;
	if (!(ed.tmp = sftmp(BLOCK_TMP)))
		error(ERROR_SYSTEM|3, "cannot create temp file");
	for (mp = ed.marks; mp < &ed.marks[elementsof(ed.marks)]; )
		*mp++ = LINE_NONE;
	ed.marked = 0;
	ed.event++;
	ed.dot = ed.dol = ed.zero;
	if (!ed.initialized) {
		ed.initialized = 1;
		if (ed.pending)
			ed.caught = ed.pending;
	}
}

static void
filename(int c)
{
	register char*	p;
	register int	sh = 0;

	ed.bytes = 0;
	ed.lines = 0;
	p = getrec(ed.buffer.line, '\n', REC_LINE);
	if (*p) {
		if (!isspace(*p))
			error(2, "no space after command");
		for (p++; isspace(*p); p++)
			;
		if (!*p)
			error(2, "file name expected");
		if (c != 'f') {
			if (*p == '!') {
				p++;
				sh = 1;
			}
			else if (*p == '\\' && *(p + 1) == '!')
				p++;
		}
		if (!sh && (!*sfstrbase(ed.buffer.file) || c == 'e' || c == 'f')) {
			sfstrset(ed.buffer.file, 0);
			sfputr(ed.buffer.file, p, 0);
		}
		if (c == 'f')
			return;
	}
	else if (c == 'f')
		return;
	else if (!*(p = sfstrbase(ed.buffer.file)))
		error(2, "file name expected");
	if (c == 'e') {
		edit();
		ed.addr2 = ed.zero;
	}
	if (sh) {
		if (!(ed.iop = sfpopen(NiL, p, (c == 'e' || c == 'r') ? "r" : "w")))
			error(ERROR_SYSTEM|2, "%s: cannot execute shell command", p);
		p--;
	}
	else if (c == 'e' || c == 'r') {
		if (!(ed.iop = sfopen(NiL, p, "r")))
			error(ERROR_SYSTEM|2, "%s: cannot read", p);
	}
	else if ((c != 'W' || !(ed.iop = sfopen(NiL, p, "a"))) && !(ed.iop = sfopen(NiL, p, "w")))
		error(ERROR_SYSTEM|2, "%s: cannot write", p);
	error_info.file = p;
}

static void
global(int sense, int query)
{
	register char*		s;
	register int		c;
	register Line_t*	a1;

	if (ed.global)
		error(2, "recursive global not allowed");
	setwide();
	squeeze(ed.dol > ed.zero);
	if ((c = getchr()) == '\n')
		error(2, "incomplete global expression");
	compile(c);
	if (query)
		newline();
	else {
		s = getrec(ed.buffer.global, '\n', REC_SPLICE|REC_TERMINATE);
		if (s[0] == '\n' && !s[1])
			sfputr(ed.buffer.global, "p\n", 0);
	}
	for (a1 = ed.zero; a1 <= ed.dol; a1++) {
		a1->offset &= ~LINE_GLOBAL;
		if (a1 >= ed.addr1 && a1 <= ed.addr2 && execute(a1) == sense)
			a1->offset |= LINE_GLOBAL;
	}

	/* special case: g/.../d (avoid n^2 algorithm) */

	if (!query && s[0] == 'd' && s[1] == '\n' && !s[2])
		gdelete();
	else {
		for (a1 = ed.zero; a1 <= ed.dol; a1++) {
			if (a1->offset & LINE_GLOBAL) {
				a1->offset &= ~LINE_GLOBAL;
				ed.dot = a1;
				if (query) {
					putrec(lineget(a1->offset));
					if ((c = getchr()) == EOF)
						break;
					else if (c == '\n')
						continue;
					else if (c == '&') {
						newline();
						if (!*(ed.global = sfstrbase(ed.buffer.query)))
							error(2, "no saved command");
					}
					else {
						ed.peekc = c;
						ed.global = getrec(ed.buffer.query, '\n', REC_TERMINATE);
					}
				}
				else
					ed.global = s;
				commands();
				a1 = ed.zero;
			}
		}
	}
}

static void
join(void)
{
	register Line_t*	a1;

	nonzero();
	sfstrset(ed.buffer.work, 0);
	for (a1 = ed.addr1; a1 <= ed.addr2;)
		sfputr(ed.buffer.work, lineget((a1++)->offset), -1);
	a1 = ed.dot = ed.addr1;
	replace(a1, sfstruse(ed.buffer.work));
	if (a1 < ed.addr2)
		rdelete(a1 + 1, ed.addr2);
}

static int
compsub(void)
{
	register int	seof;
	register int	c;

	seof = getchr();
	if (isspace(seof))
		error(2, "invalid or missing delimiter");
	compile(seof);
	sfstruse(ed.buffer.substitute);
	for (;;) {
		c = getchr();
		if (c == '\\') {
			sfputc(ed.buffer.substitute, c);
			c = getchr();
		}
		else if (c == '\n' || c == EOF) {
			if (!ed.global || !ed.global[0]) {
				ed.peekc = c;
				ed.print |= PRINT;
				break;
			}
		}
		else if (c == seof)
			break;
		else if (c == '%' && !sfstrtell(ed.buffer.substitute) && ((ed.peekc = getchr()) == '\n' || ed.peekc == EOF || ed.peekc == seof)) {
			if (!*sfstrbase(ed.buffer.substitute))
				error(2, "no saved replacement string");
			sfstrset(ed.buffer.substitute, sfstrsize(ed.buffer.substitute) - 1);
			continue;
		}
		sfputc(ed.buffer.substitute, c);
	}
	sfputc(ed.buffer.substitute, 0);
	if ((ed.peekc = getchr()) == 'g') {
		ed.peekc = 0;
		newline();
		return(-1);
	}
	c = getnum();
	newline();
	return(c);
}

static void
dosub(void)
{
	register char*	s;
	register int	c;
	register int	n;

	sfstrset(ed.buffer.work, 0);
	if (n = BEG(0) - CUR())
		sfwrite(ed.buffer.work, CUR(), n);
	s = sfstrbase(ed.buffer.substitute);
	while (c = *s++) {
		if (c == '&') {
			if (n = END(0) - BEG(0))
				sfwrite(ed.buffer.work, BEG(0), n);
			continue;
		}
		if (c == '\\') {
			c = *s++;
			if (c >= MATCH_MIN && c <= MATCH_MAX) {
				c -= MATCH_MIN;
				if (HIT(c) && (n = END(c) - BEG(c)))
					sfwrite(ed.buffer.work, BEG(c), n);
				continue;
			}
		}
		sfputc(ed.buffer.work, c);
	}
	n = sfstrtell(ed.buffer.work);
	sfputr(ed.buffer.work, END(0), 0);
	swap(Sfio_t*, ed.buffer.work, ed.buffer.line);
	SET(sfstrbase(ed.buffer.line) + n);
}

static void
substitute(int inglob)
{
	register Line_t*	a1;
	register int		m;
	int			g;
	int			n;

	n = getnum();
	g = compsub();
	if (g > 0) {
		if (n)
			error(2, "only one substitute count expected");
		n = g;
		g = 0;
	}
	for (a1 = ed.addr1; a1 <= ed.addr2; a1++) {
		if (execute(a1)){
			m = n;
			do {
				int	span = END(0) - BEG(0);

				if (--m <= 0) {
					dosub();
					if (!g)
						break;
					if (!span) {
						if (!*END(0))
							break;
						NXT();
					}
				}
			} while (execute(NiL));
			if (m <= 0) {
				char*	s;
				char*	e;

				inglob = 1;
				s = sfstrbase(ed.buffer.line);
				if (e = strchr(s, '\n'))
					*e++ = 0;
				replace(a1, s);
				if (e) {
					ed.linebreak = e;
					m = append(getbreak, a1);
					a1 += m;
					ed.addr2 += m;
				}
			}
		}
	}
	if (!inglob)
		error(2, "global pattern not found");
}

static void
reverse(register Line_t* a1, register Line_t* a2)
{
	modify();
	while (--a2 > a1) {
		a1->event = a2->event = ed.event;
		a2->undo = a2->offset;
		a2->offset = a1->undo = a1->offset;
		(a1++)->offset = a2->undo;
	}
}

static void
move(int cflag)
{
	register Line_t*	adt;
	register Line_t*	ad1;
	register Line_t*	ad2;

	nonzero();
	if (!(adt = address()))
		error(2, "invalid move destination");
	newline();
	if (cflag) {
		unsigned long	m;

		ad1 = ed.dol;
		m = append(getcopy, ad1++);
		ad2 = ed.dol;
		ad1 += m;
		adt += m;
	}
	else {
		ad2 = ed.addr2;
		for (ad1 = ed.addr1; ad1 <= ad2; ad1++)
			ad1->offset &= ~LINE_GLOBAL;
		ad1 = ed.addr1;
	}
	ad2++;
	if (adt < ad1) {
		ed.dot = adt + (ad2 - ad1);
		if (++adt == ad1)
			return;
		reverse(adt, ad1);
		reverse(ad1, ad2);
		reverse(adt, ad2);
	}
	else if (adt >= ad2) {
		ed.dot = adt++;
		reverse(ad1, ad2);
		reverse(ad2, adt);
		reverse(ad1, adt);
	}
	else
		error(2, "move would do nothing");
}

static void
commands(void)
{
	register Line_t*	a1;
	register int		c;
	register int		n;
	char*			s;
	int			lastsep;

	for (;;) {
		trap();
		if (ed.print) {
			ed.addr1 = ed.addr2 = ed.dot;
			print();
		}
		if (!ed.global) {
			ed.evented = 0;
			if (ed.prompt > 0)
				sfputr(ed.msg, sfstrbase(ed.buffer.prompt), -1);
		}
		if ((c = getchr()) == ',' || c == ';') {
			ed.given = 1;
			ed.addr1 = (lastsep = c) == ',' ? ed.zero + 1 : ed.dot;
			a1 = ed.dol;
			c = getchr();
		}
		else {
			ed.addr1 = 0;
			ed.peekc = c;
			c = '\n';
			for (;;) {
				lastsep = c;
				a1 = address();
				c = getchr();
				if (c != ',' && c != ';')
					break;
				if (lastsep == ',')
					error(2, "invalid address");
				if (!a1) {
					a1 = ed.zero + 1;
					if (a1 > ed.dol)
						a1--;
				}
				ed.addr1 = a1;
				if (c == ';')
					ed.dot = a1;
			}
			if (lastsep != '\n' && !a1)
				a1 = ed.dol;
		}
		if (!(ed.addr2 = a1)) {
			ed.given = 0;
			ed.addr2 = ed.dot;	
		}
		else
			ed.given = 1;
		if (!ed.addr1)
			ed.addr1 = ed.addr2;
		switch (c) {

		case 'a':
			add(0);
			continue;

		case 'c':
			nonzero();
			newline();
			rdelete(ed.addr1, ed.addr2);
			append(getline, ed.addr1 - 1);
			continue;

		case 'd':
			nonzero();
			newline();
			rdelete(ed.addr1, ed.addr2);
			continue;

		case 'E':
			ed.modified = 0;
			c = 'e';
			/*FALLTHROUGH*/
		case 'e':
			setnoaddr();
			if (ed.verbose && ed.modified) {
				ed.modified = 0;
				error(2, "modified data not written");
			}
			/*FALLTHROUGH*/
		case 'r':
			filename(c);
			setwide();
			squeeze(0);
			c = ed.zero != ed.dol;
			append(getfile, ed.addr2);
			ed.modified = c;
			exfile();
			continue;

		case 'f':
			setnoaddr();
			filename(c);
			putrec(sfstrbase(ed.buffer.file));
			continue;

		case 'G':
			global(1, 1);
			continue;

		case 'g':
			global(1, 0);
			continue;

		case 'H':
			ed.help = !ed.help;
			/*FALLTHROUGH*/
		case 'h':
			setnoaddr();
			newline();
			if (ed.help || c == 'h')
				sfputr(ed.msg, sfstrbase(ed.buffer.help), '\n');
			continue;

		case 'i':
			add(-1);
			continue;

		case 'j':
			if (!ed.given)
				ed.addr2++;
			newline();
			join();
			continue;

		case 'k':
			nonzero();
			if ((c = getchr()) == EOF || (c -= MARK_MIN) < 0 || c >= elementsof(ed.marks))
				error(2, "invalid mark");
			newline();
			ed.addr2->offset |= LINE_MARKED;
			ed.marks[c] = ed.addr2->offset & ~LINE_GLOBAL;
			ed.marked = 1;
			continue;

		case 'm':
			move(0);
			continue;

		case 'n':
			ed.print |= PRINT_NUMBER;
			newline();
			print();
			continue;

		case '\n':
			if (!a1) {
				a1 = ed.dot + 1;
				ed.addr2 = a1;
				ed.addr1 = a1;
			}
			if (lastsep == ';')
				ed.addr1 = a1;
			print();
			continue;

		case 'l':
			ed.print |= PRINT_LIST;
			/*FALLTHROUGH*/
		case 'p':
			newline();
			print();
			continue;

		case 'P':
			setnoaddr();
			s = getrec(ed.buffer.line, '\n', 0);
			if (*s || !(ed.prompt = -ed.prompt) && (s = "*")) {
				sfstrset(ed.buffer.prompt, 0);
				sfputr(ed.buffer.prompt, s, 0);
				ed.prompt = 1;
			}
			continue;

		case 'Q':
			ed.modified = 0;
			/*FALLTHROUGH*/
		case 'q':
			setnoaddr();
			newline();
			quit(0);
			continue;

		case 'S':
			setnoaddr();
			newline();
			sfprintf(ed.msg, "file=\"%s\"%s%s%s prompt=\"%s\" tmp=%lu%s event=%lu version=%s\n", sfstrbase(ed.buffer.file), ed.modified ? " modified" : "", ed.help ? " help" : "", ed.verbose ? " verbose" : "", sfstrbase(ed.buffer.prompt), ed.tmpoff, ed.tmpoff > BLOCK_TMP ? "[file]" : "", ed.event, strrchr(id, ' ') + 1);
			continue;

		case 's':
			nonzero();
			substitute(ed.global != 0);
			continue;

		case 't':
			move(1);
			continue;

		case 'u':
			setnoaddr();
			newline();
			undo();
			continue;

		case 'V':
			global(0, 1);
			continue;

		case 'v':
			global(0, 0);
			continue;

		case 'W':
		case 'w':
			setwide();
			squeeze(ed.dol > ed.zero);
			if ((n = getchr()) != 'q' && n != 'Q') {
				ed.peekc = n;
				n = 0;
			}
			filename(c);
			if (ed.dol > ed.zero)
				putfile();
			exfile();
			if (n == 'Q' || ed.addr1 <= ed.zero + 1 && ed.addr2 == ed.dol)
				ed.modified = 0;
			if (n)
				quit(0);
			continue;

		case 'z':
			nonzero();
			page();
			continue;

		case '=':
			setwide();
			squeeze(0);
			newline();
			sfprintf(ed.msg, "%d\n", ed.addr2 - ed.zero);
			continue;

		case '!':
			shell();
			continue;

		case '#':
			setnoaddr();
			getrec(ed.buffer.line, '\n', REC_IGNORE);
			continue;

		case EOF:
			return;

		}
		error(2, "unknown command");
	}
}

int
main(int argc, char** argv)
{
	NoP(argc);
	error_info.id = "ed";
	error_info.write = helpwrite;
	init();
	for (;;)
	{
		for (;;) {
			switch (optget(argv, "hop:[prompt]qs [file]")) {

			case 'h':
				ed.help = 1;
				continue;

			case 'o':
				ed.msg = sfstderr;
				sfstrset(ed.buffer.file, 0);
				sfputr(ed.buffer.file, "/dev/stdout", 0);
				continue;

			case 'p':
				sfstrset(ed.buffer.prompt, 0);
				sfputr(ed.buffer.prompt, opt_info.arg, 0);
				ed.prompt = 1;
				continue;

			case 'q':
				signal(SIGQUIT, SIG_DFL);
				ed.verbose = 1;
				continue;

			case 's':
				ed.verbose = 0;
				continue;

			case 0:
				break;

			case '?':
				error(ERROR_USAGE|4, opt_info.arg);
				break;

			case ':':
				error(2, opt_info.arg);
				break;

			}
			break;
		}
		if (!*(argv += opt_info.index) || **argv != '-' || *(*argv + 1))
			break;
		ed.verbose = 0;
	}
	if (*argv) {
		if (*(argv + 1))
			error(ERROR_USAGE|4, opt_info.arg);
		sfprintf(ed.buffer.global, "e %s", *argv);
		ed.global = sfstruse(ed.buffer.global);
	}
	edit();
	sfslowio(sfstdin);
	setjmp(ed.again);
	commands();
	quit(0);
	exit(0);
}
#pragma prototyped

#include <ast.h>
#include <ctype.h>
#include <error.h>
#include <regex.h>

static const char id[] = "\n@(#)grep (AT&T Research) 01/01/96\0\n";

/*
 * snarfed from Doug McElroy's C++ version
 *
 * this grep is based on the Posix re package.
 * unfortunately it has to have a nonstandard interface.
 * 1. fgrep does not have usual operators. REG_LITERAL
 * caters for this.
 * 2. grep allows null expressions, hence REG_NULL.
 * 3. it may be possible to combine the multiple 
 * patterns of grep into single patterns.  important
 * special cases are handled by regcomb().
 * 4. anchoring by -x has to be done separately from
 * compilation (remember that fgrep has no ^ or $ operator),
 * hence REG_LEFT|REG_RIGHT.  (An honest, but slow alternative:
 * run regexec with REG_NOSUB off and nmatch=1 and check
 * whether the match is full length)
 */

typedef struct Item			/* list item			*/
{
	struct Item*	next;		/* next in list			*/
	union
	{
	regex_t		re;		/* re value - sue me for waste	*/
	char*		string;		/* string value			*/
	}		value;
} Item_t;

typedef struct				/* generic list			*/
{
	Item_t*		head;		/* list head			*/
	Item_t*		tail;		/* list tail			*/
} List_t;

static struct				/* program state		*/
{
	List_t		files;		/* pattern file list		*/
	List_t		patterns;	/* pattern list			*/
	List_t		res;		/* re list			*/

	int		code;		/* no hits exit code		*/
	int		hits;		/* if any patterns hit		*/
	int		options;	/* regex options		*/

	unsigned char	count;		/* count number of hits		*/
	unsigned char	list;		/* list files with hits		*/
	unsigned char	match;		/* match sense			*/
	unsigned char	query;		/* return status but no output	*/
	unsigned char	number;		/* line numbers			*/
	unsigned char	prefix;		/* print file prefix		*/
	unsigned char	suppress;	/* no unopenable file messages	*/
} state;

static void
fatal(int result)
{
	char	buf[128];

	if (result && result != REG_NOMATCH)
	{
		regerror(result, 0, buf, sizeof(buf));
		error(3, "%s", buf);
	}
}

static void
addre(List_t* p, char* s)
{
	int	result;
	Item_t*	x;

	if (!(x = newof(0, Item_t, 1, 0)))
		error(ERROR_SYSTEM|3, "out of space (pattern `%s')", s);
	if (result = regcomp(&x->value.re, s, state.options))
		fatal(result);
	if (!p->head)
		p->head = p->tail = x;
	else if (regcomb(&p->tail->value.re, &x->value.re))
		p->tail = p->tail->next = x;
	else free(x);
}

static void
addstring(List_t* p, char* s)
{
	Item_t*	x;

	if (!(x = newof(0, Item_t, 1, 0)))
		error(ERROR_SYSTEM|3, "out of space (string `%s')", s);
	x->value.string = s;
	if (p->head) p->tail->next = x;
	else p->head = x;
	p->tail = x;
}

/*
 * the update s = t+1 flagged below is formally illegal when
 * t==0, but what run-time system will catch it?
 */

static void
compile(void)
{
	int	i;
	int	line;
	char*	s;
	char*	t;
	char*	file;
	Item_t*	x;
	Sfio_t*	f;

	for (x = state.patterns.head; x; x = x->next)
		for (t = s = x->value.string; t; s = t + 1) /* see above */
		{
			if (t = strchr(s, '\n'))
				*t = 0;
			addre(&state.res, s);
		}	
	for (x = state.files.head; x; x = x->next)
	{
		s = x->value.string;
		if (f = sfopen(NiL, s, "r"))
		{
			file = error_info.file;
			error_info.file = s;
			line = error_info.line;
			error_info.line = 0;
			while (s = sfgetr(f, '\n', 1))
			{
				error_info.line++;
				addre(&state.res, s);
			}
			error_info.file = file;
			error_info.line = line;
			sfclose(f);
		}
		else if (!state.suppress)
			error(ERROR_SYSTEM|4, "%s: cannot open", s);
		else state.code = 2;
	}
	if (!(x = state.res.head))
		error(3, "no pattern#1");
}

static void
execute(Sfio_t* input, char* name)
{
	char*		s;
	char*		file;
	Item_t*		x;
	int		result;
	int		line;
	unsigned long	hits = 0;
	
	file = error_info.file;
	if (!(error_info.file = name))
		name = "(standard input)";
	line = error_info.line;
	error_info.line = 0;
	while (s = sfgetr(input, '\n', 1))
	{
		error_info.line++;
		for (x = state.res.head; x; x = x->next)
		{
			if (!(result = regexec(&x->value.re, s, 0, 0, 0)))
				break;
			if (result != REG_NOMATCH)
				fatal(result);
		}
		if ((x != 0) == state.match)
		{
			hits++;
			if (state.query || state.list)
				break;
			if (state.count)
				continue;
			if (state.prefix)
				sfprintf(sfstdout, "%s:", name);
			if (state.number)
				sfprintf(sfstdout, "%d:", error_info.line);
			sfprintf(sfstdout, "%s\n", s);
		}
	}
	error_info.file = file;
	error_info.line = line;
	if (hits)
	{
		state.hits = 1;
		if (state.query)
			return;
		if (state.list)
			sfprintf(sfstdout, "%s\n", name);
	}
	if (!state.list && state.count)
	{
		if (state.prefix)
			sfprintf(sfstdout, "%s:", name);
		sfprintf(sfstdout, "%d\n", hits);
	}
}

main(int argc, char** argv)
{
	int	c;
	char*	s;
	Sfio_t*	f;

	state.match = 1;
	state.options = REG_NOSUB|REG_NULL;
	state.code = 1;
	if (s = strrchr(argv[0], '/')) s++;
	else s = argv[0];
	switch (*s)
	{
	case 'a':
	case 'A':
		s = "agrep";
		state.options |= REG_AUGMENTED;
		break;
	case 'e':
	case 'E':
		s = "egrep";
		state.options |= REG_EXTENDED;
		break;
	case 'f':
	case 'F':
		s = "fgrep";
		state.options |= REG_LITERAL;
		break;
	default:
		s = "grep";
		break;
	}
	error_info.id = s;
	while (c = optget(argv, "AEFchilqnsvxe:[pattern]f:[file] [file ...]"))
		switch (c)
		{
		case 'A':
			state.options |= REG_AUGMENTED;
			break;
		case 'E':
			state.options |= REG_EXTENDED;
			break;
		case 'F':
			state.options |= REG_LITERAL;
			break;
		case 'c':
			state.count = 1;
			break;
		case 'e':
			addstring(&state.patterns, opt_info.arg);
			break;
		case 'f':
			addstring(&state.files, opt_info.arg);
			break;
		case 'h':
			state.prefix = 0;
			break;
		case 'i':
			state.options |= REG_ICASE;
			break;
		case 'l':
			state.list = 1;
			break;
		case 'n':
			state.number = 1;
			break;
		case 'q':
			state.query = 1;
			break;
		case 's':
			state.suppress = 1;
			break;
		case 'v':
			state.match = 0;
			break;
		case 'x':
			state.options |= REG_LEFT|REG_RIGHT;
			break;
		case '?':
			error(ERROR_USAGE|4, opt_info.arg);
			break;
		case ':':
			error(2, opt_info.arg);
			break;
		}
	argv += opt_info.index;
	if ((state.options & (REG_AUGMENTED|REG_LITERAL)) == (REG_AUGMENTED|REG_LITERAL))
		error(3, "-A and -F are incompatible");
	if ((state.options & (REG_EXTENDED|REG_LITERAL)) == (REG_EXTENDED|REG_LITERAL))
		error(3, "-E and -F are incompatible");
	if (!state.files.head && !state.patterns.head)
	{
		if (!argv[0])
			error(3, "no pattern");
		addstring(&state.patterns, *argv++);
	}
	compile();
	if (!argv[0])
		execute(sfstdin, NiL);
	else
	{
		if (!state.prefix && argv[1])
			state.prefix = 1;
		while (s = *argv++)
		{
			if (f = sfopen(NiL, s, "r"))
			{
				execute(f, s);
				sfclose(f);
			}
			else if (!state.suppress)
				error(ERROR_SYSTEM|4, "%s: cannot open", s);
			else state.code = 2;
			if (state.query && state.hits)
				break;
		}
	}
	exit(state.hits ? 0 : state.code);
}
#pragma prototyped

#include <ast.h>
#include <error.h>

#include "regex.h"

typedef unsigned char uchar;

typedef struct {
	uchar *w;		/* write pointer */
	uchar *e;		/* end */
	uchar *s;		/* start */
} Text;

extern void compile(Text *script, Text *raw);
extern void execute(Text *script, Text *input);
extern int recomp(Text *script, Text *t, int seof);
extern int match(uchar *re, Text *data, int gflag);
extern int substitute(regex_t*, Text* data, uchar *rhs, int gf);
extern regex_t *readdr(int addr);
extern void tcopy(Text *from, Text *to);
void printscript(Text *script);
extern void vacate(Text*);
extern void synwarn(char*);
extern void syntax(char*);
extern int readline(Text*);
extern int ateof(void);
extern void coda(void);

#define exch(a, b, t) ((t)=(a), (a)=(b), (b)=(t))
	
	/* space management; assure room for n more chars in Text */
#define assure(/*Text*/t, /*int*/ n) 		\
	do if((t)->s==0 || (t)->w>=(t)->e-n-1) grow(t, n);while(0)
extern void grow(Text*, int);

	/* round character pointer up to integer pointer.
	   portable to the cray; simpler tricks are not */

#define intp(/*uchar**/p) (int*)(p + sizeof(int) - 1 \
			- (p+sizeof(int)-1 - (uchar*)0)%sizeof(int))

extern int reflags;
extern int recno;
extern int nflag;
extern int qflag;
extern int sflag;
extern int bflag;
extern char *stdouterr;

extern Text files;

/* SCRIPT LAYOUT

   script commands are packed thus:
   0,1,or2 address words signed + for numbers - for regexp
   if 2 addresses, then another word indicates activity
	positive: active, the record number where activated
	negative: inactive, sign or-ed with number where deactivated
   instruction word
	high byte IMASK+flags; flags are NEG and SEL
	next byte command code (a letter)
	next two bytes, length of this command, including addrs
        (length is a multiple of 4; capacity could be expanded
	by counting the length in words instead of bytes)
   after instruction word
	on s command
		offset of regexp in rebuf
		word containing flags p,w plus n (g = >n=0)
		replacement text
		word containing file designator, if flag w
	on y command
		256-byte transliteration table
	on b and t command
		offset of label in script
*/

#define BYTE		CHAR_BIT
#define IMASK		0xC0000000	/* instruction flag */
#define NEG  		0x01000000	/* instruction written with ! */
#define LMASK		0xffff		/* low half word */
#define AMASK		0x7fffffff	/* address mask, clear sign bit */
#define INACT		(~AMASK)	/* inactive bit, the sign bit */
#define DOLLAR		AMASK		/* huge address */
#define REGADR		(~AMASK)	/* context address */
#define PFLAG		0x80000000	/* s/../../p */
#define WFLAG		0x40000000	/* s/../../g */

extern int pack(int neg, int cmd, int length);
extern int *instr(uchar*);
#define code(/*int*/ inst) ((inst)>>2*BYTE & 0xff)
#define nexti(/*uchar**/ p) ((p) + (*instr(p)&LMASK))
#pragma prototyped

#include "sed.h"

static const char id[] = "\n@(#)sed (AT&T Research) 01/01/96\0\n";

void	readscript(Text*, char*);
void	copyscript(Text*, uchar*);
void	initinput(int, char **);
Sfio_t*	aopen(char*);

#define ustrncmp(a,b,c) (uchar*)strncmp((char*)(a), (char*)(b), c)

int reflags;		/* regcomp() flags */
int recno;		/* current record number */
int nflag;		/* nonprint option */
int qflag;		/* command q executed */
int sflag;		/* substitution has occurred */
int bflag;		/* strip leading blanks from c,a,i <text> */

main(int argc, char **argv)
{
	int c;
	static Text script;
	static Text data;
	error_info.id = "sed";
	while (c = optget(argv, "bdne:[expression]f:[script]AE [file ...]"))
		switch (c)
		{
		case 'A':
			reflags |= REG_AUGMENTED;
			break;
		case 'E':
			reflags |= REG_EXTENDED;
			break;
		case 'b':
			bflag++;
			break;
		case 'e':
			copyscript(&data, (uchar*)opt_info.arg);
			break;
		case 'f':
			readscript(&data, opt_info.arg);
			break;
		case 'n':
			nflag++;
			break;
		case '?':
			error(ERROR_USAGE|4, opt_info.arg);
			break;
		case ':':
			error(2, opt_info.arg);
			break;
		}
	if (error_info.errors)
		error(ERROR_USAGE|4, optusage(NiL));
	argv += opt_info.index;
	argc -= opt_info.index;
	if(data.s == 0) {
		if(!*argv)
			error(3, "no script");
		copyscript(&data, (uchar*)*argv++);
		argc--;
	}
	if(ustrncmp(data.s, "#n", 2) == 0)
		nflag = 1;
	copyscript(&data, (uchar*)"\n\n");  /* e.g. s/a/\ */
	compile(&script, &data);
#if DEBUG
	printscript(&script);
#endif

	initinput(argc, argv);
	for(;;) {
		data.w = data.s;
		if(!readline(&data))
			break;
		execute(&script, &data);
	}
	if(sfclose(sfstdout) == EOF)
		error(3, stdouterr);
	return 0;
}

void
grow(Text *t, int n)
{
	int w = t->w - t->s;
	int e = t->e - t->s + (n/SF_BUFSIZE+1)*SF_BUFSIZE;
	t->s = (uchar*)realloc(t->s, e);
	if(t->s == 0)
		error(3, "out of space");
	t->w = t->s + w;
	t->e = t->s + e;
}

/* BUG: a segment that ends with a comment whose
   last character is \ causes a diagnostic */

void
safescript(Text *t)
{
	if(t->w > t->s+1 && t->w[-2] == '\\')
		error(1, "script segment ends with \\");
}

void
readscript(Text *t, char *s)
{
	int n;
	Sfio_t *f = aopen(s);
	for(;;) {
		assure(t, 4);
		n = sfread(f, t->w, t->e - t->w - 3);
		if(n <= 0)
			break;
		t->w += n;
	}
	sfclose(f);
	if(t->w > t->s && t->w[-1] != '\n') {
		*t->w++ = '\n';
		error(1, "newline appended to script segment");
	}
	*t->w = 0;
	safescript(t);
}

void
copyscript(Text *t, uchar *s)
{
	do {
		assure(t, 2);
	} while(*t->w++ = *s++);
	if(--t->w > t->s && t->w[-1] != '\n') {
		*t->w++ = '\n';
		*t->w = 0;
	}
	safescript(t);
}

/* DATA INPUT */

struct {
	int iargc;		/* # of files not fully read */
	char **iargv;		/* current file */
	Sfio_t *ifile;		/* current input file */
} input;

int
readline(Text *t)
{
	char*	s;
	int	c;

	coda();
	if (qflag || ateof())
		return 0;
	while (!(s = sfgetr(input.ifile, '\n', 1)))
	{
		if (s = sfgetr(input.ifile, '\n', -1))
		{
			error(1, "newline appended");
			break;
		}
		error_info.file = 0;
		error_info.line = 0;
		if (--input.iargc <= 0)
			return 0;
		sfclose(input.ifile);
		input.ifile = aopen(*++input.iargv);
		error_info.file = *input.iargv;
	}
	c = sfslen();
	assure(t, c);
	memcpy(t->w, s, c);
	t->w += c - 1;

	/*
	 * peek ahead to identify line $
	 */

	if ((c = sfgetc(input.ifile)) != EOF)
		sfungetc(input.ifile, c);
	else if (input.iargc == 1)
		input.iargc = 0;
	error_info.line++;
	recno++;
	sflag = 0;
	return 1;
}	

int 
ateof(void)
{
	return input.iargc <= 0;
}	

void
initinput(int argc, char **argv)
{
	input.iargc = argc;
	input.iargv = argv;
	if(input.iargc == 0) {
		input.iargc = 1;	/* for ateof() */
		input.ifile = sfstdin;
	} else {
		input.ifile = aopen(*input.iargv);
		error_info.file = *input.iargv;
	}
}

Sfio_t *
aopen(char *s)
{
	Sfio_t *f = sfopen(NiL, s, "r");
	if(f == 0)
		error(ERROR_SYSTEM|3, "%s: cannot open", s);
	return f;
}

#if DEBUG & 1

/* debugging code 1; compile and execute stubs.
   simply prints the already collected script and
   prints numbered input lines */

void
compile(Text *script, Text *t)
{
	uchar *s = t->s;
	assure(script, 1);
	*script->w++ = 0;
	while(*s) sfputc(sfstdout, *s++);
}

void
execute(Text *x, Text *y)
{
	x = x;		
	sfprintf(sfstdout, "%d: %s", recno, y->s);
}

#endif
#pragma prototyped

#include "sed.h"

#include <ctype.h>

#define ustrlen(p) strlen((char*)(p))
#define ustrcmp(p, q) strcmp((char*)(p), (char*)(q))
#define ustrcpy(p, q) (uchar*)strcpy((char*)(p), (char*)(q))
#define ustrchr(p, c) (uchar*)strchr((char*)(p), c)

int blank(Text*);
void fixlabels(Text*);
void fixbrack(Text*);
void ckludge(Text*, int, int, int, Text*);
int addr(Text*, Text*);
int pack(int, int, int);
int* instr(uchar*);
uchar *succi(uchar*);

#if DEBUG
extern void regdump(regex_t*);	/* secret entry into regex pkg */
#endif

int semicolon;
Text rebuf;

uchar adrs[256] = {	/* max no. of addrs, 3 is illegal */
	0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, /* <nl> */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 2, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* !# */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 1, 3, 3, /* := */
	3, 3, 3, 3, 2, 3, 3, 2, 2, 3, 3, 3, 3, 3, 2, 3, /* DGHN */
	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* P */
	3, 1, 2, 2, 2, 3, 3, 2, 2, 1, 3, 3, 2, 3, 2, 3, /* a-n */
	2, 1, 2, 2, 2, 3, 3, 2, 2, 2, 3, 2, 3, 0, 3, 3, /* p-y{} */
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
};

#define Ec Tc	/* commands that have same compilation method */
#define Dc Tc
#define Gc Tc
#define Hc Tc
#define Nc Tc
#define Pc Tc
#define dc Tc
#define gc Tc
#define hc Tc
#define lc Tc
#define nc Tc
#define pc Tc
#define qc Tc
#define xc Tc
#define tc bc
#define ic ac
#define cc ac

uchar *synl;	/* current line pointer for syntax errors */

/* COMMAND LAYOUT */

int
blank(Text *t)
{
	if(*t->w==' ' || *t->w=='\t') {
		t->w++;
		return 1;
	} else
		return 0;
}

int *
instr(uchar *p)		/* get address of command word */
{
	int *q = (int*)p;
	while((*q & IMASK) != IMASK)
		q++;
	return q;
}

uchar *
succi(uchar *p)
{
	int *q = instr(p);
	if(code(*q) == '{')
		return (uchar*)(q+1);
	else
		return p + (*q & LMASK);
}

int
pack(int neg, int cmd, int length)
{
	int l = length & LMASK;
	if(length != l)
		syntax("<command-list> or <text> too long");
	return IMASK | neg | cmd << 2*BYTE | l;
}

void
putint(Text *s, int n)
{
	assure(s, sizeof(int));
	*(int*)s->w = n;
	s->w += sizeof(int);
}

int
number(Text *t)
{
	unsigned n = 0;
	while(isdigit(*t->w)) {
		if(n > (INT_MAX-9)/10)
			syntax("number too big");
		n = n*10 + *t->w++ - '0';
	}
	return n;
}	

int
addr(Text *script, Text *t)
{
	int n;
	switch(*t->w) {
	default:
		return 0;
	case '$':
		t->w++;
		n = DOLLAR;
		break;
	case '\\':
		t->w++;
		if(*t->w=='\n' ||*t->w=='\\')
			syntax("bad regexp delimiter");
	case '/':
		n = recomp(&rebuf, t, *t->w++) | REGADR;
		break;
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		n = number(t);
		if(n == 0)
			syntax("address is zero");
	}
	putint(script, n);
	return 1;
}

regex_t *
readdr(int x)
{
	return (regex_t*)(rebuf.s + (x&AMASK));
}

/* LABEL HANDLING */

/* the labels array consists of int values followed by strings.
   value -1 means unassigned; other values are relative to the
   beginning of the script 

   on the first pass, every script ref to a label becomes the
   integer offset of that label in the labels array, or -1 if
   it is a branch to the end of script

   on the second pass (fixlabels), the script ref is replaced
   by the value from the labels array. */

Text labels;

int *
lablook(uchar *l, Text *labels)
{
	uchar *p, *q;
	int n;
	assure(labels, 1);
	for(p = labels->s; p < labels->w; ) {
		q = p + sizeof(int);
		if(ustrcmp(q, l) == 0)
			return (int*)p;
		q += ustrlen(q) + 1;
		p = (uchar*)intp(q);
	}
	n = ustrlen(l);
	assure(labels, sizeof(int)+n+1+sizeof(int));
	*(int*)p = -1;
	q = p + sizeof(int);
	ustrcpy(q, l);
	q += ustrlen(q) + 1;
	labels->w = (uchar*)intp(q);
	return (int*)p;
}

/* find pos in label list; assign value i to label if i>=0 */

int
getlab(Text *t, int i)
{
	int *p;
	uchar *u;
	while(blank(t));	/* not exactly posix */
	for(u=t->w; *t->w!='\n'; t->w++)
		if(!isprint(*t->w) || *t->w==' ')
			synwarn("invisible character in name");
	if(u == t->w)
		return -1;
	*t->w = 0;
	p = lablook(u, &labels);
	if(*p == -1)
		*p = i;
	else if(i != -1)
		syntax("duplicate label");
	*t->w = '\n';
	return (uchar*)p - labels.s;
}

void
Cc(Text *script, Text *t)	/* colon */
{
	if(getlab(t, script->w - sizeof(int) - script->s) == -1)
		syntax("missing label");
}

void
bc(Text *script, Text *t)
{
	int g;
	g = getlab(t, -1);	/* relative pointer to label list */
	putint(script, g);
}
			
void
fixlabels(Text *script)
{
	uchar *p;
	int *q;
	for(p=script->s; p<script->w; p=succi(p)) {
		q = instr(p);
		switch(code(*q)) {
		case 't':
		case 'b':
			if(q[1] == -1)
				q[1] = script->w - script->s;
			else if(*(int*)(labels.s+q[1]) != -1)
				q[1] = *(int*)(labels.s+q[1]);
			else
				error(3, "undefined label: %s",
					labels.s+q[1]+sizeof(int));
		}
	}
	free(labels.s);
}

/* FILES */

Text files;

void
rc(Text *script, Text *t)
{
	uchar *u;
	if(!blank(t))
		synwarn("no space before file name");
	while(blank(t)) ;
	for(u=t->w; *t->w!='\n'; t->w++) ;
	if(u == t->w)
		syntax("missing file name");
	*t->w = 0;
	putint(script, (uchar*)lablook(u, &files) - files.s);
	*t->w = '\n';
}

void
wc(Text *script, Text *t)
{
	int *p;
	rc(script, t);
	p = (int*)(files.s + ((int*)script->w)[-1]);
	if(*p != -1)
		return;
	*(Sfio_t**)p = sfopen(NiL, (char*)(p+1), "w");
	if(*p == 0)
		syntax("can't open file for writing");
}

/* BRACKETS */

Text brack;

/* Lc() stacks (in brack) the location of the { command word.
   Rc() stuffs into that word the offset of the } sequel
   relative to the command word.
   fixbrack() modifies the offset to be relative to the
   beginning of the instruction, including addresses. */

void				/* { */
Lc(Text *script, Text *t)
{
	while(blank(t));
	putint(&brack, script->w - sizeof(int) - script->s);
}

void				/* } */
Rc(Text *script, Text *t)
{
	int l;
	int *p;
	t = t;
	if(brack.w == 0 || (brack.w-=sizeof(int)) < brack.s)
		syntax("unmatched }");
	l = *(int*)brack.w;
	p = (int*)(script->s + l);
	l = script->w - script->s - l;
	if(l >= LMASK - 3*sizeof(int))	/* fixbrack could add 3 */
		syntax("{command-list} too long)");
	*p = (*p&~LMASK) | l;
}

void
fixbrack(Text *script)
{
	uchar *p;
	int *q;
	if(brack.w == 0)
		return;
	if(brack.w > brack.s)
		syntax("unmatched {");
	for(p=script->s; p<script->w; p=succi(p)) {
		q = instr(p);
		if(code(*q) == '{')
			*q += (uchar*)q - p;
	}
	free(brack.s);
}

/* EASY COMMANDS */

void
Xc(Text *script, Text *t)	/* # */
{
	script = script;	/* avoid use/set diagnostics */
	if(t->s[1]=='n')
		nflag = 1;
	while(*t->w != '\n')
		t->w++;
}

void
Ic(Text *script, Text *t)	/* ignore */
{
	script = script;
	t->w--;
}

void
Tc(Text *script, Text *t)	/* trivial to compile */
{
	script = script;
	t = t;
}

void
xx(Text *script, Text *t)
{
	script = script;
	t = t;
	syntax("unknown command");
}

/* MISCELLANY */

void
ac(Text *script, Text *t)
{
	if(*t->w++ != '\\' || *t->w++ != '\n')
		syntax("\\<newline> missing after command");
	for(;;) {
		while(bflag && blank(t)) ;
		assure(script, 2 + sizeof(int));
		switch(*t->w) {
		case 0:
			error(ERROR_PANIC|4, "bug: missed end of <text>");
		case '\n':
			*script->w++ = *t->w;
			*script->w++ = 0;
			script->w = (uchar*)intp(script->w);
			return;
		case '\\':
			t->w++;
		default:
			*script->w++ = *t->w++;
		}
	}
}
void
yc(Text *script, Text *t)
{
	int i;
	int delim = *t->w++;
	uchar *s = script->w;
	uchar *p, *q;
	if(delim == '\n' || delim=='\\')
		syntax("missing delimiter");
	assure(script, 256);
	for(i=0; i<256; i++) 
		s[i] = 0;
	for(q=t->w; *q!=delim; q++)
		if(*q == '\n')
			syntax("missing delimiter");
		else if(*q=='\\' && q[1]==delim)
			q++;
	for(p=t->w, q++; *p != delim; p++, q++) {
		if(*p=='\\' && p[1]==delim)
			p++;
		if(*q == '\n')
			syntax("missing delimiter");
		if(*q == delim)
			syntax("string lengths differ");
		if(*q=='\\' && q[1]==delim)
			q++;
		if(s[*p] && s[*p]!=*q)
			syntax("ambiguous map");
		if(s[*p])
			synwarn("redundant map");
		s[*p] = *q;
	}
	if(*q++ != delim)
		syntax("string lengths differ");
	for(i=0; i<256; i++)
		if(s[i] == 0)
			s[i] = i;
	t->w = q;
	script->w += 256;
}

void
sc(Text *script, Text *t)
{
	int c, flags, re, nsub;
	int *q;
	int n = -1;
	int delim = *t->w++;
	switch(delim) {
	case '\n':
	case '\\':
		syntax("improper delimiter");
	}
	re = recomp(&rebuf, t, delim);
	putint(script, re);
	nsub = readdr(re)->re_nsub;
	flags = script->w - script->s;
	putint(script, 0);		/* space for flags */
	while((c=*t->w++) != delim) {
		assure(script, 3+sizeof(int*));
		if(c == '\n')
			syntax("unterminated command");
		else if(c == '\\') {
			int d = *t->w++;
			if(d==delim)
				;
			else if(d=='&' || d=='\\')
				*script->w++ = c;
			else if(d>='0' && d<='9') {
				if(d > '0'+nsub)
					syntax("improper backreference");
				*script->w++ = c;
			}
			c = d;
		}
		*script->w++ = c;
	}
	*script->w++ = 0;
	script->w = (uchar*)intp(script->w);
	q = (int*)(script->s + flags);
	*q = 0;
	for(;;) {
		switch(*t->w) {
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			if(n != -1)
				syntax("extra flags");
			n = number(t);
			if(n == 0 || (n&(PFLAG|WFLAG)) != 0)
				syntax("count out of range");
			continue;
		case 'p':
			if(*q & PFLAG)
				syntax("extra flags");
			t->w++;
			*q |= PFLAG;
			continue;
		case 'g':
			t->w++;
			if(n != -1)
				syntax("extra flags");
			n = 0;
			continue;
		case 'w':
			t->w++;
			*q |= WFLAG;	 
			wc(script, t);
		}
		break;
	}
	*q |= n==-1? 1: n;
}		

void
synwarn(char *s)
{
	uchar *t = ustrchr(synl, '\n');
	error(1, "%s: %.*s", s, t-synl, synl);
}

void
syntax(char *s)
{
	uchar *t = ustrchr(synl, '\n');
	error(3, "%s: %.*s", s, t-synl, synl);
}

#if DEBUG

void
printscript(Text *script)
{
	uchar *s;
	int *q;
	for(s=script->s; s<script->w; s = succi(s)) {
		q = (int*)s;
		if((*q&IMASK) != IMASK) {
			if((*q&REGADR) == 0)
				printf("%d", *q);
			else
				regdump((regex_t*)(*q & AMASK));
			q++;
		}
		if((*q&IMASK) != IMASK) {
			if((*q&REGADR) == 0)
				printf(",%d", *q);
			else
				regdump((regex_t*)(*q & AMASK));
			q += 2;
		}
		if(code(*q) == '\n')
			continue;
		printf("%s%c\n", *q&NEG?"!":"", code(*q));
	}	
}

#endif

#if DEBUG & 2

/* debugging code 2; execute stub.
   prints the compiled script (without arguments)
   then each input line with line numbers */

void
execute(Text *script, Text *y)
{
	if(recno == 1)
		printscript(script);
	printf("%d:%s",recno,y->s);
}

#endif

typedef void (*cmdf)(Text*, Text*);

static cmdf docom[128] = {
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,Ic,xx,xx,xx,xx,xx, /* <nl> */
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,
	xx,Ic,xx,Xc,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx, /* !# */
	xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,Cc,Ic,xx,Ec,xx,xx, /* :;= */
	xx,xx,xx,xx,Dc,xx,xx,Gc,Hc,xx,xx,xx,xx,xx,Nc,xx, /* DGHN */
	Pc,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx, /* P */
	xx,ac,bc,cc,dc,xx,xx,gc,hc,ic,xx,xx,lc,xx,nc,xx, /* a-n */
	pc,qc,rc,sc,tc,xx,xx,wc,xc,yc,xx,Lc,xx,Rc,xx,xx  /* p-y{} */
};


void
compile(Text *script, Text *t)
{
	int loc;	/* progam counter */
	int neg;	/* ! in effect */
	int cmd;
	int naddr;
	int *q;		/* address of instruction word */
	t->w = t->s;	/* here w is a read pointer */
	while(*t->w) {
		assure(script, 4*sizeof(int));
		loc = script->w - script->s;
		synl = t->w;
		naddr = 0;
		while(blank(t)) ;
		naddr += addr(script, t);
		if(naddr && *t->w ==',') {
			t->w++;
			naddr += addr(script, t);
			if(naddr < 2)
				syntax("missing address");
		}
		q = (int*)script->w;
		if(naddr == 2)
			*q++ = INACT;
		script->w = (uchar*)(q+1);
		neg = 0;
		for(;;) {
			while(blank(t));
			cmd = *t->w++;
			if(neg && docom[cmd&0xff]==Ic)
				syntax("improper !");
			if(cmd != '!')
				break;
			neg = NEG;
		}
		if(!neg) {
			switch(adrs[cmd]) {
			case 1:
				if(naddr <= 1)
					break;
			case 0:
				if(naddr == 0)
					break;
				syntax("too many addresses");
			}
		}
		(*docom[cmd&0xff])(script, t);
		switch(*t->w) {
		case 0:
			script->w = script->s + loc;
			break;
		default:
			if(cmd == '{')
				break;
			syntax("junk after command");
		case ';':
			if(!semicolon++)
				synwarn("semicolon separators");
		case '\n':
				t->w++;
		}
		*q = pack(neg,cmd,script->w-script->s-loc);
	}
	fixbrack(script);
	fixlabels(script);
}
#pragma prototyped

#include "sed.h"

#include <ctype.h>

#define ustrchr(p, c) (uchar*)strchr((char*)(p), c)

int selected(uchar*, Text*);

#define Re Ie
#define Ce Ie
#define Se Ie
#define re ae

#define IBUG "interpreter bug %d"
char *stdouterr = "writing standard output";

Text hold;

void
cputchar(int c)
{
	if(sfputc(sfstdout, c) == EOF)
		error(3, stdouterr);
}

void
writeline(Text *data)
{
	int n = data->w - data->s;
	if(sfwrite(sfstdout, data->s, n) != n)
		error(ERROR_SYSTEM|3, stdouterr);
	cputchar('\n');
}

/* return 1 if action is to be taken on current line,
         -1 if (numeric) address has been passed,
	  0 otherwise*/
int
sel1(int addr, Text *data)
{
	if(addr & REGADR)
		return regexec(readdr(addr),(char*)data->s,0,0,0) == 0;
	if(addr == recno)
		return 1;
	if(addr == DOLLAR)
		return ateof();
	if(addr < recno)
		return -1;
	return 0;
}

/* return 2 on non-final line of a selected range,
          1 on any other selected line,
	  0 on non-selected lines 
   (the 1-2 distinction matters only for 'c' commands) */

int
selected(uchar *pc, Text *data)
{
	int active;
	int *ipc = (int*)pc;	/* points to address words */
	int *q = instr(pc);	/* points to instruction word */
	int neg = !!(*q & NEG);
	switch(q - ipc)	{
	case 0:			/* 0 address */
		return !neg;
	case 1:			/* 1 address */
		return neg ^ sel1(ipc[0], data)==1;
	case 2:
		error(ERROR_PANIC|4, IBUG,1);
	case 3:			/* 2 address */
		q--;		/* points to activity indicator */
		active = !(*q & INACT);
		if((*q&AMASK) < recno) {
			switch(sel1(ipc[active], data)) {
			case 0:
				if((active&ateof()) == 0)
					break;
			case 1:
				*q = recno;
				if(active)
					*q |= INACT;
				return (neg^1) << (!active&!ateof());
			case -1:
				if(active) {
					*q = recno | INACT;
					return neg;
				}
			}
		}
		return (neg^active) << 1;
	default:
		error(ERROR_PANIC|4, IBUG,2);
		return 0;	/* dummy */
	}
}

void
vacate(Text *t)
{
	assure(t, 1);
	t->w = t->s;
	*t->w = 0;
}

void
tcopy(Text *from, Text *to)
{
	int n = from->w - from->s;
	assure(to, n+1);
	memmove(to->w, from->s, n);
	to->w += n;
	*to->w = 0;
}
	

/* EASY COMMANDS */

uchar *
vv(Text *script, uchar *pc, Text *data)
{
	script = script;
	pc = pc;
	data = data;
	error(ERROR_PANIC|4, IBUG,3);
	return 0;	/* dummy */
}

uchar *
be(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return script->s + instr(pc)[1];
}

uchar *
de(Text *script, uchar *pc, Text *data)
{
	pc = pc;
	vacate(data);
	return 0;
}

uchar *
De(Text *script, uchar *pc, Text *data)
{
	int n;
	uchar *end = (uchar*)ustrchr(data->s, '\n');
	if(end == 0)
		return de(script, pc, data);
	end++;
	n = data->w - end;
	memmove(data->s, end, n+1);
	data->w = data->s + n;
	return script->s;
}

uchar *
Ee(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	if(sfprintf(sfstdout, "%d\n", recno) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return nexti(pc);
}

uchar *
Ge(Text *script, uchar *pc, Text *data)
{
	script = script;
	if(hold.s == 0) 
		vacate(&hold);
	if(data->w > data->s)
		*data->w++ = '\n';
	tcopy(&hold, data);
	return nexti(pc);
}

uchar *
ge(Text *script, uchar *pc, Text *data)
{
	vacate(data);
	return Ge(script, pc, data);
}

uchar *
He(Text *script, uchar *pc, Text *data)
{
	script = script;
	assure(&hold, 1);
	*hold.w++ = '\n';
	tcopy(data, &hold);
	return nexti(pc);
}

uchar *
he(Text *script, uchar *pc, Text *data)
{
	script = script;
	vacate(&hold);
	tcopy(data, &hold);
	return nexti(pc);
}

uchar *
Ie(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return nexti(pc);
}

uchar *
ie(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	if(sfprintf(sfstdout, "%s", (char*)(instr(pc)+1)) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return nexti(pc);
}

uchar *
Le(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	return (uchar*)(instr(pc)+1);
}

uchar *
Ne(Text *script, uchar *pc, Text *data)
{
	assure(data, 1);
	*data->w++ = '\n';
	if(readline(data))
		return nexti(pc);
	*--data->w = 0;
	return de(script, pc, data);
}

uchar *
ne(Text *script, uchar *pc, Text *data)
{
	if(!nflag)
		writeline(data);
	vacate(data);
	if(readline(data))
		return nexti(pc);
	return 0;
}

uchar *
Pe(Text *script, uchar *pc, Text *data)
{
	int n;
	uchar *end = ustrchr(data->s, '\n');
	if(end == 0)
		n = data->w - data->s;
	else
		n = end - data->s;
	if(sfwrite(sfstdout, data->s, n) != n)
		error(ERROR_SYSTEM|3, stdouterr);
	cputchar('\n');
	script = script;
	return nexti(pc);
}

uchar *
pe(Text *script, uchar *pc, Text *data)
{
	writeline(data);
	script = script;
	return nexti(pc);
}

uchar *
qe(Text *script, uchar *pc, Text *data)
{
	pc = pc;
	data = data;
	qflag++;
	return script->w;
}

uchar *
te(Text *script, uchar *pc, Text *data)
{
	int tflag = sflag;
	sflag = 0;
	if(tflag)
		return be(script, pc, data);
	else
		return nexti(pc);
}

uchar *
ww(Text *script, uchar *pc, Text *data, int offset)
{
	int *q = (int*)(files.s + offset);
	Sfio_t *f = *(Sfio_t**)q;
	int n = data->w - data->s;
	assure(data, 1);
	*data->w = '\n';
	if(sfwrite(f, data->s, n+1) != n+1 ||
	   sfsync(f) == EOF)	/* in case of subsequent r */
		error(ERROR_SYSTEM|3, "%s: cannot write", (char*)(q+1));
	*data->w = 0;
	script = script;
	return nexti(pc);
}

uchar *
we(Text *script, uchar *pc, Text *data)
{
	return ww(script, pc, data, instr(pc)[1]);
}

uchar *
xe(Text *script, uchar *pc, Text *data)
{
	uchar *t;
	script = script;
	if(hold.s == 0)
		vacate(&hold);
	exch(data->s, hold.s, t);
	exch(data->e, hold.e, t);
	exch(data->w, hold.w, t);
	return nexti(pc);
}

uchar *
ye(Text *script, uchar *pc, Text *data)
{
	uchar *s = (uchar*)data->s;
	uchar *w = (uchar*)data->w;
	uchar *tbl = (uchar*)(instr(pc)+1);
	for( ; s<w; s++)
		*s = tbl[*s];
	script = script;
	return nexti(pc);
}

/* MISCELLANY */

uchar *
se(Text *script, uchar *pc, Text *data)
{
	int *q = instr(pc);
	int flags = q[2];
	uchar *p = (uchar*)(flags&WFLAG? q+4: q+3);
	int n = flags & ~(PFLAG|WFLAG);

	sflag = substitute(readdr(q[1]), data, p, n);
	if(!sflag)
		return nexti(pc);
	if(flags & PFLAG)
		pe(script, pc, data);
	if(flags & WFLAG)
		return ww(script, pc, data, ((int*)nexti(pc))[-1]);
	return nexti(pc);
}

struct { char p, q; } digram[] = {
	'\\',	'\\',
	'\a',	'a',
	'\b',	'b',
	'\f',	'f',
	'\n',	'n',
	'\r',	'r',
	'\t',	't',
	'\v',	'v',
};

uchar *
le(Text *script, uchar *pc, Text *data)
{
	int i = 0;
	int j;
	uchar *s;
	script = script;
	for(s=data->s; s<data->w; s++, i++) {
		if(i >= 60) {
			cputchar('\\');
			cputchar('\n');
			i = 0;
		}
		for(j=0; j<sizeof(digram)/sizeof(*digram); j++)
			if(*s == digram[j].p) {
				cputchar('\\');
				cputchar(digram[j].q);
				goto cont;
			}
		if(!isprint(*s)) {
			if(sfprintf(sfstdout, "\\%3.3o", *s) <= 0)
				error(ERROR_SYSTEM|3, stdouterr);
		} else
			cputchar(*s);
	cont:	;
	}
	cputchar('$');
	cputchar('\n');
	return nexti(pc);
}	

/* END-OF-CYCLE STUFF */

Text todo;

uchar *
ae(Text *script, uchar *pc, Text *data)
{
	script = script;
	data = data;
	assure(&todo, sizeof(uchar*));
	*(uchar**)todo.w = pc;
	todo.w += sizeof(uchar*);
	return nexti(pc);
}

uchar *
ce(Text *script, uchar *pc, Text *data)
{	
	if(sfprintf(sfstdout, "%s", (char*)(instr(pc)+1)) <= 0)
		error(ERROR_SYSTEM|3, stdouterr);
	return de(script, pc, data);
}

void
coda(void)
{
	int *q;
	uchar *p;
	Sfio_t *f;
	if(todo.s == 0)
		return;
	for(p=todo.s; p<todo.w; p+=sizeof(int)) {
		q = instr(*(uchar**)p);
		switch(code(*q)) {
		case 'a':
			if(sfprintf(sfstdout, "%s", (char*)(q+1)) <= 0)
				error(ERROR_SYSTEM|3, stdouterr);
			continue;
		case 'r':
			f = sfopen(NiL, (char*)(files.s+q[1]+sizeof(int)), "r");
			if(f == 0)
				continue;
			if (sfmove(f, sfstdout, SF_UNBOUND, -1) < 0 || !sfeof(f) || sferror(sfstdout))
				error(ERROR_SYSTEM|3, stdouterr);
			sfclose(f);
			continue;
		default:
			error(ERROR_PANIC|4, IBUG,5);
		}
	}
	vacate(&todo);
}

/* execution functions return pointer to next instruction */

typedef uchar* (*exef)(Text*, uchar *, Text*);

static exef excom[128] = {
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,Ie,vv,vv,vv,vv,vv,
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,
	vv,vv,vv,Ie,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv, /* # */
	vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,Ce,Se,vv,Ee,vv,vv, /* :;= */
	vv,vv,vv,vv,De,vv,vv,Ge,He,vv,vv,vv,vv,vv,Ne,vv, /* DGHN */
	Pe,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv,vv, /* P */
	vv,ae,be,ce,de,vv,vv,ge,he,ie,vv,vv,le,vv,ne,vv, /* a-n */
	pe,qe,re,se,te,vv,vv,we,xe,ye,vv,Le,vv,Re,vv,vv  /* p-y{} */
};

void
execute(Text *script, Text *data)
{
	uchar *pc;
	int sel;
	for(pc = script->s; pc < script->w; ) {
		sel = selected(pc, data);
		if(sel) {
			int cmd = code(*instr(pc));
			if(sel==2 && cmd=='c')
				cmd = 'd';
			pc = (*excom[cmd])(script, pc, data);
			if(pc == 0)
				return;
		} else
			pc = nexti(pc);
	}
	if(!nflag)
		writeline(data);
}
#pragma prototyped

#include "sed.h"

void docopy(uchar *where, int n);
int dosub(uchar *where, uchar *rp);

Text retemp;	/* holds a rewritten regex, without delimiter */

int
recomp(Text *rebuf, Text *t, int delim)
{
	static int lastre;
	uchar *w;
	vacate(&retemp);
	for(w=t->w; ; retemp.w++,w++) {
		assure(&retemp, 2);
		*retemp.w = *w;
		if(*w == delim)
			break;
		else if(*w==0 || *w=='\n')
			syntax("unterminated address");
		else if(*w != '\\')
			continue;
		else if(*++w==delim)
			*retemp.w = delim;
		else if(*w == 'n')
			*retemp.w = '\n';
		else if(*w==0 || *w=='\n')
			syntax("unterminated regular expression");
		else {
			assure(&retemp, 2);
			*++retemp.w = *w;
		}
	}
	*retemp.w = 0;

	assure(rebuf, sizeof(regex_t));
	if(*retemp.s) {
		if(regcomp((regex_t*)rebuf->w,(char*)retemp.s,reflags))
			syntax("bad regular expression");
		lastre = rebuf->w - rebuf->s;
		rebuf->w += sizeof(regex_t);
	} else if(rebuf->w == rebuf->s)
		syntax("no previous regular expression");
	t->w = w + 1;
	return lastre;
}

Text gendata;

#define NMATCH 10
regmatch_t matches[NMATCH];
#define so matches[0].rm_so
#define eo matches[0].rm_eo

int
substitute(regex_t *re, Text* data, uchar *rhs, int n)
{
	Text t;
	uchar *where = data->s;
	if(regexec(re, (char*)data->s, NMATCH, matches, 0))
		return 0;
	vacate(&gendata);
	if(n == 0)
		do {
			docopy(where, so);
			if(!dosub(where, rhs))
				return 0;
			where += eo;
			if(eo == so)
				if(where < data->w)
					docopy(where++, 1);
				else
					goto done;
		} while(regexec(re, (char*)where, NMATCH, matches, REG_NOTBOL) == 0);
	else {
		while(--n > 0) {
			where += eo;
			if(eo == so)
				if(where < data->w)
					where++;
				else
					return 0;
			if(regexec(re, (char*)where, NMATCH, matches, REG_NOTBOL))
				return 0;
		}
		docopy(data->s, where-data->s+so);
		if(!dosub(where, rhs))
			return 0;
		where += eo;
	}			
	eo = so = data->w - where;
	docopy(where, so);
done:
	exch(gendata, *data, t);
	return 1;
}

void
docopy(uchar *where, int n)
{
	assure(&gendata, n+1);
	memmove(gendata.w, where, n);
	gendata.w += n;
	*gendata.w = 0;
}

	/* interpretation problem: if there is no match for \1, say,
           does the substitition occur?  dosub uses a null string.
	   a change where indicated will abort the substitution */
	
int
dosub(uchar *where, uchar *rp)
{
	int c, n;
	regmatch_t *m;

	while(c = *rp++) {
		if(c == '\\') {
			c = *rp++;
			if (c >= '1' && c <= '9') {
				m = matches + c - '0';
				if(m->rm_eo == -1)
					continue;   /* or return 0 */
				n = m->rm_eo - m->rm_so;
				assure(&gendata, n);
				memmove(gendata.w,where+m->rm_so,n);
				gendata.w += n;
				continue;
			}
		} else if(c == '&') {
				assure(&gendata, eo-so);
				memmove(gendata.w,where+so,eo-so);
				gendata.w += eo-so;
				continue;
		}
		assure(&gendata, 1);
		*gendata.w++ = c;
	}
	return 1;
}
#pragma prototyped

/*
 * regular-expression tester
 *
 * usage: testre <testre.dat
 * see comments in testre.dat for description of format
 */

static const char id[] = "\n@(#)testre (AT&T Research) 01/01/96\0\n";

#include <ast.h>
#include <ctype.h>
#include <regex.h>
#include <setjmp.h>
#include <sig.h>
#include <stk.h>

#define LOOPED		2

#define NOTEST		(~0)
#ifndef REG_LEFT
#define REG_LEFT	NOTEST
#endif
#ifndef REG_MINIMAL
#define REG_MINIMAL	NOTEST
#endif
#ifndef REG_NULL
#define REG_NULL	NOTEST
#endif
#ifndef REG_RIGHT
#define REG_RIGHT	NOTEST
#endif

#define REG_UNKNOWN	(-1)

#ifndef REG_ENEWLINE
#define REG_ENEWLINE	(REG_UNKNOWN-1)
#endif
#ifndef REG_ENULL
#define REG_ENULL	(REG_UNKNOWN-2)
#endif
#ifndef REG_ECOUNT
#define REG_ECOUNT	(REG_UNKNOWN-3)
#endif
#ifndef REG_BADESC
#define REG_BADESC	(REG_UNKNOWN-4)
#endif
#ifndef REG_EMEM
#define REG_EMEM	(REG_UNKNOWN-5)
#endif
#ifndef REG_ELOOP
#define REG_ELOOP	(REG_UNKNOWN-6)
#endif
#ifndef REG_EBUS
#define REG_EBUS	(REG_UNKNOWN-7)
#endif
#ifndef REG_EFAULT
#define REG_EFAULT	(REG_UNKNOWN-8)
#endif

static const struct { int code; char* name; } codes[] = {
	REG_UNKNOWN,	"UNKNOWN",
	REG_NOMATCH,	"NOMATCH",
	REG_BADPAT,	"BADPAT",
	REG_ECOLLATE,	"ECOLLATE",
	REG_ECTYPE,	"ECTYPE",
	REG_EESCAPE,	"EESCAPE",
	REG_ESUBREG,	"ESUBREG",
	REG_EBRACK,	"EBRACK",
	REG_EPAREN,	"EPAREN",
	REG_EBRACE,	"EBRACE",
	REG_BADBR,	"BADBR",
	REG_ERANGE,	"ERANGE",
	REG_ESPACE,	"ESPACE",
	REG_BADRPT,	"BADRPT",
	REG_ENEWLINE,	"ENEWLINE",
	REG_ENULL,	"ENULL",
	REG_ECOUNT,	"ECOUNT",
	REG_BADESC,	"BADESC",
	REG_EMEM,	"EMEM",
	REG_ELOOP,	"ELOOP",
	REG_EBUS,	"EBUS",
	REG_EFAULT,	"EFAULT",
};

static struct
{
	int	failures;
	int	goofs;
	int	lineno;
	int	ret;
	int	signals;
	char*	which;
	jmp_buf	gotcha;
} state;

static void
report(char* comment, char* re, char* s, int flags)
{
	state.failures++;
	sfprintf(sfstdout, "%d:", state.lineno);
	if(re) {
		sfprintf(sfstdout, "%s", re);
		if(s)
			sfprintf(sfstdout, " versus %s", s);
	}
	sfprintf(sfstdout, " %s%s %s", state.which, (flags & REG_NOSUB) ? " NOSUB" : "", comment);
}

static void
bad(char* comment, char* re, char* s)
{
	sfprintf(sfstdout,  "bad test case ");
	report(comment, re, s, 0);
	exit(1);
}

static void
doregerror(regex_t* preg, int code, int lineno)
{
	char*	msg;
	char	buf[200];

	switch (code)
	{
	case REG_EBUS:
		msg = "bus error";
		break;
	case REG_EFAULT:
		msg = "memory fault";
		break;
	case REG_ELOOP:
		msg = "did not terminate";
		break;
	default:
		regerror(code, preg, msg = buf, sizeof buf);
		break;
	}
	sfprintf(sfstdout, "%s\n", msg);
}

static int
readfield(char* f, char end)
{
	int	c;

	for(;;) {
		*f = 0;
		c = sfgetc(sfstdin);
		if(c == EOF)
			return 1;
		if(c == end)
			break;
		if(c == '\n')
			return 1;
		*f++ = c;
	} 
	if(c == '\t') {
		while(c == end)
			c = sfgetc(sfstdin);
		sfungetc(sfstdin, c);
	}
	return 0;
}

static int
hex(int c)
{
	return	isdigit(c) ? c-'0' :
		isupper(c) ? c-'A' :
		c-'a'+10;
}

static void
escape(char* s)
{
	char*	t;

	for(t=s; *t=*s; s++, t++) {
		if(*s != '\\')
			continue;
		switch(*++s) {
		case 0:
			*++t = 0;
			break;
		case 'n':
			*t = '\n';
			break;
		case 'x':
			if(!isxdigit(s[1]) || !isxdigit(s[2]))
				bad("bad \\x\n", NiL, NiL);
			*t = hex(*++s) << 4;
			*t |= hex(*++s);
			break;
		default:
			s--;
		}
	}
}

static int
readline(char* spec, char* re, char* s, char* ans)
{
	int	c;

	switch(c = sfgetc(sfstdin)) {
	case EOF:
		return 0;
	case '#':
		while(c != '\n')
			c = sfgetc(sfstdin);
	case '\n':
		*spec = 0;
		return 1;
	}
	sfungetc(sfstdin, c);
	if(readfield(spec, '\t')) return 0;
	if(readfield(re, '\t')) return 0;
	if(readfield(s, '\t')) return 0;
	if(readfield(ans, '\n')) return 0;
	escape(re);
	escape(s);
	return 1;
}

static void
matchprint(regmatch_t* match, int nmatch)
{
	int	i;

	for( ; nmatch>0; nmatch --)
		if(match[nmatch-1].rm_so != -1)
			break;
	for(i=0; i<nmatch; i++) {
		sfprintf(sfstdout, "(");
		if(match[i].rm_so == -1)
			sfprintf(sfstdout, "?");
		else
			sfprintf(sfstdout, "%d", match[i].rm_so);
		sfprintf(sfstdout, ",");
		if(match[i].rm_eo == -1)
			sfprintf(sfstdout, "?");
		else
			sfprintf(sfstdout, "%d", match[i].rm_eo);
		sfprintf(sfstdout, ")");
	}
	sfprintf(sfstdout, "\n");
}

static int
matchcheck(int nmatch, regmatch_t* match, char* ans, char* re, char* s, int flags)
{
	char*	p;
	int	i;
	int	m;
	int	n;

	for(i = 0, p = ans; i<nmatch && *p; i++) {
		if(*p++ != '(')
			bad("improper answer\n", re, s);
		if(*p == '?') {
			m = -1;
			p++;
		} else
			m = strtol(p, &p, 10);
		if(*p++ != ',')
			bad("improper answer\n", re, s);
		if(*p == '?') {
			n = -1;
			p++;
		} else
			n = strtol(p, &p, 10);
		if(*p++ != ')')
			bad("improper answer\n", re, s);
		if(m!=match[i].rm_so || n!=match[i].rm_eo) {
			report("match was: ", re, s, flags);
			matchprint(match, nmatch);
			return 0;
		}
	}
	for( ; i<nmatch; i++) {
		if(match[i].rm_so!=-1 || match[i].rm_eo!=-1) {
			report("match was: ", re, s, flags);
			matchprint(match, nmatch);
			return 0;
		}
	}
	return 1;
}

static void
gotcha(int sig)
{
	signal(sig, gotcha);
	alarm(0);
	state.signals++;
	switch (sig)
	{
	case SIGALRM:
		state.ret = REG_ELOOP;
		break;
	case SIGBUS:
		state.ret = REG_EBUS;
		break;
	case SIGSEGV:
		state.ret = REG_EFAULT;
		break;
	}
	sigunblock(sig);
	longjmp(state.gotcha, 1);
}

static void*
stkresize(void* handle, void* p, size_t n)
{
	void*	x;

	if (!n || !(x = stkalloc((Stk_t*)handle, n)))
		return 0;
	if (p)
		memcpy(x, p, n / 2);
	return x;
}

main(int argc, char** argv)
{
	regmatch_t	NOMATCH;
	int		flags;
	int		cflags;
	int		eflags;
	int		are;
	int		bre;
	int		ere;
	int		kre;
	int		lre;
	int		sre;
	char		spec[10];
	char		re[1000];
	char		s[100000];
	char		ans[500];
	char		msg[500];
	regmatch_t	match[100];
	regex_t		preg;
	char*		p;
	int		nmatch;
	int		cret;
	int		eret;
	int		i;
	int		expected;
	int		got;
	int		len;

	int		catch = 0;
	int		testno = 0;
	int		verbose = 0;
	off_t		stk = -1;

	sfprintf(sfstdout, "TEST	<regex>");
	while((p = *++argv) && *p == '-')
		for(;;)
		{
			switch(*++p)
			{
			case 0:
				break;
			case 'c':
				catch = 1;
				sfprintf(sfstdout, ", catch");
				continue;
			case 's':
#ifdef REG_AUGMENTED
				stk = stktell(stkstd);
				regalloc((void*)stkstd, stkresize, REG_NOFREE);
				sfprintf(sfstdout, ", stkstd");
#endif
				continue;
			case 'v':
				verbose = 1;
				sfprintf(sfstdout, ", verbose");
				continue;
			default:
				sfprintf(sfstdout, ", invalid option %c", *p);
				continue;
			}
			break;
		}
	if(p)
		sfprintf(sfstdout, ", argument(s) ignored");
	sfprintf(sfstdout, "\n");
	if(catch) {
		signal(SIGALRM, gotcha);
		signal(SIGBUS, gotcha);
		signal(SIGSEGV, gotcha);
	}
	NOMATCH.rm_so = -2;
	NOMATCH.rm_eo = -2;
	while(readline(spec, re, s, ans)) {
		state.lineno++;
		if(*spec == 0)
			continue;
		sfsync(sfstdout);

	/* interpret: */

		cflags = eflags = are = bre = ere = kre = lre = sre = 0;
		nmatch = 20;
		for(p=spec; *p; p++) {
			if(isdigit(*p)) {
				nmatch = strtol(p, &p, 10);
				p--;
				continue;
			}
			switch(*p) {

			case 'A':
				are = 1;
				continue;
			case 'B':
				bre = 1;
				continue;
			case 'E':
				ere = 1;
				continue;
			case 'K':
				kre = 1;
				continue;
			case 'L':
				lre = 1;
				continue;
			case 'S':
				sre = 1;
				continue;

			case 'I':
				cflags |= REG_ICASE;
				continue;
			case 'M':
				cflags |= REG_MINIMAL;
				continue;
			case 'U':
				cflags |= REG_NULL;
				continue;
			case 'W':
				cflags |= REG_NEWLINE;
				continue;

			case 'a':
				cflags |= REG_LEFT|REG_RIGHT;
				continue;
			case 'b':
				eflags |= REG_NOTBOL;
				continue;
			case 'e':
				eflags |= REG_NOTEOL;
				continue;
			case 'l':
				cflags |= REG_LEFT;
				continue;
			case 'r':
				cflags |= REG_RIGHT;
				continue;

			case '?':
				continue;

			default:
				bad("bad spec\n", re, s);

			}
		}
		if(streq(re, "NULL"))
			re[0] = 0;
		if(streq(s, "NULL"))
			s[0] = 0;
		if((cflags|eflags) == NOTEST)
			continue;

	compile:

		if(bre) {
			state.which = "BRE";
			bre = 0;
			flags = cflags;
		}
		else if(ere) {
			state.which = "ERE";
			ere = 0;
			flags = cflags | REG_EXTENDED;
		}
#ifdef REG_AUGMENTED
		else if(are) {
			state.which = "ARE";
			are = 0;
			flags = cflags | REG_AUGMENTED;
		}
#endif
#ifdef REG_LITERAL
		else if(lre) {
			state.which = "LRE";
			lre = 0;
			flags = cflags | REG_LITERAL;
		}
#endif
#ifdef REG_SHELL
		else if(sre) {
			state.which = "SRE";
			sre = 0;
			flags = cflags | REG_SHELL;
		}
#ifdef REG_AUGMENTED
		else if(kre) {
			state.which = "KRE";
			kre = 0;
			flags = cflags | REG_SHELL | REG_AUGMENTED;
		}
#endif
#endif
		else
			continue;
		if(verbose)
			sfprintf(sfstdout, "test %-3d %s \"%s\" \"%s\"\n", state.lineno, state.which, re, s);

	nosub:

		testno++;
		if(catch) {
			if(setjmp(state.gotcha))
				cret = state.ret;
			else {
				alarm(LOOPED);
				cret = regcomp(&preg, re, flags);
				alarm(0);
			}
		} else
			cret = regcomp(&preg, re, flags);
		if(cret == 0) {
			if(!streq(ans, "NULL") &&
			   !streq(ans, "NOMATCH") &&
			   ans[0]!='(') {
				report("regcomp should fail and didn't\n", re, NiL, flags);
				continue;
			}
		} else {
			if(streq(ans, "NULL") ||
			   ans[0]=='(' ||
			   cret==REG_BADPAT && streq(ans, "NOMATCH")) {
				report("regcomp failed: ", re, NiL, flags);
				doregerror(&preg, cret, state.lineno);
			} else {
				expected = got = 0;
				for(i=1; i<elementsof(codes); i++) {
					if(streq(ans, codes[i].name))
						expected = i;
					if(cret==codes[i].code)
						got = i;
				}
				if(!expected)
				{
					report("invalid error code: ", re, NiL, flags);
					sfprintf(sfstdout, "%s expected, %s returned\n", ans, codes[got].name);
				}
				else if(cret!=codes[expected].code && cret!=REG_BADPAT) {
					report("regcomp should fail and did: ", re, NiL, flags);
					sfprintf(sfstdout, "%s expected, %s returned: ", ans, codes[got].name);
					state.failures--;
					state.goofs++;
					doregerror(&preg, cret, state.lineno);
				}
			}
			goto compile;
		}

	/* execute: */
		
		for(i=0; i<elementsof(match); i++)
			match[i] = NOMATCH;

		if(catch) {
			if(setjmp(state.gotcha))
				eret = state.ret;
			else {
				alarm(LOOPED);
				eret = regexec(&preg, s, nmatch, match, eflags);
				alarm(0);
			}
		} else
			eret = regexec(&preg, s, nmatch, match, eflags);

		if(flags & REG_NOSUB) {
			if(eret) {
				report("regexec REG_NOSUB failed: ", re, s, flags);
				doregerror(&preg, eret, state.lineno);
			}
		} else if(eret) {
			if(!streq(ans, "NOMATCH")) {
				report("regexec failed", re, s, flags);
				if(eret != REG_NOMATCH) {
					sfprintf(sfstdout, ": ");
					doregerror(&preg, eret, state.lineno);
				} else
					sfprintf(sfstdout, "\n");
			}
		} else if(streq(ans, "NOMATCH")) {
			report("regexec should fail and didn't: ", re, s, flags);
			matchprint(match, nmatch);
		} else if(streq(ans, "NULL")) {
			if(match[0].rm_so != NOMATCH.rm_so) {
				report("no match but match array assigned: ", re, s, flags);
				matchprint(match, nmatch);
			}
		} else if (matchcheck(nmatch, match, ans, re, s, flags)) {
			if(stk >= 0)
				stkseek(stkstd, stk);
			else
				regfree(&preg);
			flags |= REG_NOSUB;
			goto nosub;
		}
		if(stk >= 0)
			stkseek(stkstd, stk);
		else
			regfree(&preg);
		goto compile;
	}
	sfprintf(sfstdout, "TEST	<regex>, %d tests", testno);
	if(state.goofs)
		sfprintf(sfstdout, ", %d goofs", state.goofs);
	if(state.signals)
		sfprintf(sfstdout, ", %d signals", state.signals);
	sfprintf(sfstdout, ", %d errors\n", state.failures);
	return 0;
}
