<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<META name="generator" content="mm2html (AT&T Labs Research) 2007-02-09">
<META name="description" content="ast-open package">
<META name="keywords" content="software, package">
<TITLE> ast-open package </TITLE>
<META name="author" content="gsf+dgk+kpv">
</HEAD>
<BODY bgcolor=white link=slateblue vlink=teal >
<TABLE border=0 align=center width=96%>
<TBODY><TR><TD valign=top align=left>
<!--INDEX--><!--/INDEX-->
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="ast-open package">ast-open package</A></H3></FONT></FONT></CENTER>
The AT&amp;T Software Technology ast-open package from AT&amp;T Research
contains all of the ast open source commands and libraries.
Components in this package:
<P>
<P></P><TABLE border=0 frame=void rules=none width=100%><TBODY><TR><TD>
<TABLE align=center border=0 bordercolor=white cellpadding=0 cellspacing=0 frame=void rules=none width=99% >
<TBODY>
<TR><TD align=left>
<A href="#3d">3d</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;dss&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;pack&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#std">std</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libcmd&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libpz</TD></TR>
<TR><TD align=left>
<A href="#at">at</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;dsslib&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#pax">pax</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;tests&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libcodex&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;librecsort</TD></TR>
<TR><TD align=left>
<A href="#builtin">builtin</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;html&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;paxlib&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#tksh">tksh</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libcoshell&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libsum</TD></TR>
<TR><TD align=left>
bzip&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#ie">ie</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;probe&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#tw">tw</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libcs&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libtk</TD></TR>
<TR><TD align=left>
codex&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#ksh93">ksh93</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#proto">proto</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;vczip&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libdll&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#libtksh">libtksh</A></TD></TR>
<TR><TD align=left>
codexlib&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;mailx&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#pzip">pzip</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#warp">warp</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libdss&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libuu</TD></TR>
<TR><TD align=left>
<A href="#coshell">coshell</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;mam&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;re&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libardir&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libexpr&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libvcodex</TD></TR>
<TR><TD align=left>
cpp&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#msgcc">msgcc</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#sort">sort</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libast&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libmam&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libvdelta</TD></TR>
<TR><TD align=left>
cql&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;ncsl&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;sortlib&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libbz&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libodelta&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libz</TD></TR>
<TR><TD align=left>
cs&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;<A href="#nmake">nmake</A>&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;ss&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libcdb&nbsp;&nbsp;</TD><TD align=left>&nbsp;&nbsp;libpp</TD></TR>
</TBODY></TABLE></TD></TR></TBODY></TABLE>
<P>
This package is a superset of the following packages: ast-base ast-make ast-ksh ksh ast-ast; you won't need these if you download ast-open.
A recent
	<A href="#release change log">release change log</A>
is also included.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="3d">3d</A></H3></FONT></FONT></CENTER>
<STRONG>3d</STRONG>
is the historical name for
<EM>n</EM><STRONG>DFS</STRONG><EM>,</EM>
the multiple dimension file system.
It is implemented as a shared library that is preloaded
before any other shared library using the recently documented
(<EM>ahem</EM>)
<STRONG>LD_PRELOAD</STRONG>
or
<STRONG>_RLD_LIST</STRONG>
feature of the runtime linker.
<STRONG>3d</STRONG>
intercepts pathname system calls (and other calls if tracing is
turned on) and provides a logical namespace on top of the underlying
physical file system.
The shared library implementation currently works
only on
<EM>bsd.i386</EM>,
<EM>linux.i386</EM>,
<EM>osf.alpha</EM>,
<EM>sun4</EM>,
<EM>sol.*</EM>,
and
<EM>sgi.*</EM>.
<P>
<STRONG>3d</STRONG>
works in conjunction with
<STRONG>ksh88</STRONG>
or
<STRONG>ksh93</STRONG>.
The
<STRONG>3d</STRONG>
command with no arguments enters a
<STRONG>3d</STRONG>
shell.
The
<STRONG>vpath</STRONG>
builtin controls the logical
filesystem view:
<PRE>
     vpath dir_1 dir_2
</PRE>
mounts the directory hierarchy
<EM>dir_1</EM>
on top of
<EM>dir_2</EM>.
Files under
<EM>dir_1</EM>
overlay files under
<EM>dir_2</EM>.
Files under
<EM>dir_2</EM>
are readonly;
any files under
<EM>dir_2</EM>
that are modified are first copied to the
corresponding place in
<EM>dir_1</EM>.
<EM>vpaths</EM>
may be chained:
<PRE>
     vpath dir_2 dir_3
</PRE>
<EM>vpaths</EM>
are per-process; every process may have a different view.
<EM>vpaths</EM>
are a handy way to separate source and generated files.
Typical
<STRONG>advsoft</STRONG>
users set up
<STRONG>3d</STRONG>
at login or
<STRONG>xterm</STRONG>
time:
<PRE>
     export HOSTTYPE=$(package)
     vpath $HOME/arch/$HOSTTYPE $HOME
</PRE>
with source files in
<TT>$HOME/src/(cmd|lib)/*</TT>.
<STRONG>nmake</STRONG>
is run in
<TT>$HOME/arch/$HOSTTYPE/src/(cmd|lib)/*</TT>
and generated files (objects and executables) are dropped in the top hierarchy.
<P>
<STRONG>2d</STRONG>
can prefix any command to disable 
<STRONG>3d</STRONG>
for that command:
<PRE>
     2d ls *.c
</PRE>
<P>
<STRONG>3d</STRONG>
also provides tracing, monitoring and call intercept services.
<STRONG>vpm</STRONG>
uses monitoring to graph the process and io hierarchy.
The
<EM>cs</EM>
name server uses pathname call intercepts to translate network
pathnames.
Try this for any host:
<PRE>
     cat /dev/tcp/hostname/inet.daytime
</PRE>
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="at">at</A></H3></FONT></FONT></CENTER>
The
<STRONG>ast</STRONG>
<STRONG>at</STRONG>
command is a re-implementations of
<NOBR><A href="/~gsf/man/man1/at.html"><STRONG>at</STRONG></A>(1)</NOBR>
and
<NOBR><A href="/~gsf/man/man1/crontab.html"><STRONG>crontab</STRONG></A>(1),</NOBR>
including a
<NOBR><A href="/~gsf/man/man1/cs.html"><STRONG>cs</STRONG></A>(1)</NOBR>
service \bat.svc\b for the \bat\b and \bcron\b daemons.
On most systems the
<STRONG>at</STRONG>
and
<STRONG>crontab</STRONG>
commands are installed as
<STRONG>ast_at</STRONG>
and
<STRONG>ast_crontab</STRONG>
because the \bat\b service executor \b$INSTALLROOT/lib/at/jobs/atx\b must be
installed setuid \broot\b so the daemon can operate multi-user
(enabling \broot\b privelege is always a manual operation with
<NOBR><A href="/~gsf/man/man1/package.html"><STRONG>package</STRONG></A>(1)</NOBR>
packages.)
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="builtin">builtin</A></H3></FONT></FONT></CENTER>
The
<STRONG>ast</STRONG>
<STRONG>builtin</STRONG>
commands are stand-alone implementations of the section
<STRONG>1</STRONG>
command in
<NOBR><A href="/~gsf/man/man3/libcmd.html"><STRONG>libcmd</STRONG></A>(3).</NOBR>
See the
<NOBR><A href="/~gsf/man/man1/ksh.html"><STRONG>ksh</STRONG></A>(1)</NOBR>
<STRONG>builtin</STRONG>(1)
command for information on loading command DLLs at runtime.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="coshell">coshell</A></H3></FONT></FONT></CENTER>
<STRONG>coshell</STRONG>
executes blocks of shell commands on lightly loaded hosts in the local network.
There is one
<STRONG>coshell</STRONG>
server per user.
This server runs as a daemon on the user's home host,
and only processes running on the home host have access to the server.
The server controls a background
<STRONG>ksh</STRONG>
shell process, initiated by
<STRONG>rsh</STRONG>,
on each of the connected hosts.
<P>
<STRONG>coshell</STRONG>
is easy to use and administer.
The only privilege required for installation, administration or use is
<STRONG>rsh</STRONG>
access to the local hosts.
<STRONG>coshell</STRONG>
does requires a uniform file namespace across all hosts on the local network.
<P>
<STRONG>nmake</STRONG>
and
<STRONG>gmake</STRONG>
users can take advantage of network execution with
no makefile modifications.
Shell level access is similar to but more efficient than
<STRONG>rsh</STRONG>
and allows host expression matching to replace the explicit host name argument.
<P>
Factor of 5 compilation speedups are typical.
<P>
To start your local daemon:
<PRE>
     coshell +
</PRE>
To send
<STRONG>nmake</STRONG>
or
<STRONG>gmake</STRONG>
actions to
<STRONG>coshell</STRONG>
at concurrency level 8:
<PRE>
     export COSHELL=coshell
     export NPROC=8
</PRE>
To run shell commands on a lightly loaded host:
<PRE>
     coshell -r - 'hostname; sort a &gt; b' &amp;
     pid=$!
     # other stuff
     wait $pid
</PRE>
For interactive
<STRONG>coshell</STRONG>
status:
<PRE>
     coshell -
     coshell&gt; s
     <EM> ... status ...</EM>
     coshell&gt; h
     <EM> ... help ...</EM>
     coshell&gt; q
</PRE>
<STRONG>package</STRONG>
generates static host information and
<STRONG>ss</STRONG>
lists the dynamic status of hosts on the local network.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="ie">ie</A></H3></FONT></FONT></CENTER>
<STRONG>ie</STRONG>
executes a dynamically linked command with the
<NOBR><A href="/~gsf/man/man1/ksh.html"><STRONG>ksh</STRONG></A>(1)</NOBR>
input line edit discipline pushed on the standard input.
All child processes will also have input line editing enabled.
<P>
<STRONG>ie</STRONG>
intercepts the
<NOBR><A href="/~gsf/man/man3/read.html"><STRONG>read</STRONG></A>(3)</NOBR>
system call by preloading a DLL (shared library) at runtime,
so it only works on architectures that support DLL preload.
Statically-linked, set-uid or set-gid commands will not work with
<STRONG>ie</STRONG>.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="ksh93">ksh93</A></H3></FONT></FONT></CENTER>
KSH-93 is the most recent version of the KornShell Language
described in
"The KornShell Command and Programming Language,"
by Morris Bolsky and David Korn of AT&amp;T Bell Laboratories, ISBN 0-13-182700-6.
The KornShell is a shell programming language,
which is upward compatible with "sh" (the Bourne Shell),
and is intended to conform to the IEEE P1003.2/ISO 9945.2 Shell and
Utilities standard.
KSH-93 provides an enhanced programming environment in
addition to the major command-entry features of the BSD
shell "csh".  With KSH-93, medium-sized programming tasks can be
performed at shell-level without a significant loss in performance.
In addition, "sh" scripts can be run on KSH-93 without modification.
<P>
The code should conform to the IEEE POSIX 1003.1 standard and to the
proposed ANSI-C standard so that it should be portable to all
such systems.  Like the previous version, KSH-88,
it is designed to accept eight bit character sets
transparently, thereby making it internationally compatible.
It can support multi-byte characters sets with some characteristics
of the character set given at run time.
<P>
KSH-93 provides the following features, many of which were also inherent
in KSH-88:
<UL type=square>
<LI>
Enhanced Command Re-entry Capability:  The KSH-93 history
function records commands entered at any shell level and stores
them, up to a user-specified limit, even after you log off.
This allows you to re-enter long commands with a few keystrokes
- even those commands you entered yesterday.
The history file allows for eight bit characters in
commands and supports essentially unlimited size histories.
<LI>
In-line Editing: In "sh", the only way to fix mistyped
commands is to backspace or retype the line. KSH-93 allows you
to edit a command line using a choice of EMACS-TC or "vi"
functions.
You can use the in-line editors to complete filenames as
you type them.
You may also use this editing feature when entering
command lines from your history file.
A user can capture keystrokes and rebind keys to customize the
editing interface.
<LI>
Extended I/O Capabilities:  KSH-93 provides several I/O
capabilities not available in "sh", including the ability to:
<UL type=circle>
<LI>
specify a file descriptor for input and output
<LI>
start up and run co-processes
<LI>
produce a prompt at the terminal before a read
<LI>
easily format and interpret responses to a menu
<LI>
echo lines exactly as output without escape processing
<LI>
format output using printf formats.
<LI>
read and echo lines ending in "&#0092;".
</UL>
<LI>
Improved performance: KSH-93 executes many scripts faster
than the System V Bourne shell. A major reason for this is
that many of the standard utilities are built-in.
To reduce the time to initiate a command, KSH-93 allows
commands to be added as built-ins at run time
on systems that support dynamic loading such as System V Release 4.
<LI>
Arithmetic: KSH-93 allows you to do integer arithmetic in any
base from two to sixty-four.  You can also do double
precision floating point arithmetic.
Almost the complete set of C language operators are available
with the same syntax and precedence.
Arithmetic expressions can be used to as an argument expansion 
or as a separate command.
In addition there is an arithmetic for command that works
like the for statement in C.
<LI>
Arrays: KSH-93 supports both indexed and associative arrays.
The subscript for an indexed array is an arithmetic expression,
whereas, the subscript for an associative array is a string.
<LI>
Shell Functions and Aliases: Two mechanisms - functions and
aliases - can be used to assign a user-selected identifier to
an existing command or shell script.
Functions allow local variables and provide scoping
for exception handling.
Functions can be searched for and loaded on first reference the
way scripts are.
<LI>
Substring Capabilities:  KSH-93 allows you to create a
substring of any given string either by specifying the starting
offset and length, or by stripping off leading
or trailing substrings during parameter substitution.
You can also specify attributes, such as upper and lower case,
field width, and justification to shell variables.
<LI>
More pattern matching capabilities:  KSH-93 allows you to specify
extended regular expressions for file and string matches.
<LI>
KSH-93 uses a hierarchal name space for variables.
Compound variables can be defined and variables can
be passed by reference.  In addition, each variable
can have one or more disciplines associated with
it to intercept assignments and references.
<LI>
Improved debugging:  KSH-93 can generate line numbers on execution
traces.  Also, I/O redirections are now traced.
There is a DEBUG trap that gets evaluated after each command
so that errors can be localized.
<LI>
Job Control: On systems that support job control, including
System V Release 4, KSH-93
provides a job-control mechanism almost identical to that of
the BSD "csh", version 4.1.
This feature allows you
to stop and restart programs, and to move programs between the
foreground and the background.
<LI>
Added security:
KSH-93 can execute scripts which do not have read permission
and scripts which have the setuid and/or setgid set when
invoked by name, rather than as an argument to the shell.
It is possible to log or control the execution of setuid and/or
setgid scripts.
The noclobber option prevents you from accidentally erasing
a file by redirecting to an existing file.
<LI>
KSH-93 can be extended by adding built-in commands at run time.
In addition, KSH-93 can be used as a library that can
be embedded into an application to allow scripting.
</UL>
Documentation for KSH-93 consists of an "Introduction to KSH-93",
"Compatibility with the Bourne Shell" and a manual page and a
README file.  In addition, the "New KornShell Command and Programming
Language," book is available from Prentice Hall.

<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="msgcc">msgcc</A></H3></FONT></FONT></CENTER>
<STRONG>msgcc</STRONG>
and
<STRONG>msgcpp</STRONG>
extract message text from C source for
<NOBR><A href="/~gsf/man/man1/gencat.html"><STRONG>gencat</STRONG></A>(1)</NOBR>
message catalogs.
<NOBR><A href="/~gsf/man/man1/msggen.html"><STRONG>msggen</STRONG></A>(1)</NOBR>
is a
<NOBR><A href="/~gsf/man/man1/gencat.html"><STRONG>gencat</STRONG></A>(1)</NOBR>
replacement that generates machine independent binary message
catalogs that are compatible with the
<STRONG>ast</STRONG>
<NOBR><A href="/~gsf/man/man3/catgets.html"><STRONG>catgets</STRONG></A>(3)</NOBR>
implementation.
<STRONG>catgets</STRONG>
also supports native message catalogs where available.
<NOBR><A href="/~gsf/man/man1/msgcvt.html"><STRONG>msgcvt</STRONG></A>(1)</NOBR>
and
<NOBR><A href="/~gsf/man/man1/msgadmin.html"><STRONG>msgadmin</STRONG></A>(1)</NOBR>
are administrative commands that support machine translation
of C locale message catalogs.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="nmake">nmake</A></H3></FONT></FONT></CENTER>
<STRONG>nmake</STRONG>
is the AT&amp;T
<STRONG>nmake</STRONG>,
first released in 1985.
<STRONG>nmake</STRONG>
is a modern variant of the traditional Feldman
<STRONG>make</STRONG>
with an important difference:
<STRONG>nmake</STRONG>
maintains state that records
information for future runs.
The state includes:
<UL type=square>
<LI>
file modification times
<LI>
explicit prerequisites (from makefile assertions)
<LI>
implicit prerequisites (from
<EM>#include</EM>
scanning)
<LI>
action text (used to build targets)
<LI>
variable values
<LI>
target attributes
</UL>
State
<EM>and</EM>
a language to manipulate it finally makes concise
makefiles a reality; concise because rules traditionally placed in
each makefile can now be implemented in a general way in a single
<EM>base rules</EM>
file.
The base rules are such a fundamental part of
<STRONG>nmake</STRONG>
that most of its visible features are controlled by them.
<P>
Most makefiles are just a few lines:
<PRE>
     :PACKAGE: X11
     
     xgame :: README xgame.6 xgame.h xgame.c xutil.c -lXaw -lXmu -lXt
</PRE>
Automatically generated
<STRONG>probe</STRONG>
information provides convenient compiler abstractions:
<PRE>
     CCFLAGS = $(CC.DLL)
     
     ast 4.0 :LIBRARY: ast.c strmatch.c
</PRE>
In this case if the compiler supports
shared libraries (aka <STRONG>dll</STRONG><EM>s</EM>) then
<TT>nmake install</TT>
will generate
<EM>libast.a</EM>
and
<EM>libast.so.4.0</EM>
(or the appropriate shared library suffix determined by
<STRONG>CC.SUFFIX.SHARED</STRONG>).
There are no
<STRONG>nmake</STRONG>
makefile generators (because the makefiles are so small),
there is no separate
<TT>make depend</TT>
(because the files with
<EM>.SCAN</EM>
attributes are automatically scanned for implicit prerequisites),
and there is no cheating (because all time stamp changes
are detected, not just
<EM>newer-than</EM>).
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="pax">pax</A></H3></FONT></FONT></CENTER>
<STRONG>pax</STRONG>
is a POSIX 1003.2 conformant replacement for
<STRONG>tar</STRONG>
and
<STRONG>cpio</STRONG>
that handles most UNIX archive and tape formats.
<STRONG>pax</STRONG>
uses the
<EM>vdelta</EM>
algorithm to construct efficient delta archives that contain bytewise
changes from a given base archive. 
<STRONG>gzip</STRONG>
and
<STRONG>compress</STRONG>
archives are also handled on input and output.
<P>
To create a
<EM>vdelta</EM>
compressed base archive:
<PRE>
     tw | pax -w -f base -z -
</PRE>
To create a delta archive on the base above (record file changes only):
<PRE>
     tw | pax -w -f delta -z base
</PRE>
To read the delta archive:
<PRE>
     pax -r -f delta -z base
</PRE>
To create a delta archive from linux-1.2.0 to linux-1.2.5:
<PRE>
     pax -rf linux-1.2.5.tar.gz -wf 0-5.pax.gz -x gzip -z linux-1.2.0.tar.gz
</PRE>
To create the linux-1.2.5 archive:
<PRE>
     pax -rf 0-5.pax.gz -z linux-1.2.0.tar.gz -wf linux-1.2.5.tar.gz -x tar -x gzip
</PRE>
The
<STRONG>bax</STRONG>
script, shipped with
<STRONG>pax</STRONG>,
combines
<STRONG>tw</STRONG>
and
<STRONG>pax</STRONG>
for handy backup control.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="proto">proto</A></H3></FONT></FONT></CENTER>
<STRONG>proto</STRONG>
converts ANSI C prototype constructs to constructs compatible
with K&amp;R C, ANSI C, and C++.
Only files with the line
<PRE>
     #pragma prototyped
</PRE>
in the first 64 lines are processed; other files are silently ignored.
This is how
<STRONG>advsoft</STRONG>
source is first shipped to foreign architectures.
Once
<STRONG>advsoft</STRONG>
is bootstrapped the
non-<STRONG>proto</STRONG>
source can be built using the
<STRONG>advsoft</STRONG>
tools.
<P>
<STRONG>proto</STRONG>
also converts in the other direction by providing
<EM>extern</EM>
prototypes for a collection of K&amp;R source files and by converting
K&amp;R source files in place.
K&amp;R to ANSI is not 100%, but is a good starting point for manual conversion.
<P>
<STRONG>proto</STRONG>
is token based (no C grammar); this allows it to convert 
before C preprocessing, and also allows
<STRONG>proto</STRONG>
to be inserted into
the standalone
<STRONG>cpp</STRONG>.
This is how
<STRONG>nmake</STRONG>
compiles ANSI C source with K&amp;R compilers.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="pzip">pzip</A></H3></FONT></FONT></CENTER>
Fixed length record data is often viewed as a waste of space,
too sparse for production use.
Much effort is then put into optimizing
the data schema, and in the process complicating the data interface.
<STRONG>pzip</STRONG>
shows that in many cases this view of fixed length data is wrong.
In fact, variable length data may become more compressible when
converted to a sparse, fixed length format.
Intense semantic schema
analysis can be replaced by an automated record partition, resulting in
compression space improvements of 2 to 10 times and decompression speed
improvements of 2 to 3 times over
<STRONG>gzip</STRONG>
for a large class of data.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="sort">sort</A></H3></FONT></FONT></CENTER>
<STRONG>sort</STRONG>
is a POSIX 1003.2 conformant implementation based on
<STRONG>-lrecsort</STRONG>
by Phong Vo and Glenn Fowler with key encoding by Doug McIlroy.
The
<STRONG>recsort</STRONG>
discipline/method interface allows
<STRONG>sort</STRONG>
to double as a test harness for different sort algorithms.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="std">std</A></H3></FONT></FONT></CENTER>
The
<STRONG>ast</STRONG>
<STRONG>std</STRONG>
commands are re-implementations of some of the standard section
<STRONG>1</STRONG>
commands.
On most systems the
<STRONG>mount</STRONG>
and
<STRONG>ps</STRONG>
commands are installed as
<STRONG>ast_mount</STRONG>
and
<STRONG>ast_ps</STRONG>
because the author either could not keep up with option proliferation or
the commands must be installed with sufficient privelege to operate
multi-user.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="tksh">tksh</A></H3></FONT></FONT></CENTER>
<EM>tksh</EM>
is an implementation of the Tcl C library
written on top of the library for the new KornShell
(<EM>ksh93</EM>).
<EM>tksh</EM>
emulates the behavior of Tcl by using the API that is provided for extending
<EM>ksh93</EM>,
which is similar to the Tcl library in that it allows access to
variables, functions and other state of the interpreter.
This implementation requires no modification to
<EM>ksh93</EM>,
and allows Tcl libraries such as Tk to run on top of
<EM>ksh93</EM>
unchanged,
making it possible to use shell scripts in
place of Tcl scripts. 
<EM>ksh93</EM>
is well suited for use with Tk because it is
backward compatible with
<EM>sh</EM>,
making it both easy to learn and easy to extend
existing scripts to provide a graphical user interface.
<P>
<EM>tksh</EM>
is not yet
another port of Tk to another language -- it allows Tcl scripts to run without
modification using the ksh93 internals.
This makes it possible to combine
Tcl and
<EM>ksh93</EM>,
which is useful for writing
<EM>ksh93</EM>
scripts that use components that have been implemented in Tcl
(such as Tk widgets).
<P>
<EM>tksh</EM>
was developed by
<A href="http://www.research.att.com/~jlk" target=_top>Jeff Korn</A>
and is distributed by
<A href="mailto:advsoft@research.att.com" target=_top>advsoft@research.att.com</A>.
For the latest information vist the
<EM>tksh</EM>
<A href="http://www.cs.princeton.edu/~jlk/tksh" target=_top>home page</A>.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="tw">tw</A></H3></FONT></FONT></CENTER>
<STRONG>tw</STRONG>
is a combination of
<STRONG>find</STRONG>
and
<STRONG>xargs</STRONG>
that applies C style expressions on the
<EM>stat</EM>
structure of each file in a directory hierarchy.
<PRE>
     tw
</PRE>
lists the directory hierarchy under the current directory,
<PRE>
     tw chmod go-rwx
</PRE>
changes the mode of all files in the directory hierarchy under the current
directory by calling
<STRONG>chmod</STRONG>
as few times as the
<EM>exec</EM>
arg limit allows.
<PRE>
     tw -d /usr/src -e "name=='*.&#0091;chly&#0093;'" grep FOOBAR
</PRE>
greps for
<STRONG>FOOBAR</STRONG>
in all the
<STRONG>C</STRONG>
source files in /usr/src. 
<P>
<STRONG>tw</STRONG>
efficiently prunes the file tree search; it follows symbolic
links by default (logical walk).
The
<STRONG>getconf</STRONG>
variable
<STRONG>PATH_RESOLVE</STRONG>
controls the default behavior for all
<STRONG>advsoft</STRONG>
commands:
<PRE>
     getconf PATH_RESOLVE - physical
</PRE>
sets the default to not follow symbolic links,
<STRONG>logical</STRONG>
to follow,
and
<STRONG>metaphysical</STRONG>
to follow only command line symbolic links
(corresponding to the -P, -L and -H command options that override the
default).
<PRE>
     tw -P -e type==LNK
</PRE>
does a physical walk that lists all symbolic links.
<PRE>
     tw -e "mtime&gt;='yesterday morning'"
</PRE>
lists all files modified since yesterday morning.
The magic file types from the
<STRONG>file</STRONG>
command are available in
<STRONG>tw</STRONG>
expressions
(<STRONG>tw</STRONG>
and
<STRONG>file</STRONG>
use the same library routine in
<STRONG>libast</STRONG>):
<PRE>
     tw -e "(mode &amp; 'u+s') &amp;&amp; magic == '*script*'" chmod u-s
</PRE>
finds all setuid scripts and turns off the setuid mode bit.
The magic file also contains MIME types:
<PRE>
     tw -e "mime == '*/exe'"
</PRE>
lists all executable programs
(<EM>a.out</EM>'s).
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="warp">warp</A></H3></FONT></FONT></CENTER>
<STRONG>warp</STRONG>
executes a dynamically linked command in a different time frame.
It intercepts time related system calls and modifies the times seen by
the command using the formula:
<PRE>
     time' = time + warp + (time - base) * (factor - 1)
</PRE>
where:
<UL type=square>
<LI>
<EM>time'</EM>
The logical system time seen by the command process.
<LI>
<EM>time</EM>
The physical system time.
<LI>
<EM>warp</EM>
A fixed offset from the physical system time
(i.e., the warp.)
<LI>
<EM>base</EM>
The physical system time when
<STRONG>warp</STRONG>
was first applied to the process or any ancestor process.
<LI>
<EM>factor</EM>
The rate of logical time change with respect to the physical clock
(i.e., the warp factor.)
</UL>
<EM>warp</EM>,
<EM>base</EM>,
and
<EM>factor</EM>
are inherited by children of warped processes so that a child process
is warped in the same time frame as its parent.
Time progresses for warped processes at the rate of
<EM>factor</EM>
times the physical system clock.
Any files created by a warped process
will appear to be in the warped logical time frame
for that process but will appear in physical system time frame
for non-warped processes.
<P>
Statically-linked, set-uid or set-gid commands are not warped.
<P>
<H4>Interface</H4>
<STRONG>warp</STRONG>
&#0091;
<STRONG>&#45;b</STRONG>
<EM>base</EM>
&#0093; &#0091;
<STRONG>&#45;f</STRONG>
<EM>factor</EM>
&#0093; &#0091;
<STRONG>&#45;n</STRONG>
&#0093; &#0091;
<STRONG>&#45;t</STRONG>
&#0093;
<EM>date</EM>
&#0091;
<EM>command</EM>
&#0091;
<EM>arg</EM>
<!--NULL-->...
&#0093; &#0093;
<P>
The components of the warp formula are set as follows:
the warp offset
<EM>warp</EM>
is
<EM>date-now</EM>,
<EM>base</EM>
is
<EM>date</EM>
by default,
and
<EM>factor</EM>
is 1 by default.
<P>
Command argument date specifications support common conventions:
<PRE>
     yesterday
     next week
     50 days
     2000-02-28/00:00
     feb 28 2000
</PRE>
Absolute seconds since the epoch, a.k.a.
<STRONG>time_t</STRONG>
values, are represented by
<STRONG>#</STRONG><EM>seconds.</EM>
<P>
The
<STRONG>&#45;n</STRONG>
option shows how
<EM>command</EM>
would be executed without actually executing it.
The
<STRONG>&#45;t</STRONG>
option traces each intercepted system call.
<P>
<STRONG>warp</STRONG>
executes
<EM>command</EM>
with optional
<EM>args</EM>,
or
<STRONG>$SHELL</STRONG>
if
<EM>command</EM>
is omitted.
<P>
<H4>Examples</H4>
<PRE>
     $ date -f %Y-%m-%d/%H:%M
     1998-03-11/13:41
     $ warp 2000-02-29/12:30:30 date -f %Y-%m-%d/%H:%M
     2000-02-29/12:30
     $ date -f %Y-%m-%d/%H:%M
     1998-03-11/13:44
     $ warp +57060970 date
     2000-01-01/00:00
     
     # get a shell where 1 logical day passes for each physical second
     $ PS1='(warp) ' warp -f $(60*60*24) 2000-02-29/12:30:30
     (warp) date -f %Y-%m-%d/%H:%M
     2000-03-07/18:58
     (warp) sleep 1
     (warp) date -f %Y-%m-%d/%H:%M
     2000-03-19/18:58
</PRE>
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="tksh">tksh</A></H3></FONT></FONT></CENTER>
<EM>tksh</EM>
is an implementation of the Tcl C library
written on top of the library for the new KornShell
(<EM>ksh93</EM>).
<EM>tksh</EM>
emulates the behavior of Tcl by using the API that is provided for extending
<EM>ksh93</EM>,
which is similar to the Tcl library in that it allows access to
variables, functions and other state of the interpreter.
This implementation requires no modification to
<EM>ksh93</EM>,
and allows Tcl libraries such as Tk to run on top of
<EM>ksh93</EM>
unchanged,
making it possible to use shell scripts in
place of Tcl scripts. 
<EM>ksh93</EM>
is well suited for use with Tk because it is
backward compatible with
<EM>sh</EM>,
making it both easy to learn and easy to extend
existing scripts to provide a graphical user interface.
<P>
<EM>tksh</EM>
is not yet
another port of Tk to another language -- it allows Tcl scripts to run without
modification using the ksh93 internals.
This makes it possible to combine
Tcl and
<EM>ksh93</EM>,
which is useful for writing
<EM>ksh93</EM>
scripts that use components that have been implemented in Tcl
(such as Tk widgets).
<P>
<EM>tksh</EM>
was developed by
<A href="http://www.research.att.com/~jlk" target=_top>Jeff Korn</A>
and is distributed by
<A href="mailto:advsoft@research.att.com" target=_top>advsoft@research.att.com</A>.
For the latest information vist the
<EM>tksh</EM>
<A href="http://www.cs.princeton.edu/~jlk/tksh" target=_top>home page</A>.
<P>
<P><HR><CENTER><FONT color=red><FONT face=courier><H3><A name="release change log">release change log</A></H3></FONT></FONT></CENTER>
<PRE>

All recorded changes follow.
</PRE>
<P>
<HR>
<TABLE border=0 align=center width=96%>
<TR>
<TD align=left></TD>
<TD align=center></TD>
<TD align=right>April 09, 2007</TD>
</TR>
</TABLE>
<P>

</TD></TR></TBODY></TABLE>

</BODY>
</HTML>
